(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Dygraph = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the custom bars option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends Dygraph.DataHandlers.BarsHandler
 */
var CustomBarsHandler = function CustomBarsHandler() {};

CustomBarsHandler.prototype = new _bars2['default']();

/** @inheritDoc */
CustomBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point;
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      y = point[1];
      if (y !== null && !isNaN(y)) {
        series.push([x, y, [point[0], point[2]]]);
      } else {
        series.push([x, y, [y, y]]);
      }
    } else {
      series.push([x, null, [null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
CustomBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var y, low, high, mid, count, i, extremes;

  low = 0;
  mid = 0;
  high = 0;
  count = 0;
  for (i = 0; i < originalData.length; i++) {
    y = originalData[i][1];
    extremes = originalData[i][2];
    rollingData[i] = originalData[i];

    if (y !== null && !isNaN(y)) {
      low += extremes[0];
      mid += y;
      high += extremes[1];
      count += 1;
    }
    if (i - rollPeriod >= 0) {
      var prev = originalData[i - rollPeriod];
      if (prev[1] !== null && !isNaN(prev[1])) {
        low -= prev[2][0];
        mid -= prev[1];
        high -= prev[2][1];
        count -= 1;
      }
    }
    if (count) {
      rollingData[i] = [originalData[i][0], 1.0 * mid / count, [1.0 * low / count, 1.0 * high / count]];
    } else {
      rollingData[i] = [originalData[i][0], null, [null, null]];
    }
  }

  return rollingData;
};

exports['default'] = CustomBarsHandler;
module.exports = exports['default'];

},{"./bars":4}],2:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the error bars option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends BarsHandler
 */
var ErrorBarsHandler = function ErrorBarsHandler() {};

ErrorBarsHandler.prototype = new _bars2["default"]();

/** @inheritDoc */
ErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, variance, point;
  var sigma = options.get("sigma");
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      y = point[0];
      if (y !== null && !isNaN(y)) {
        variance = sigma * point[1];
        // preserve original error value in extras for further
        // filtering
        series.push([x, y, [y - variance, y + variance, point[1]]]);
      } else {
        series.push([x, y, [y, y, y]]);
      }
    } else {
      series.push([x, null, [null, null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
ErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var sigma = options.get("sigma");

  var i, j, y, v, sum, num_ok, stddev, variance, value;

  // Calculate the rolling average for the first rollPeriod - 1 points
  // where there is not enough data to roll over the full number of points
  for (i = 0; i < originalData.length; i++) {
    sum = 0;
    variance = 0;
    num_ok = 0;
    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
      y = originalData[j][1];
      if (y === null || isNaN(y)) continue;
      num_ok++;
      sum += y;
      variance += Math.pow(originalData[j][2][2], 2);
    }
    if (num_ok) {
      stddev = Math.sqrt(variance) / num_ok;
      value = sum / num_ok;
      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];
    } else {
      // This explicitly preserves NaNs to aid with "independent
      // series".
      // See testRollingAveragePreservesNaNs.
      v = rollPeriod == 1 ? originalData[i][1] : null;
      rollingData[i] = [originalData[i][0], v, [v, v]];
    }
  }

  return rollingData;
};

exports["default"] = ErrorBarsHandler;
module.exports = exports["default"];

},{"./bars":4}],3:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the combination 
 * of error bars and fractions options.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _bars = require('./bars');

var _bars2 = _interopRequireDefault(_bars);

/**
 * @constructor
 * @extends Dygraph.DataHandlers.BarsHandler
 */
var FractionsBarsHandler = function FractionsBarsHandler() {};

FractionsBarsHandler.prototype = new _bars2["default"]();

/** @inheritDoc */
FractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point, num, den, value, stddev, variance;
  var mult = 100.0;
  var sigma = options.get("sigma");
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      num = point[0];
      den = point[1];
      if (num !== null && !isNaN(num)) {
        value = den ? num / den : 0.0;
        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
        variance = mult * stddev;
        y = mult * value;
        // preserve original values in extras for further filtering
        series.push([x, y, [y - variance, y + variance, num, den]]);
      } else {
        series.push([x, num, [num, num, num, den]]);
      }
    } else {
      series.push([x, null, [null, null, null, null]]);
    }
  }
  return series;
};

/** @inheritDoc */
FractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];
  var sigma = options.get("sigma");
  var wilsonInterval = options.get("wilsonInterval");

  var low, high, i, stddev;
  var num = 0;
  var den = 0; // numerator/denominator
  var mult = 100.0;
  for (i = 0; i < originalData.length; i++) {
    num += originalData[i][2][2];
    den += originalData[i][2][3];
    if (i - rollPeriod >= 0) {
      num -= originalData[i - rollPeriod][2][2];
      den -= originalData[i - rollPeriod][2][3];
    }

    var date = originalData[i][0];
    var value = den ? num / den : 0.0;
    if (wilsonInterval) {
      // For more details on this confidence interval, see:
      // http://en.wikipedia.org/wiki/Binomial_confidence_interval
      if (den) {
        var p = value < 0 ? 0 : value,
            n = den;
        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));
        var denom = 1 + sigma * sigma / den;
        low = (p + sigma * sigma / (2 * den) - pm) / denom;
        high = (p + sigma * sigma / (2 * den) + pm) / denom;
        rollingData[i] = [date, p * mult, [low * mult, high * mult]];
      } else {
        rollingData[i] = [date, 0, [0, 0]];
      }
    } else {
      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];
    }
  }

  return rollingData;
};

exports["default"] = FractionsBarsHandler;
module.exports = exports["default"];

},{"./bars":4}],4:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler base implementation for the "bar" 
 * data formats. This implementation must be extended and the
 * extractSeries and rollingAverage must be implemented.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
/*global DygraphLayout:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

var _dygraphLayout = require('../dygraph-layout');

var _dygraphLayout2 = _interopRequireDefault(_dygraphLayout);

/**
 * @constructor
 * @extends {Dygraph.DataHandler}
 */
var BarsHandler = function BarsHandler() {
  _datahandler2['default'].call(this);
};
BarsHandler.prototype = new _datahandler2['default']();

// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.
//   (I get closure compiler errors if this isn't here.)
/**
 * @override
 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where 
 *     rawData[i] = [x,ySeries1,...,ySeriesN].
 * @param {!number} seriesIndex Index of the series to extract. All other
 *     series should be ignored.
 * @param {!DygraphOptions} options Dygraph options.
 * @return {Array.<[!number,?number,?]>} The series in the unified data format
 *     where series[i] = [x,y,{extras}]. 
 */
BarsHandler.prototype.extractSeries = function (rawData, seriesIndex, options) {
  // Not implemented here must be extended
};

/**
 * @override
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *          data format where series[i] = [x,y,{extras}].
 * @param {!number} rollPeriod The number of points over which to average the data
 * @param {!DygraphOptions} options The dygraph options.
 * TODO(danvk): be more specific than "Array" here.
 * @return {!Array.<[!number,?number,?]>} the rolled series.
 */
BarsHandler.prototype.rollingAverage = function (series, rollPeriod, options) {
  // Not implemented here, must be extended.
};

/** @inheritDoc */
BarsHandler.prototype.onPointsCreated_ = function (series, points) {
  for (var i = 0; i < series.length; ++i) {
    var item = series[i];
    var point = points[i];
    point.y_top = NaN;
    point.y_bottom = NaN;
    point.yval_minus = _datahandler2['default'].parseFloat(item[2][0]);
    point.yval_plus = _datahandler2['default'].parseFloat(item[2][1]);
  }
};

/** @inheritDoc */
BarsHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
  var minY = null,
      maxY = null,
      y;

  var firstIdx = 0;
  var lastIdx = series.length - 1;

  for (var j = firstIdx; j <= lastIdx; j++) {
    y = series[j][1];
    if (y === null || isNaN(y)) continue;

    var low = series[j][2][0];
    var high = series[j][2][1];

    if (low > y) low = y; // this can happen with custom bars,
    if (high < y) high = y; // e.g. in tests/custom-bars.html

    if (maxY === null || high > maxY) maxY = high;
    if (minY === null || low < minY) minY = low;
  }

  return [minY, maxY];
};

/** @inheritDoc */
BarsHandler.prototype.onLineEvaluated = function (points, axis, logscale) {
  var point;
  for (var j = 0; j < points.length; j++) {
    // Copy over the error terms
    point = points[j];
    point.y_top = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_minus, logscale);
    point.y_bottom = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_plus, logscale);
  }
};

exports['default'] = BarsHandler;
module.exports = exports['default'];

},{"../dygraph-layout":12,"./datahandler":5}],5:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview This file contains the managment of data handlers
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 * 
 * The idea is to define a common, generic data format that works for all data
 * structures supported by dygraphs. To make this possible, the DataHandler
 * interface is introduced. This makes it possible, that dygraph itself can work
 * with the same logic for every data type independent of the actual format and
 * the DataHandler takes care of the data format specific jobs. 
 * DataHandlers are implemented for all data types supported by Dygraphs and
 * return Dygraphs compliant formats.
 * By default the correct DataHandler is chosen based on the options set.
 * Optionally the user may use his own DataHandler (similar to the plugin
 * system).
 * 
 * 
 * The unified data format returend by each handler is defined as so: 
 * series[n][point] = [x,y,(extras)] 
 * 
 * This format contains the common basis that is needed to draw a simple line
 * series extended by optional extras for more complex graphing types. It
 * contains a primitive x value as first array entry, a primitive y value as
 * second array entry and an optional extras object for additional data needed.
 * 
 * x must always be a number.
 * y must always be a number, NaN of type number or null.
 * extras is optional and must be interpreted by the DataHandler. It may be of
 * any type. 
 * 
 * In practice this might look something like this:
 * default: [x, yVal]
 * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]
 * 
 */
/*global Dygraph:false */
/*global DygraphLayout:false */

"use strict";

/**
 * 
 * The data handler is responsible for all data specific operations. All of the
 * series data it receives and returns is always in the unified data format.
 * Initially the unified data is created by the extractSeries method
 * @constructor
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
var DygraphDataHandler = function DygraphDataHandler() {};

var handler = DygraphDataHandler;

/**
 * X-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.X = 0;

/**
 * Y-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.Y = 1;

/**
 * Extras-value array index constant for unified data samples.
 * @const
 * @type {number}
 */
handler.EXTRAS = 2;

/**
 * Extracts one series from the raw data (a 2D array) into an array of the
 * unified data format.
 * This is where undesirable points (i.e. negative values on log scales and
 * missing values through which we wish to connect lines) are dropped.
 * TODO(danvk): the "missing values" bit above doesn't seem right.
 * 
 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where 
 *     rawData[i] = [x,ySeries1,...,ySeriesN].
 * @param {!number} seriesIndex Index of the series to extract. All other
 *     series should be ignored.
 * @param {!DygraphOptions} options Dygraph options.
 * @return {Array.<[!number,?number,?]>} The series in the unified data format
 *     where series[i] = [x,y,{extras}]. 
 */
handler.prototype.extractSeries = function (rawData, seriesIndex, options) {};

/**
 * Converts a series to a Point array.  The resulting point array must be
 * returned in increasing order of idx property.
 * 
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *          data format where series[i] = [x,y,{extras}].
 * @param {!string} setName Name of the series.
 * @param {!number} boundaryIdStart Index offset of the first point, equal to the
 *          number of skipped points left of the date window minimum (if any).
 * @return {!Array.<Dygraph.PointType>} List of points for this series.
 */
handler.prototype.seriesToPoints = function (series, setName, boundaryIdStart) {
  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In
  // fact,
  // on chrome+linux, they are 6 times more expensive than iterating through
  // the
  // points and drawing the lines. The brunt of the cost comes from allocating
  // the |point| structures.
  var points = [];
  for (var i = 0; i < series.length; ++i) {
    var item = series[i];
    var yraw = item[1];
    var yval = yraw === null ? null : handler.parseFloat(yraw);
    var point = {
      x: NaN,
      y: NaN,
      xval: handler.parseFloat(item[0]),
      yval: yval,
      name: setName, // TODO(danvk): is this really necessary?
      idx: i + boundaryIdStart
    };
    points.push(point);
  }
  this.onPointsCreated_(series, points);
  return points;
};

/**
 * Callback called for each series after the series points have been generated
 * which will later be used by the plotters to draw the graph.
 * Here data may be added to the seriesPoints which is needed by the plotters.
 * The indexes of series and points are in sync meaning the original data
 * sample for series[i] is points[i].
 * 
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *     data format where series[i] = [x,y,{extras}].
 * @param {!Array.<Dygraph.PointType>} points The corresponding points passed 
 *     to the plotter.
 * @protected
 */
handler.prototype.onPointsCreated_ = function (series, points) {};

/**
 * Calculates the rolling average of a data set.
 * 
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *          data format where series[i] = [x,y,{extras}].
 * @param {!number} rollPeriod The number of points over which to average the data
 * @param {!DygraphOptions} options The dygraph options.
 * @return {!Array.<[!number,?number,?]>} the rolled series.
 */
handler.prototype.rollingAverage = function (series, rollPeriod, options) {};

/**
 * Computes the range of the data series (including confidence intervals).
 * 
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *     data format where series[i] = [x, y, {extras}].
 * @param {!Array.<number>} dateWindow The x-value range to display with 
 *     the format: [min, max].
 * @param {!DygraphOptions} options The dygraph options.
 * @return {Array.<number>} The low and high extremes of the series in the
 *     given window with the format: [low, high].
 */
handler.prototype.getExtremeYValues = function (series, dateWindow, options) {};

/**
 * Callback called for each series after the layouting data has been
 * calculated before the series is drawn. Here normalized positioning data
 * should be calculated for the extras of each point.
 * 
 * @param {!Array.<Dygraph.PointType>} points The points passed to 
 *          the plotter.
 * @param {!Object} axis The axis on which the series will be plotted.
 * @param {!boolean} logscale Weather or not to use a logscale.
 */
handler.prototype.onLineEvaluated = function (points, axis, logscale) {};

/**
 * Helper method that computes the y value of a line defined by the points p1
 * and p2 and a given x value.
 * 
 * @param {!Array.<number>} p1 left point ([x,y]).
 * @param {!Array.<number>} p2 right point ([x,y]).
 * @param {!number} xValue The x value to compute the y-intersection for.
 * @return {number} corresponding y value to x on the line defined by p1 and p2.
 * @private
 */
handler.prototype.computeYInterpolation_ = function (p1, p2, xValue) {
  var deltaY = p2[1] - p1[1];
  var deltaX = p2[0] - p1[0];
  var gradient = deltaY / deltaX;
  var growth = (xValue - p1[0]) * gradient;
  return p1[1] + growth;
};

/**
 * Helper method that returns the first and the last index of the given series
 * that lie inside the given dateWindow.
 * 
 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
 *     data format where series[i] = [x,y,{extras}].
 * @param {!Array.<number>} dateWindow The x-value range to display with 
 *     the format: [min,max].
 * @return {!Array.<[!number,?number,?]>} The samples of the series that 
 *     are in the given date window.
 * @private
 */
handler.prototype.getIndexesInWindow_ = function (series, dateWindow) {
  var firstIdx = 0,
      lastIdx = series.length - 1;
  if (dateWindow) {
    var idx = 0;
    var low = dateWindow[0];
    var high = dateWindow[1];

    // Start from each side of the array to minimize the performance
    // needed.
    while (idx < series.length - 1 && series[idx][0] < low) {
      firstIdx++;
      idx++;
    }
    idx = series.length - 1;
    while (idx > 0 && series[idx][0] > high) {
      lastIdx--;
      idx--;
    }
  }
  if (firstIdx <= lastIdx) {
    return [firstIdx, lastIdx];
  } else {
    return [0, series.length - 1];
  }
};

/**
 * Optimized replacement for parseFloat, which was way too slow when almost
 * all values were type number, with few edge cases, none of which were strings.
 * @param {?number} val
 * @return {number}
 * @protected
 */
handler.parseFloat = function (val) {
  // parseFloat(null) is NaN
  if (val === null) {
    return NaN;
  }

  // Assume it's a number or NaN. If it's something else, I'll be shocked.
  return val;
};

exports["default"] = DygraphDataHandler;
module.exports = exports["default"];

},{}],6:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler implementation for the fractions option.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

var _default = require('./default');

var _default2 = _interopRequireDefault(_default);

/**
 * @extends DefaultHandler
 * @constructor
 */
var DefaultFractionHandler = function DefaultFractionHandler() {};

DefaultFractionHandler.prototype = new _default2['default']();

DefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var x, y, point, num, den, value;
  var mult = 100.0;
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    x = rawData[j][0];
    point = rawData[j][i];
    if (logScale && point !== null) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point[0] <= 0 || point[1] <= 0) {
        point = null;
      }
    }
    // Extract to the unified data format.
    if (point !== null) {
      num = point[0];
      den = point[1];
      if (num !== null && !isNaN(num)) {
        value = den ? num / den : 0.0;
        y = mult * value;
        // preserve original values in extras for further filtering
        series.push([x, y, [num, den]]);
      } else {
        series.push([x, num, [num, den]]);
      }
    } else {
      series.push([x, null, [null, null]]);
    }
  }
  return series;
};

DefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];

  var i;
  var num = 0;
  var den = 0; // numerator/denominator
  var mult = 100.0;
  for (i = 0; i < originalData.length; i++) {
    num += originalData[i][2][0];
    den += originalData[i][2][1];
    if (i - rollPeriod >= 0) {
      num -= originalData[i - rollPeriod][2][0];
      den -= originalData[i - rollPeriod][2][1];
    }

    var date = originalData[i][0];
    var value = den ? num / den : 0.0;
    rollingData[i] = [date, mult * value];
  }

  return rollingData;
};

exports['default'] = DefaultFractionHandler;
module.exports = exports['default'];

},{"./datahandler":5,"./default":7}],7:[function(require,module,exports){
/**
 * @license
 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DataHandler default implementation used for simple line charts.
 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _datahandler = require('./datahandler');

var _datahandler2 = _interopRequireDefault(_datahandler);

/**
 * @constructor
 * @extends Dygraph.DataHandler
 */
var DefaultHandler = function DefaultHandler() {};

DefaultHandler.prototype = new _datahandler2['default']();

/** @inheritDoc */
DefaultHandler.prototype.extractSeries = function (rawData, i, options) {
  // TODO(danvk): pre-allocate series here.
  var series = [];
  var logScale = options.get('logscale');
  for (var j = 0; j < rawData.length; j++) {
    var x = rawData[j][0];
    var point = rawData[j][i];
    if (logScale) {
      // On the log scale, points less than zero do not exist.
      // This will create a gap in the chart.
      if (point <= 0) {
        point = null;
      }
    }
    series.push([x, point]);
  }
  return series;
};

/** @inheritDoc */
DefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
  rollPeriod = Math.min(rollPeriod, originalData.length);
  var rollingData = [];

  var i, j, y, sum, num_ok;
  // Calculate the rolling average for the first rollPeriod - 1 points
  // where
  // there is not enough data to roll over the full number of points
  if (rollPeriod == 1) {
    return originalData;
  }
  for (i = 0; i < originalData.length; i++) {
    sum = 0;
    num_ok = 0;
    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
      y = originalData[j][1];
      if (y === null || isNaN(y)) continue;
      num_ok++;
      sum += originalData[j][1];
    }
    if (num_ok) {
      rollingData[i] = [originalData[i][0], sum / num_ok];
    } else {
      rollingData[i] = [originalData[i][0], null];
    }
  }

  return rollingData;
};

/** @inheritDoc */
DefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
  var minY = null,
      maxY = null,
      y;
  var firstIdx = 0,
      lastIdx = series.length - 1;

  for (var j = firstIdx; j <= lastIdx; j++) {
    y = series[j][1];
    if (y === null || isNaN(y)) continue;
    if (maxY === null || y > maxY) {
      maxY = y;
    }
    if (minY === null || y < minY) {
      minY = y;
    }
  }
  return [minY, maxY];
};

exports['default'] = DefaultHandler;
module.exports = exports['default'];

},{"./datahandler":5}],8:[function(require,module,exports){
/**
 * @license
 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the
 * needs of dygraphs.
 *
 * In particular, support for:
 * - grid overlays
 * - error bars
 * - dygraphs attribute system
 */

/**
 * The DygraphCanvasRenderer class does the actual rendering of the chart onto
 * a canvas. It's based on PlotKit.CanvasRenderer.
 * @param {Object} element The canvas to attach to
 * @param {Object} elementContext The 2d context of the canvas (injected so it
 * can be mocked for testing.)
 * @param {Layout} layout The DygraphLayout object for this graph.
 * @constructor
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraph = require('./dygraph');

var _dygraph2 = _interopRequireDefault(_dygraph);

/**
 * @constructor
 *
 * This gets called when there are "new points" to chart. This is generally the
 * case when the underlying data being charted has changed. It is _not_ called
 * in the common case that the user has zoomed or is panning the view.
 *
 * The chart canvas has already been created by the Dygraph object. The
 * renderer simply gets a drawing context.
 *
 * @param {Dygraph} dygraph The chart to which this renderer belongs.
 * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.
 * @param {CanvasRenderingContext2D} elementContext The drawing context.
 * @param {DygraphLayout} layout The chart's DygraphLayout object.
 *
 * TODO(danvk): remove the elementContext property.
 */
var DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {
  this.dygraph_ = dygraph;

  this.layout = layout;
  this.element = element;
  this.elementContext = elementContext;

  this.height = dygraph.height_;
  this.width = dygraph.width_;

  // --- check whether everything is ok before we return
  if (!utils.isCanvasSupported(this.element)) {
    throw "Canvas is not supported.";
  }

  // internal state
  this.area = layout.getPlotArea();

  // Set up a clipping area for the canvas (and the interaction canvas).
  // This ensures that we don't overdraw.
  // on Android 3 and 4, setting a clipping area on a canvas prevents it from
  // displaying anything.
  if (!utils.isAndroid()) {
    var ctx = this.dygraph_.canvas_ctx_;
    ctx.beginPath();
    ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
    ctx.clip();

    ctx = this.dygraph_.hidden_ctx_;
    ctx.beginPath();
    ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
    ctx.clip();
  }
};

/**
 * Clears out all chart content and DOM elements.
 * This is called immediately before render() on every frame, including
 * during zooms and pans.
 * @private
 */
DygraphCanvasRenderer.prototype.clear = function () {
  this.elementContext.clearRect(0, 0, this.width, this.height);
};

/**
 * This method is responsible for drawing everything on the chart, including
 * lines, error bars, fills and axes.
 * It is called immediately after clear() on every frame, including during pans
 * and zooms.
 * @private
 */
DygraphCanvasRenderer.prototype.render = function () {
  // attaches point.canvas{x,y}
  this._updatePoints();

  // actually draws the chart.
  this._renderLineChart();
};

/**
 * Returns a predicate to be used with an iterator, which will
 * iterate over points appropriately, depending on whether
 * connectSeparatedPoints is true. When it's false, the predicate will
 * skip over points with missing yVals.
 */
DygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {
  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;
};

DygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {
  return array[idx].yval !== null;
};

/**
 * Draws a line with the styles passed in and calls all the drawPointCallbacks.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {
  var g = e.dygraph;
  // TODO(konigsberg): Compute attributes outside this method call.
  var stepPlot = g.getBooleanOption("stepPlot", e.setName);

  if (!utils.isArrayLike(strokePattern)) {
    strokePattern = null;
  }

  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);

  var points = e.points;
  var setName = e.setName;
  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

  var stroking = strokePattern && strokePattern.length >= 2;

  var ctx = e.drawingContext;
  ctx.save();
  if (stroking) {
    if (ctx.setLineDash) ctx.setLineDash(strokePattern);
  }

  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);
  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);

  if (stroking) {
    if (ctx.setLineDash) ctx.setLineDash([]);
  }

  ctx.restore();
};

/**
 * This does the actual drawing of lines on the canvas, for just one series.
 * Returns a list of [canvasx, canvasy] pairs for points for which a
 * drawPointCallback should be fired.  These include isolated points, or all
 * points if drawPoints=true.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {

  var prevCanvasX = null;
  var prevCanvasY = null;
  var nextCanvasY = null;
  var isIsolated; // true if this point is isolated (no line segments)
  var point; // the point being processed in the while loop
  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.
  var first = true; // the first cycle through the while loop

  var ctx = e.drawingContext;
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = strokeWidth;

  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.
  var arr = iter.array_;
  var limit = iter.end_;
  var predicate = iter.predicate_;

  for (var i = iter.start_; i < limit; i++) {
    point = arr[i];
    if (predicate) {
      while (i < limit && !predicate(arr, i)) {
        i++;
      }
      if (i == limit) break;
      point = arr[i];
    }

    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test
    // doesn't catch Infinity values. Could change this to
    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?
    if (point.canvasy === null || point.canvasy != point.canvasy) {
      if (stepPlot && prevCanvasX !== null) {
        // Draw a horizontal line to the start of the missing data
        ctx.moveTo(prevCanvasX, prevCanvasY);
        ctx.lineTo(point.canvasx, prevCanvasY);
      }
      prevCanvasX = prevCanvasY = null;
    } else {
      isIsolated = false;
      if (drawGapPoints || prevCanvasX === null) {
        iter.nextIdx_ = i;
        iter.next();
        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;

        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;
        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;
        if (drawGapPoints) {
          // Also consider a point to be "isolated" if it's adjacent to a
          // null point, excluding the graph edges.
          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {
            isIsolated = true;
          }
        }
      }

      if (prevCanvasX !== null) {
        if (strokeWidth) {
          if (stepPlot) {
            ctx.moveTo(prevCanvasX, prevCanvasY);
            ctx.lineTo(point.canvasx, prevCanvasY);
          }

          ctx.lineTo(point.canvasx, point.canvasy);
        }
      } else {
        ctx.moveTo(point.canvasx, point.canvasy);
      }
      if (drawPoints || isIsolated) {
        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);
      }
      prevCanvasX = point.canvasx;
      prevCanvasY = point.canvasy;
    }
    first = false;
  }
  ctx.stroke();
  return pointsOnLine;
};

/**
 * This fires the drawPointCallback functions, which draw dots on the points by
 * default. This gets used when the "drawPoints" option is set, or when there
 * are isolated points.
 * @param {Object} e The dictionary passed to the plotter function.
 * @private
 */
DygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {
  var ctx = e.drawingContext;
  for (var idx = 0; idx < pointsOnLine.length; idx++) {
    var cb = pointsOnLine[idx];
    ctx.save();
    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);
    ctx.restore();
  }
};

/**
 * Attaches canvas coordinates to the points array.
 * @private
 */
DygraphCanvasRenderer.prototype._updatePoints = function () {
  // Update Points
  // TODO(danvk): here
  //
  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These
  // transformations can be pushed into the canvas via linear transformation
  // matrices.
  // NOTE(danvk): this is trickier than it sounds at first. The transformation
  // needs to be done before the .moveTo() and .lineTo() calls, but must be
  // undone before the .stroke() call to ensure that the stroke width is
  // unaffected.  An alternative is to reduce the stroke width in the
  // transformed coordinate space, but you can't specify different values for
  // each dimension (as you can with .scale()). The speedup here is ~12%.
  var sets = this.layout.points;
  for (var i = sets.length; i--;) {
    var points = sets[i];
    for (var j = points.length; j--;) {
      var point = points[j];
      point.canvasx = this.area.w * point.x + this.area.x;
      point.canvasy = this.area.h * point.y + this.area.y;
    }
  }
};

/**
 * Add canvas Actually draw the lines chart, including error bars.
 *
 * This function can only be called if DygraphLayout's points array has been
 * updated with canvas{x,y} attributes, i.e. by
 * DygraphCanvasRenderer._updatePoints.
 *
 * @param {string=} opt_seriesName when specified, only that series will
 *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)
 * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing
 *     context.  However, lines are typically drawn on the object's
 *     elementContext.
 * @private
 */
DygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {
  var ctx = opt_ctx || this.elementContext;
  var i;

  var sets = this.layout.points;
  var setNames = this.layout.setNames;
  var setName;

  this.colors = this.dygraph_.colorsMap_;

  // Determine which series have specialized plotters.
  var plotter_attr = this.dygraph_.getOption("plotter");
  var plotters = plotter_attr;
  if (!utils.isArrayLike(plotters)) {
    plotters = [plotters];
  }

  var setPlotters = {}; // series name -> plotter fn.
  for (i = 0; i < setNames.length; i++) {
    setName = setNames[i];
    var setPlotter = this.dygraph_.getOption("plotter", setName);
    if (setPlotter == plotter_attr) continue; // not specialized.

    setPlotters[setName] = setPlotter;
  }

  for (i = 0; i < plotters.length; i++) {
    var plotter = plotters[i];
    var is_last = i == plotters.length - 1;

    for (var j = 0; j < sets.length; j++) {
      setName = setNames[j];
      if (opt_seriesName && setName != opt_seriesName) continue;

      var points = sets[j];

      // Only throw in the specialized plotters on the last iteration.
      var p = plotter;
      if (setName in setPlotters) {
        if (is_last) {
          p = setPlotters[setName];
        } else {
          // Don't use the standard plotters in this case.
          continue;
        }
      }

      var color = this.colors[setName];
      var strokeWidth = this.dygraph_.getOption("strokeWidth", setName);

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = strokeWidth;
      p({
        points: points,
        setName: setName,
        drawingContext: ctx,
        color: color,
        strokeWidth: strokeWidth,
        dygraph: this.dygraph_,
        axis: this.dygraph_.axisPropertiesForSeries(setName),
        plotArea: this.area,
        seriesIndex: j,
        seriesCount: sets.length,
        singleSeriesName: opt_seriesName,
        allSeriesPoints: sets
      });
      ctx.restore();
    }
  }
};

/**
 * Standard plotters. These may be used by clients via Dygraph.Plotters.
 * See comments there for more details.
 */
DygraphCanvasRenderer._Plotters = {
  linePlotter: function linePlotter(e) {
    DygraphCanvasRenderer._linePlotter(e);
  },

  fillPlotter: function fillPlotter(e) {
    DygraphCanvasRenderer._fillPlotter(e);
  },

  errorPlotter: function errorPlotter(e) {
    DygraphCanvasRenderer._errorPlotter(e);
  }
};

/**
 * Plotter which draws the central lines for a series.
 * @private
 */
DygraphCanvasRenderer._linePlotter = function (e) {
  var g = e.dygraph;
  var setName = e.setName;
  var strokeWidth = e.strokeWidth;

  // TODO(danvk): Check if there's any performance impact of just calling
  // getOption() inside of _drawStyledLine. Passing in so many parameters makes
  // this code a bit nasty.
  var borderWidth = g.getNumericOption("strokeBorderWidth", setName);
  var drawPointCallback = g.getOption("drawPointCallback", setName) || utils.Circles.DEFAULT;
  var strokePattern = g.getOption("strokePattern", setName);
  var drawPoints = g.getBooleanOption("drawPoints", setName);
  var pointSize = g.getNumericOption("pointSize", setName);

  if (borderWidth && strokeWidth) {
    DygraphCanvasRenderer._drawStyledLine(e, g.getOption("strokeBorderColor", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
  }

  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
};

/**
 * Draws the shaded error bars/confidence intervals for each series.
 * This happens before the center lines are drawn, since the center lines
 * need to be drawn on top of the error bars for all series.
 * @private
 */
DygraphCanvasRenderer._errorPlotter = function (e) {
  var g = e.dygraph;
  var setName = e.setName;
  var errorBars = g.getBooleanOption("errorBars") || g.getBooleanOption("customBars");
  if (!errorBars) return;

  var fillGraph = g.getBooleanOption("fillGraph", setName);
  if (fillGraph) {
    console.warn("Can't use fillGraph option with error bars");
  }

  var ctx = e.drawingContext;
  var color = e.color;
  var fillAlpha = g.getNumericOption('fillAlpha', setName);
  var stepPlot = g.getBooleanOption("stepPlot", setName);
  var points = e.points;

  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

  var newYs;

  // setup graphics context
  var prevX = NaN;
  var prevY = NaN;
  var prevYs = [-1, -1];
  // should be same color as the lines but only 15% opaque.
  var rgb = utils.toRGB_(color);
  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
  ctx.fillStyle = err_color;
  ctx.beginPath();

  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {
    return x === null || x === undefined || isNaN(x);
  };

  while (iter.hasNext) {
    var point = iter.next();
    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {
      prevX = NaN;
      continue;
    }

    newYs = [point.y_bottom, point.y_top];
    if (stepPlot) {
      prevY = point.y;
    }

    // The documentation specifically disallows nulls inside the point arrays,
    // but in case it happens we should do something sensible.
    if (isNaN(newYs[0])) newYs[0] = point.y;
    if (isNaN(newYs[1])) newYs[1] = point.y;

    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;
    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;
    if (!isNaN(prevX)) {
      if (stepPlot) {
        ctx.moveTo(prevX, prevYs[0]);
        ctx.lineTo(point.canvasx, prevYs[0]);
        ctx.lineTo(point.canvasx, prevYs[1]);
      } else {
        ctx.moveTo(prevX, prevYs[0]);
        ctx.lineTo(point.canvasx, newYs[0]);
        ctx.lineTo(point.canvasx, newYs[1]);
      }
      ctx.lineTo(prevX, prevYs[1]);
      ctx.closePath();
    }
    prevYs = newYs;
    prevX = point.canvasx;
  }
  ctx.fill();
};

/**
 * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are
 * superfluous. It accumulates all movements which haven't changed the x-value
 * and only applies the two with the most extreme y-values.
 * 
 * Calls to lineTo/moveTo must have non-decreasing x-values.
 */
DygraphCanvasRenderer._fastCanvasProxy = function (context) {
  var pendingActions = []; // array of [type, x, y] tuples
  var lastRoundedX = null;
  var lastFlushedX = null;

  var LINE_TO = 1,
      MOVE_TO = 2;

  var actionCount = 0; // number of moveTos and lineTos passed to context.

  // Drop superfluous motions
  // Assumes all pendingActions have the same (rounded) x-value.
  var compressActions = function compressActions(opt_losslessOnly) {
    if (pendingActions.length <= 1) return;

    // Lossless compression: drop inconsequential moveTos.
    for (var i = pendingActions.length - 1; i > 0; i--) {
      var action = pendingActions[i];
      if (action[0] == MOVE_TO) {
        var prevAction = pendingActions[i - 1];
        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {
          pendingActions.splice(i, 1);
        }
      }
    }

    // Lossless compression: ... drop consecutive moveTos ...
    for (var i = 0; i < pendingActions.length - 1;) /* incremented internally */{
      var action = pendingActions[i];
      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {
        pendingActions.splice(i, 1);
      } else {
        i++;
      }
    }

    // Lossy compression: ... drop all but the extreme y-values ...
    if (pendingActions.length > 2 && !opt_losslessOnly) {
      // keep an initial moveTo, but drop all others.
      var startIdx = 0;
      if (pendingActions[0][0] == MOVE_TO) startIdx++;
      var minIdx = null,
          maxIdx = null;
      for (var i = startIdx; i < pendingActions.length; i++) {
        var action = pendingActions[i];
        if (action[0] != LINE_TO) continue;
        if (minIdx === null && maxIdx === null) {
          minIdx = i;
          maxIdx = i;
        } else {
          var y = action[2];
          if (y < pendingActions[minIdx][2]) {
            minIdx = i;
          } else if (y > pendingActions[maxIdx][2]) {
            maxIdx = i;
          }
        }
      }
      var minAction = pendingActions[minIdx],
          maxAction = pendingActions[maxIdx];
      pendingActions.splice(startIdx, pendingActions.length - startIdx);
      if (minIdx < maxIdx) {
        pendingActions.push(minAction);
        pendingActions.push(maxAction);
      } else if (minIdx > maxIdx) {
        pendingActions.push(maxAction);
        pendingActions.push(minAction);
      } else {
        pendingActions.push(minAction);
      }
    }
  };

  var flushActions = function flushActions(opt_noLossyCompression) {
    compressActions(opt_noLossyCompression);
    for (var i = 0, len = pendingActions.length; i < len; i++) {
      var action = pendingActions[i];
      if (action[0] == LINE_TO) {
        context.lineTo(action[1], action[2]);
      } else if (action[0] == MOVE_TO) {
        context.moveTo(action[1], action[2]);
      }
    }
    if (pendingActions.length) {
      lastFlushedX = pendingActions[pendingActions.length - 1][1];
    }
    actionCount += pendingActions.length;
    pendingActions = [];
  };

  var addAction = function addAction(action, x, y) {
    var rx = Math.round(x);
    if (lastRoundedX === null || rx != lastRoundedX) {
      // if there are large gaps on the x-axis, it's essential to keep the
      // first and last point as well.
      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,
          hasGapOnRight = rx - lastRoundedX > 1,
          hasGap = hasGapOnLeft || hasGapOnRight;
      flushActions(hasGap);
      lastRoundedX = rx;
    }
    pendingActions.push([action, x, y]);
  };

  return {
    moveTo: function moveTo(x, y) {
      addAction(MOVE_TO, x, y);
    },
    lineTo: function lineTo(x, y) {
      addAction(LINE_TO, x, y);
    },

    // for major operations like stroke/fill, we skip compression to ensure
    // that there are no artifacts at the right edge.
    stroke: function stroke() {
      flushActions(true);context.stroke();
    },
    fill: function fill() {
      flushActions(true);context.fill();
    },
    beginPath: function beginPath() {
      flushActions(true);context.beginPath();
    },
    closePath: function closePath() {
      flushActions(true);context.closePath();
    },

    _count: function _count() {
      return actionCount;
    }
  };
};

/**
 * Draws the shaded regions when "fillGraph" is set. Not to be confused with
 * error bars.
 *
 * For stacked charts, it's more convenient to handle all the series
 * simultaneously. So this plotter plots all the points on the first series
 * it's asked to draw, then ignores all the other series.
 *
 * @private
 */
DygraphCanvasRenderer._fillPlotter = function (e) {
  // Skip if we're drawing a single series for interactive highlight overlay.
  if (e.singleSeriesName) return;

  // We'll handle all the series at once, not one-by-one.
  if (e.seriesIndex !== 0) return;

  var g = e.dygraph;
  var setNames = g.getLabels().slice(1); // remove x-axis

  // getLabels() includes names for invisible series, which are not included in
  // allSeriesPoints. We remove those to make the two match.
  // TODO(danvk): provide a simpler way to get this information.
  for (var i = setNames.length; i >= 0; i--) {
    if (!g.visibility()[i]) setNames.splice(i, 1);
  }

  var anySeriesFilled = (function () {
    for (var i = 0; i < setNames.length; i++) {
      if (g.getBooleanOption("fillGraph", setNames[i])) return true;
    }
    return false;
  })();

  if (!anySeriesFilled) return;

  var area = e.plotArea;
  var sets = e.allSeriesPoints;
  var setCount = sets.length;

  var stackedGraph = g.getBooleanOption("stackedGraph");
  var colors = g.getColors();

  // For stacked graphs, track the baseline for filling.
  //
  // The filled areas below graph lines are trapezoids with two
  // vertical edges. The top edge is the line segment being drawn, and
  // the baseline is the bottom edge. Each baseline corresponds to the
  // top line segment from the previous stacked line. In the case of
  // step plots, the trapezoids are rectangles.
  var baseline = {};
  var currBaseline;
  var prevStepPlot; // for different line drawing modes (line/step) per series

  // Helper function to trace a line back along the baseline.
  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {
    ctx.lineTo(baselineX, baselineY);
    if (stackedGraph) {
      for (var i = pathBack.length - 1; i >= 0; i--) {
        var pt = pathBack[i];
        ctx.lineTo(pt[0], pt[1]);
      }
    }
  };

  // process sets in reverse order (needed for stacked graphs)
  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {
    var ctx = e.drawingContext;
    var setName = setNames[setIdx];
    if (!g.getBooleanOption('fillGraph', setName)) continue;

    var fillAlpha = g.getNumericOption('fillAlpha', setName);
    var stepPlot = g.getBooleanOption('stepPlot', setName);
    var color = colors[setIdx];
    var axis = g.axisPropertiesForSeries(setName);
    var axisY = 1.0 + axis.minyval * axis.yscale;
    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;
    axisY = area.h * axisY + area.y;

    var points = sets[setIdx];
    var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

    // setup graphics context
    var prevX = NaN;
    var prevYs = [-1, -1];
    var newYs;
    // should be same color as the lines but only 15% opaque.
    var rgb = utils.toRGB_(color);
    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
    ctx.fillStyle = err_color;
    ctx.beginPath();
    var last_x,
        is_first = true;

    // If the point density is high enough, dropping segments on their way to
    // the canvas justifies the overhead of doing so.
    if (points.length > 2 * g.width_ || _dygraph2['default'].FORCE_FAST_PROXY) {
      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);
    }

    // For filled charts, we draw points from left to right, then back along
    // the x-axis to complete a shape for filling.
    // For stacked plots, this "back path" is a more complex shape. This array
    // stores the [x, y] values needed to trace that shape.
    var pathBack = [];

    // TODO(danvk): there are a lot of options at play in this loop.
    //     The logic would be much clearer if some (e.g. stackGraph and
    //     stepPlot) were split off into separate sub-plotters.
    var point;
    while (iter.hasNext) {
      point = iter.next();
      if (!utils.isOK(point.y) && !stepPlot) {
        traceBackPath(ctx, prevX, prevYs[1], pathBack);
        pathBack = [];
        prevX = NaN;
        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {
          baseline[point.canvasx] = area.h * point.y_stacked + area.y;
        }
        continue;
      }
      if (stackedGraph) {
        if (!is_first && last_x == point.xval) {
          continue;
        } else {
          is_first = false;
          last_x = point.xval;
        }

        currBaseline = baseline[point.canvasx];
        var lastY;
        if (currBaseline === undefined) {
          lastY = axisY;
        } else {
          if (prevStepPlot) {
            lastY = currBaseline[0];
          } else {
            lastY = currBaseline;
          }
        }
        newYs = [point.canvasy, lastY];

        if (stepPlot) {
          // Step plots must keep track of the top and bottom of
          // the baseline at each point.
          if (prevYs[0] === -1) {
            baseline[point.canvasx] = [point.canvasy, axisY];
          } else {
            baseline[point.canvasx] = [point.canvasy, prevYs[0]];
          }
        } else {
          baseline[point.canvasx] = point.canvasy;
        }
      } else {
        if (isNaN(point.canvasy) && stepPlot) {
          newYs = [area.y + area.h, axisY];
        } else {
          newYs = [point.canvasy, axisY];
        }
      }
      if (!isNaN(prevX)) {
        // Move to top fill point
        if (stepPlot) {
          ctx.lineTo(point.canvasx, prevYs[0]);
          ctx.lineTo(point.canvasx, newYs[0]);
        } else {
          ctx.lineTo(point.canvasx, newYs[0]);
        }

        // Record the baseline for the reverse path.
        if (stackedGraph) {
          pathBack.push([prevX, prevYs[1]]);
          if (prevStepPlot && currBaseline) {
            // Draw to the bottom of the baseline
            pathBack.push([point.canvasx, currBaseline[1]]);
          } else {
            pathBack.push([point.canvasx, newYs[1]]);
          }
        }
      } else {
        ctx.moveTo(point.canvasx, newYs[1]);
        ctx.lineTo(point.canvasx, newYs[0]);
      }
      prevYs = newYs;
      prevX = point.canvasx;
    }
    prevStepPlot = stepPlot;
    if (newYs && point) {
      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);
      pathBack = [];
    }
    ctx.fill();
  }
};

exports['default'] = DygraphCanvasRenderer;
module.exports = exports['default'];

},{"./dygraph":17,"./dygraph-utils":16}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphTickers = require('./dygraph-tickers');

var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

var _dygraphInteractionModel = require('./dygraph-interaction-model');

var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

var _dygraphCanvas = require('./dygraph-canvas');

var _dygraphCanvas2 = _interopRequireDefault(_dygraphCanvas);

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

// Default attribute values.
var DEFAULT_ATTRS = {
  highlightCircleSize: 3,
  highlightSeriesOpts: null,
  highlightSeriesBackgroundAlpha: 0.5,
  highlightSeriesBackgroundColor: 'rgb(255, 255, 255)',

  labelsDivWidth: 250,
  labelsDivStyles: {
    // TODO(danvk): move defaults from createStatusMessage_ here.
  },
  labelsSeparateLines: false,
  labelsShowZeroValues: true,
  labelsKMB: false,
  labelsKMG2: false,
  showLabelsOnHighlight: true,

  digitsAfterDecimal: 2,
  maxNumberWidth: 6,
  sigFigs: null,

  strokeWidth: 1.0,
  strokeBorderWidth: 0,
  strokeBorderColor: "white",

  axisTickSize: 3,
  axisLabelFontSize: 14,
  rightGap: 5,

  showRoller: false,
  xValueParser: undefined,

  delimiter: ',',

  sigma: 2.0,
  errorBars: false,
  fractions: false,
  wilsonInterval: true, // only relevant if fractions is true
  customBars: false,
  fillGraph: false,
  fillAlpha: 0.15,
  connectSeparatedPoints: false,

  stackedGraph: false,
  stackedGraphNaNFill: 'all',
  hideOverlayOnMouseOut: true,

  legend: 'onmouseover',
  stepPlot: false,
  avoidMinZero: false,
  xRangePad: 0,
  yRangePad: null,
  drawAxesAtZero: false,

  // Sizes of the various chart labels.
  titleHeight: 28,
  xLabelHeight: 18,
  yLabelWidth: 18,

  axisLineColor: "black",
  axisLineWidth: 0.3,
  gridLineWidth: 0.3,
  axisLabelColor: "black",
  axisLabelWidth: 50,
  gridLineColor: "rgb(128,128,128)",

  interactionModel: _dygraphInteractionModel2['default'].defaultModel,
  animatedZooms: false, // (for now)

  // Range selector options
  showRangeSelector: false,
  rangeSelectorHeight: 40,
  rangeSelectorPlotStrokeColor: "#808FAB",
  rangeSelectorPlotFillGradientColor: "white",
  rangeSelectorPlotFillColor: "#A7B1C4",
  rangeSelectorBackgroundStrokeColor: "gray",
  rangeSelectorBackgroundLineWidth: 1,
  rangeSelectorPlotLineWidth: 1.5,
  rangeSelectorForegroundStrokeColor: "black",
  rangeSelectorForegroundLineWidth: 1,
  rangeSelectorAlpha: 0.6,
  showInRangeSelector: null,

  // The ordering here ensures that central lines always appear above any
  // fill bars/error bars.
  plotter: [_dygraphCanvas2['default']._fillPlotter, _dygraphCanvas2['default']._errorPlotter, _dygraphCanvas2['default']._linePlotter],

  plugins: [],

  // per-axis options
  axes: {
    x: {
      pixelsPerLabel: 70,
      axisLabelWidth: 60,
      axisLabelFormatter: utils.dateAxisLabelFormatter,
      valueFormatter: utils.dateValueFormatter,
      drawGrid: true,
      drawAxis: true,
      independentTicks: true,
      ticker: DygraphTickers.dateTicker
    },
    y: {
      axisLabelWidth: 50,
      pixelsPerLabel: 30,
      valueFormatter: utils.numberValueFormatter,
      axisLabelFormatter: utils.numberAxisLabelFormatter,
      drawGrid: true,
      drawAxis: true,
      independentTicks: true,
      ticker: DygraphTickers.numericTicks
    },
    y2: {
      axisLabelWidth: 50,
      pixelsPerLabel: 30,
      valueFormatter: utils.numberValueFormatter,
      axisLabelFormatter: utils.numberAxisLabelFormatter,
      drawAxis: true, // only applies when there are two axes of data.
      drawGrid: false,
      independentTicks: false,
      ticker: DygraphTickers.numericTicks
    }
  }
};

exports['default'] = DEFAULT_ATTRS;
module.exports = exports['default'];

},{"./dygraph-canvas":8,"./dygraph-interaction-model":11,"./dygraph-tickers":15,"./dygraph-utils":16}],10:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview A wrapper around the Dygraph class which implements the
 * interface for a GViz (aka Google Visualization API) visualization.
 * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,
 * so the documentation at
 * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html
 * translates over directly.
 *
 * For a full demo, see:
 * - http://dygraphs.com/tests/gviz.html
 * - http://dygraphs.com/tests/annotation-gviz.html
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _dygraph = require('./dygraph');

var _dygraph2 = _interopRequireDefault(_dygraph);

/**
 * A wrapper around Dygraph that implements the gviz API.
 * @param {!HTMLDivElement} container The DOM object the visualization should
 *     live in.
 * @constructor
 */
var GVizChart = function GVizChart(container) {
  this.container = container;
};

/**
 * @param {GVizDataTable} data
 * @param {Object.<*>} options
 */
GVizChart.prototype.draw = function (data, options) {
  // Clear out any existing dygraph.
  // TODO(danvk): would it make more sense to simply redraw using the current
  // date_graph object?
  this.container.innerHTML = '';
  if (typeof this.date_graph != 'undefined') {
    this.date_graph.destroy();
  }

  this.date_graph = new _dygraph2['default'](this.container, data, options);
};

/**
 * Google charts compatible setSelection
 * Only row selection is supported, all points in the row will be highlighted
 * @param {Array.<{row:number}>} selection_array array of the selected cells
 * @public
 */
GVizChart.prototype.setSelection = function (selection_array) {
  var row = false;
  if (selection_array.length) {
    row = selection_array[0].row;
  }
  this.date_graph.setSelection(row);
};

/**
 * Google charts compatible getSelection implementation
 * @return {Array.<{row:number,column:number}>} array of the selected cells
 * @public
 */
GVizChart.prototype.getSelection = function () {
  var selection = [];

  var row = this.date_graph.getSelection();

  if (row < 0) return selection;

  var points = this.date_graph.layout_.points;
  for (var setIdx = 0; setIdx < points.length; ++setIdx) {
    selection.push({ row: row, column: setIdx + 1 });
  }

  return selection;
};

exports['default'] = GVizChart;
module.exports = exports['default'];

},{"./dygraph":17}],11:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Robert Konigsberg (konigsberg@google.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview The default interaction model for Dygraphs. This is kept out
 * of dygraph.js for better navigability.
 * @author Robert Konigsberg (konigsberg@google.com)
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * You can drag this many pixels past the edge of the chart and still have it
 * be considered a zoom. This makes it easier to zoom to the exact edge of the
 * chart, a fairly common operation.
 */
var DRAG_EDGE_MARGIN = 100;

/**
 * A collection of functions to facilitate build custom interaction models.
 * @class
 */
var DygraphInteraction = {};

/**
 * Checks whether the beginning & ending of an event were close enough that it
 * should be considered a click. If it should, dispatch appropriate events.
 * Returns true if the event was treated as a click.
 *
 * @param {Event} event
 * @param {Dygraph} g
 * @param {Object} context
 */
DygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);
  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);
  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);

  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {
    DygraphInteraction.treatMouseOpAsClick(g, event, context);
  }

  context.regionWidth = regionWidth;
  context.regionHeight = regionHeight;
};

/**
 * Called in response to an interaction model operation that
 * should start the default panning behavior.
 *
 * It's used in the default callback for "mousedown" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the startPan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.startPan = function (event, g, context) {
  var i, axis;
  context.isPanning = true;
  var xRange = g.xAxisRange();

  if (g.getOptionForAxis("logscale", "x")) {
    context.initialLeftmostDate = utils.log10(xRange[0]);
    context.dateRange = utils.log10(xRange[1]) - utils.log10(xRange[0]);
  } else {
    context.initialLeftmostDate = xRange[0];
    context.dateRange = xRange[1] - xRange[0];
  }
  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);

  if (g.getNumericOption("panEdgeFraction")) {
    var maxXPixelsToDraw = g.width_ * g.getNumericOption("panEdgeFraction");
    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!

    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;
    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;

    var boundedLeftDate = g.toDataXCoord(boundedLeftX);
    var boundedRightDate = g.toDataXCoord(boundedRightX);
    context.boundedDates = [boundedLeftDate, boundedRightDate];

    var boundedValues = [];
    var maxYPixelsToDraw = g.height_ * g.getNumericOption("panEdgeFraction");

    for (i = 0; i < g.axes_.length; i++) {
      axis = g.axes_[i];
      var yExtremes = axis.extremeRange;

      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;
      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;

      var boundedTopValue = g.toDataYCoord(boundedTopY, i);
      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);

      boundedValues[i] = [boundedTopValue, boundedBottomValue];
    }
    context.boundedValues = boundedValues;
  }

  // Record the range of each y-axis at the start of the drag.
  // If any axis has a valueRange or valueWindow, then we want a 2D pan.
  // We can't store data directly in g.axes_, because it does not belong to us
  // and could change out from under us during a pan (say if there's a data
  // update).
  context.is2DPan = false;
  context.axes = [];
  for (i = 0; i < g.axes_.length; i++) {
    axis = g.axes_[i];
    var axis_data = {};
    var yRange = g.yAxisRange(i);
    // TODO(konigsberg): These values should be in |context|.
    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.
    var logscale = g.attributes_.getForAxis("logscale", i);
    if (logscale) {
      axis_data.initialTopValue = utils.log10(yRange[1]);
      axis_data.dragValueRange = utils.log10(yRange[1]) - utils.log10(yRange[0]);
    } else {
      axis_data.initialTopValue = yRange[1];
      axis_data.dragValueRange = yRange[1] - yRange[0];
    }
    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);
    context.axes.push(axis_data);

    // While calculating axes, set 2dpan.
    if (axis.valueWindow || axis.valueRange) context.is2DPan = true;
  }
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that pans the view.
 *
 * It's used in the default callback for "mousemove" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the movePan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.movePan = function (event, g, context) {
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);

  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;
  if (context.boundedDates) {
    minDate = Math.max(minDate, context.boundedDates[0]);
  }
  var maxDate = minDate + context.dateRange;
  if (context.boundedDates) {
    if (maxDate > context.boundedDates[1]) {
      // Adjust minDate, and recompute maxDate.
      minDate = minDate - (maxDate - context.boundedDates[1]);
      maxDate = minDate + context.dateRange;
    }
  }

  if (g.getOptionForAxis("logscale", "x")) {
    g.dateWindow_ = [Math.pow(utils.LOG_SCALE, minDate), Math.pow(utils.LOG_SCALE, maxDate)];
  } else {
    g.dateWindow_ = [minDate, maxDate];
  }

  // y-axis scaling is automatic unless this is a full 2D pan.
  if (context.is2DPan) {

    var pixelsDragged = context.dragEndY - context.dragStartY;

    // Adjust each axis appropriately.
    for (var i = 0; i < g.axes_.length; i++) {
      var axis = g.axes_[i];
      var axis_data = context.axes[i];
      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;

      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;

      // In log scale, maxValue and minValue are the logs of those values.
      var maxValue = axis_data.initialTopValue + unitsDragged;
      if (boundedValue) {
        maxValue = Math.min(maxValue, boundedValue[1]);
      }
      var minValue = maxValue - axis_data.dragValueRange;
      if (boundedValue) {
        if (minValue < boundedValue[0]) {
          // Adjust maxValue, and recompute minValue.
          maxValue = maxValue - (minValue - boundedValue[0]);
          minValue = maxValue - axis_data.dragValueRange;
        }
      }
      if (g.attributes_.getForAxis("logscale", i)) {
        axis.valueWindow = [Math.pow(utils.LOG_SCALE, minValue), Math.pow(utils.LOG_SCALE, maxValue)];
      } else {
        axis.valueWindow = [minValue, maxValue];
      }
    }
  }

  g.drawGraph_(false);
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that ends panning.
 *
 * It's used in the default callback for "mouseup" operations.
 * Custom interaction model builders can use it to provide the default
 * panning behavior.
 *
 * @param {Event} event the event object which led to the endPan call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;

/**
 * Called in response to an interaction model operation that
 * responds to an event that starts zooming.
 *
 * It's used in the default callback for "mousedown" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the startZoom call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.startZoom = function (event, g, context) {
  context.isZooming = true;
  context.zoomMoved = false;
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that defines zoom boundaries.
 *
 * It's used in the default callback for "mousemove" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the moveZoom call.
 * @param {Dygraph} g The dygraph on which to act.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.moveZoom = function (event, g, context) {
  context.zoomMoved = true;
  context.dragEndX = utils.dragGetX_(event, context);
  context.dragEndY = utils.dragGetY_(event, context);

  var xDelta = Math.abs(context.dragStartX - context.dragEndX);
  var yDelta = Math.abs(context.dragStartY - context.dragEndY);

  // drag direction threshold for y axis is twice as large as x axis
  context.dragDirection = xDelta < yDelta / 2 ? utils.VERTICAL : utils.HORIZONTAL;

  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);

  context.prevEndX = context.dragEndX;
  context.prevEndY = context.dragEndY;
  context.prevDragDirection = context.dragDirection;
};

/**
 * TODO(danvk): move this logic into dygraph.js
 * @param {Dygraph} g
 * @param {Event} event
 * @param {Object} context
 */
DygraphInteraction.treatMouseOpAsClick = function (g, event, context) {
  var clickCallback = g.getFunctionOption('clickCallback');
  var pointClickCallback = g.getFunctionOption('pointClickCallback');

  var selectedPoint = null;

  // Find out if the click occurs on a point.
  var closestIdx = -1;
  var closestDistance = Number.MAX_VALUE;

  // check if the click was on a particular point.
  for (var i = 0; i < g.selPoints_.length; i++) {
    var p = g.selPoints_[i];
    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);
    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {
      closestDistance = distance;
      closestIdx = i;
    }
  }

  // Allow any click within two pixels of the dot.
  var radius = g.getNumericOption('highlightCircleSize') + 2;
  if (closestDistance <= radius * radius) {
    selectedPoint = g.selPoints_[closestIdx];
  }

  if (selectedPoint) {
    var e = {
      cancelable: true,
      point: selectedPoint,
      canvasx: context.dragEndX,
      canvasy: context.dragEndY
    };
    var defaultPrevented = g.cascadeEvents_('pointClick', e);
    if (defaultPrevented) {
      // Note: this also prevents click / clickCallback from firing.
      return;
    }
    if (pointClickCallback) {
      pointClickCallback.call(g, event, selectedPoint);
    }
  }

  var e = {
    cancelable: true,
    xval: g.lastx_, // closest point by x value
    pts: g.selPoints_,
    canvasx: context.dragEndX,
    canvasy: context.dragEndY
  };
  if (!g.cascadeEvents_('click', e)) {
    if (clickCallback) {
      // TODO(danvk): pass along more info about the points, e.g. 'x'
      clickCallback.call(g, event, g.lastx_, g.selPoints_);
    }
  }
};

/**
 * Called in response to an interaction model operation that
 * responds to an event that performs a zoom based on previously defined
 * bounds..
 *
 * It's used in the default callback for "mouseup" operations.
 * Custom interaction model builders can use it to provide the default
 * zooming behavior.
 *
 * @param {Event} event the event object which led to the endZoom call.
 * @param {Dygraph} g The dygraph on which to end the zoom.
 * @param {Object} context The dragging context object (with
 *     dragStartX/dragStartY/etc. properties). This function modifies the
 *     context.
 */
DygraphInteraction.endZoom = function (event, g, context) {
  g.clearZoomRect_();
  context.isZooming = false;
  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);

  // The zoom rectangle is visibly clipped to the plot area, so its behavior
  // should be as well.
  // See http://code.google.com/p/dygraphs/issues/detail?id=280
  var plotArea = g.getArea();
  if (context.regionWidth >= 10 && context.dragDirection == utils.HORIZONTAL) {
    var left = Math.min(context.dragStartX, context.dragEndX),
        right = Math.max(context.dragStartX, context.dragEndX);
    left = Math.max(left, plotArea.x);
    right = Math.min(right, plotArea.x + plotArea.w);
    if (left < right) {
      g.doZoomX_(left, right);
    }
    context.cancelNextDblclick = true;
  } else if (context.regionHeight >= 10 && context.dragDirection == utils.VERTICAL) {
    var top = Math.min(context.dragStartY, context.dragEndY),
        bottom = Math.max(context.dragStartY, context.dragEndY);
    top = Math.max(top, plotArea.y);
    bottom = Math.min(bottom, plotArea.y + plotArea.h);
    if (top < bottom) {
      g.doZoomY_(top, bottom);
    }
    context.cancelNextDblclick = true;
  }
  context.dragStartX = null;
  context.dragStartY = null;
};

/**
 * @private
 */
DygraphInteraction.startTouch = function (event, g, context) {
  event.preventDefault(); // touch browsers are all nice.
  if (event.touches.length > 1) {
    // If the user ever puts two fingers down, it's not a double tap.
    context.startTimeForDoubleTapMs = null;
  }

  var touches = [];
  for (var i = 0; i < event.touches.length; i++) {
    var t = event.touches[i];
    // we dispense with 'dragGetX_' because all touchBrowsers support pageX
    touches.push({
      pageX: t.pageX,
      pageY: t.pageY,
      dataX: g.toDataXCoord(t.pageX),
      dataY: g.toDataYCoord(t.pageY)
      // identifier: t.identifier
    });
  }
  context.initialTouches = touches;

  if (touches.length == 1) {
    // This is just a swipe.
    context.initialPinchCenter = touches[0];
    context.touchDirections = { x: true, y: true };
  } else if (touches.length >= 2) {
    // It's become a pinch!
    // In case there are 3+ touches, we ignore all but the "first" two.

    // only screen coordinates can be averaged (data coords could be log scale).
    context.initialPinchCenter = {
      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),

      // TODO(danvk): remove
      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),
      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)
    };

    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.
    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX);

    // use symmetry to get it into the first quadrant.
    initialAngle = Math.abs(initialAngle);
    if (initialAngle > 90) initialAngle = 90 - initialAngle;

    context.touchDirections = {
      x: initialAngle < 90 - 45 / 2,
      y: initialAngle > 45 / 2
    };
  }

  // save the full x & y ranges.
  context.initialRange = {
    x: g.xAxisRange(),
    y: g.yAxisRange()
  };
};

/**
 * @private
 */
DygraphInteraction.moveTouch = function (event, g, context) {
  // If the tap moves, then it's definitely not part of a double-tap.
  context.startTimeForDoubleTapMs = null;

  var i,
      touches = [];
  for (i = 0; i < event.touches.length; i++) {
    var t = event.touches[i];
    touches.push({
      pageX: t.pageX,
      pageY: t.pageY
    });
  }
  var initialTouches = context.initialTouches;

  var c_now;

  // old and new centers.
  var c_init = context.initialPinchCenter;
  if (touches.length == 1) {
    c_now = touches[0];
  } else {
    c_now = {
      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)
    };
  }

  // this is the "swipe" component
  // we toss it out for now, but could use it in the future.
  var swipe = {
    pageX: c_now.pageX - c_init.pageX,
    pageY: c_now.pageY - c_init.pageY
  };
  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];
  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];
  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;
  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;
  var xScale, yScale;

  // The residual bits are usually split into scale & rotate bits, but we split
  // them into x-scale and y-scale bits.
  if (touches.length == 1) {
    xScale = 1.0;
    yScale = 1.0;
  } else if (touches.length >= 2) {
    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;
    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;

    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;
    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;
  }

  // Clip scaling to [1/8, 8] to prevent too much blowup.
  xScale = Math.min(8, Math.max(0.125, xScale));
  yScale = Math.min(8, Math.max(0.125, yScale));

  var didZoom = false;
  if (context.touchDirections.x) {
    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];
    didZoom = true;
  }

  if (context.touchDirections.y) {
    for (i = 0; i < 1 /*g.axes_.length*/; i++) {
      var axis = g.axes_[i];
      var logscale = g.attributes_.getForAxis("logscale", i);
      if (logscale) {
        // TODO(danvk): implement
      } else {
          axis.valueWindow = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];
          didZoom = true;
        }
    }
  }

  g.drawGraph_(false);

  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.
  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {
    var viewWindow = g.xAxisRange();
    g.getFunctionOption("zoomCallback").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());
  }
};

/**
 * @private
 */
DygraphInteraction.endTouch = function (event, g, context) {
  if (event.touches.length !== 0) {
    // this is effectively a "reset"
    DygraphInteraction.startTouch(event, g, context);
  } else if (event.changedTouches.length == 1) {
    // Could be part of a "double tap"
    // The heuristic here is that it's a double-tap if the two touchend events
    // occur within 500ms and within a 50x50 pixel box.
    var now = new Date().getTime();
    var t = event.changedTouches[0];
    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {
      g.resetZoom();
    } else {
      context.startTimeForDoubleTapMs = now;
      context.doubleTapX = t.screenX;
      context.doubleTapY = t.screenY;
    }
  }
};

// Determine the distance from x to [left, right].
var distanceFromInterval = function distanceFromInterval(x, left, right) {
  if (x < left) {
    return left - x;
  } else if (x > right) {
    return x - right;
  } else {
    return 0;
  }
};

/**
 * Returns the number of pixels by which the event happens from the nearest
 * edge of the chart. For events in the interior of the chart, this returns zero.
 */
var distanceFromChart = function distanceFromChart(event, g) {
  var chartPos = utils.findPos(g.canvas_);
  var box = {
    left: chartPos.x,
    right: chartPos.x + g.canvas_.offsetWidth,
    top: chartPos.y,
    bottom: chartPos.y + g.canvas_.offsetHeight
  };

  var pt = {
    x: utils.pageX(event),
    y: utils.pageY(event)
  };

  var dx = distanceFromInterval(pt.x, box.left, box.right),
      dy = distanceFromInterval(pt.y, box.top, box.bottom);
  return Math.max(dx, dy);
};

/**
 * Default interation model for dygraphs. You can refer to specific elements of
 * this when constructing your own interaction model, e.g.:
 * g.updateOptions( {
 *   interactionModel: {
 *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown
 *   }
 * } );
 */
DygraphInteraction.defaultModel = {
  // Track the beginning of drag events
  mousedown: function mousedown(event, g, context) {
    // Right-click should not initiate a zoom.
    if (event.button && event.button == 2) return;

    context.initializeMouseDown(event, g, context);

    if (event.altKey || event.shiftKey) {
      DygraphInteraction.startPan(event, g, context);
    } else {
      DygraphInteraction.startZoom(event, g, context);
    }

    // Note: we register mousemove/mouseup on document to allow some leeway for
    // events to move outside of the chart. Interaction model events get
    // registered on the canvas, which is too small to allow this.
    var mousemove = function mousemove(event) {
      if (context.isZooming) {
        // When the mouse moves >200px from the chart edge, cancel the zoom.
        var d = distanceFromChart(event, g);
        if (d < DRAG_EDGE_MARGIN) {
          DygraphInteraction.moveZoom(event, g, context);
        } else {
          if (context.dragEndX !== null) {
            context.dragEndX = null;
            context.dragEndY = null;
            g.clearZoomRect_();
          }
        }
      } else if (context.isPanning) {
        DygraphInteraction.movePan(event, g, context);
      }
    };
    var mouseup = function mouseup(event) {
      if (context.isZooming) {
        if (context.dragEndX !== null) {
          DygraphInteraction.endZoom(event, g, context);
        } else {
          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);
        }
      } else if (context.isPanning) {
        DygraphInteraction.endPan(event, g, context);
      }

      utils.removeEvent(document, 'mousemove', mousemove);
      utils.removeEvent(document, 'mouseup', mouseup);
      context.destroy();
    };

    g.addAndTrackEvent(document, 'mousemove', mousemove);
    g.addAndTrackEvent(document, 'mouseup', mouseup);
  },
  willDestroyContextMyself: true,

  touchstart: function touchstart(event, g, context) {
    DygraphInteraction.startTouch(event, g, context);
  },
  touchmove: function touchmove(event, g, context) {
    DygraphInteraction.moveTouch(event, g, context);
  },
  touchend: function touchend(event, g, context) {
    DygraphInteraction.endTouch(event, g, context);
  },

  // Disable zooming out if panning.
  dblclick: function dblclick(event, g, context) {
    if (context.cancelNextDblclick) {
      context.cancelNextDblclick = false;
      return;
    }

    // Give plugins a chance to grab this event.
    var e = {
      canvasx: context.dragEndX,
      canvasy: context.dragEndY
    };
    if (g.cascadeEvents_('dblclick', e)) {
      return;
    }

    if (event.altKey || event.shiftKey) {
      return;
    }
    g.resetZoom();
  }
};

/*
Dygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;

// old ways of accessing these methods/properties
Dygraph.defaultInteractionModel = DygraphInteraction.defaultModel;
Dygraph.endZoom = DygraphInteraction.endZoom;
Dygraph.moveZoom = DygraphInteraction.moveZoom;
Dygraph.startZoom = DygraphInteraction.startZoom;
Dygraph.endPan = DygraphInteraction.endPan;
Dygraph.movePan = DygraphInteraction.movePan;
Dygraph.startPan = DygraphInteraction.startPan;
*/

DygraphInteraction.nonInteractiveModel_ = {
  mousedown: function mousedown(event, g, context) {
    context.initializeMouseDown(event, g, context);
  },
  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick
};

// Default interaction model when using the range selector.
DygraphInteraction.dragIsPanInteractionModel = {
  mousedown: function mousedown(event, g, context) {
    context.initializeMouseDown(event, g, context);
    DygraphInteraction.startPan(event, g, context);
  },
  mousemove: function mousemove(event, g, context) {
    if (context.isPanning) {
      DygraphInteraction.movePan(event, g, context);
    }
  },
  mouseup: function mouseup(event, g, context) {
    if (context.isPanning) {
      DygraphInteraction.endPan(event, g, context);
    }
  }
};

exports["default"] = DygraphInteraction;
module.exports = exports["default"];

},{"./dygraph-utils":16}],12:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Based on PlotKitLayout, but modified to meet the needs of
 * dygraphs.
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * Creates a new DygraphLayout object.
 *
 * This class contains all the data to be charted.
 * It uses data coordinates, but also records the chart range (in data
 * coordinates) and hence is able to calculate percentage positions ('In this
 * view, Point A lies 25% down the x-axis.')
 *
 * Two things that it does not do are:
 * 1. Record pixel coordinates for anything.
 * 2. (oddly) determine anything about the layout of chart elements.
 *
 * The naming is a vestige of Dygraph's original PlotKit roots.
 *
 * @constructor
 */
var DygraphLayout = function DygraphLayout(dygraph) {
  this.dygraph_ = dygraph;
  /**
   * Array of points for each series.
   *
   * [series index][row index in series] = |Point| structure,
   * where series index refers to visible series only, and the
   * point index is for the reduced set of points for the current
   * zoom region (including one point just outside the window).
   * All points in the same row index share the same X value.
   *
   * @type {Array.<Array.<Dygraph.PointType>>}
   */
  this.points = [];
  this.setNames = [];
  this.annotations = [];
  this.yAxes_ = null;

  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and
  // yticks are outputs. Clean this up.
  this.xTicks_ = null;
  this.yTicks_ = null;
};

/**
 * Add points for a single series.
 *
 * @param {string} setname Name of the series.
 * @param {Array.<Dygraph.PointType>} set_xy Points for the series.
 */
DygraphLayout.prototype.addDataset = function (setname, set_xy) {
  this.points.push(set_xy);
  this.setNames.push(setname);
};

/**
 * Returns the box which the chart should be drawn in. This is the canvas's
 * box, less space needed for the axis and chart labels.
 *
 * @return {{x: number, y: number, w: number, h: number}}
 */
DygraphLayout.prototype.getPlotArea = function () {
  return this.area_;
};

// Compute the box which the chart should be drawn in. This is the canvas's
// box, less space needed for axis, chart labels, and other plug-ins.
// NOTE: This should only be called by Dygraph.predraw_().
DygraphLayout.prototype.computePlotArea = function () {
  var area = {
    // TODO(danvk): per-axis setting.
    x: 0,
    y: 0
  };

  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');
  area.h = this.dygraph_.height_;

  // Let plugins reserve space.
  var e = {
    chart_div: this.dygraph_.graphDiv,
    reserveSpaceLeft: function reserveSpaceLeft(px) {
      var r = {
        x: area.x,
        y: area.y,
        w: px,
        h: area.h
      };
      area.x += px;
      area.w -= px;
      return r;
    },
    reserveSpaceRight: function reserveSpaceRight(px) {
      var r = {
        x: area.x + area.w - px,
        y: area.y,
        w: px,
        h: area.h
      };
      area.w -= px;
      return r;
    },
    reserveSpaceTop: function reserveSpaceTop(px) {
      var r = {
        x: area.x,
        y: area.y,
        w: area.w,
        h: px
      };
      area.y += px;
      area.h -= px;
      return r;
    },
    reserveSpaceBottom: function reserveSpaceBottom(px) {
      var r = {
        x: area.x,
        y: area.y + area.h - px,
        w: area.w,
        h: px
      };
      area.h -= px;
      return r;
    },
    chartRect: function chartRect() {
      return { x: area.x, y: area.y, w: area.w, h: area.h };
    }
  };
  this.dygraph_.cascadeEvents_('layout', e);

  this.area_ = area;
};

DygraphLayout.prototype.setAnnotations = function (ann) {
  // The Dygraph object's annotations aren't parsed. We parse them here and
  // save a copy. If there is no parser, then the user must be using raw format.
  this.annotations = [];
  var parse = this.dygraph_.getOption('xValueParser') || function (x) {
    return x;
  };
  for (var i = 0; i < ann.length; i++) {
    var a = {};
    if (!ann[i].xval && ann[i].x === undefined) {
      console.error("Annotations must have an 'x' property");
      return;
    }
    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {
      console.error("Must set width and height when setting " + "annotation.icon property");
      return;
    }
    utils.update(a, ann[i]);
    if (!a.xval) a.xval = parse(a.x);
    this.annotations.push(a);
  }
};

DygraphLayout.prototype.setXTicks = function (xTicks) {
  this.xTicks_ = xTicks;
};

// TODO(danvk): add this to the Dygraph object's API or move it into Layout.
DygraphLayout.prototype.setYAxes = function (yAxes) {
  this.yAxes_ = yAxes;
};

DygraphLayout.prototype.evaluate = function () {
  this._xAxis = {};
  this._evaluateLimits();
  this._evaluateLineCharts();
  this._evaluateLineTicks();
  this._evaluateAnnotations();
};

DygraphLayout.prototype._evaluateLimits = function () {
  var xlimits = this.dygraph_.xAxisRange();
  this._xAxis.minval = xlimits[0];
  this._xAxis.maxval = xlimits[1];
  var xrange = xlimits[1] - xlimits[0];
  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;

  if (this.dygraph_.getOptionForAxis("logscale", 'x')) {
    this._xAxis.xlogrange = utils.log10(this._xAxis.maxval) - utils.log10(this._xAxis.minval);
    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;
  }
  for (var i = 0; i < this.yAxes_.length; i++) {
    var axis = this.yAxes_[i];
    axis.minyval = axis.computedValueRange[0];
    axis.maxyval = axis.computedValueRange[1];
    axis.yrange = axis.maxyval - axis.minyval;
    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;

    if (this.dygraph_.getOption("logscale")) {
      axis.ylogrange = utils.log10(axis.maxyval) - utils.log10(axis.minyval);
      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;
      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {
        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');
      }
    }
  }
};

DygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {
  if (logscale) {
    return (utils.log10(value) - utils.log10(xAxis.minval)) * xAxis.xlogscale;
  } else {
    return (value - xAxis.minval) * xAxis.scale;
  }
};

/**
 * @param {DygraphAxisType} axis
 * @param {number} value
 * @param {boolean} logscale
 * @return {number}
 */
DygraphLayout.calcYNormal_ = function (axis, value, logscale) {
  if (logscale) {
    var x = 1.0 - (utils.log10(value) - utils.log10(axis.minyval)) * axis.ylogscale;
    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276
  } else {
      return 1.0 - (value - axis.minyval) * axis.yscale;
    }
};

DygraphLayout.prototype._evaluateLineCharts = function () {
  var isStacked = this.dygraph_.getOption("stackedGraph");
  var isLogscaleForX = this.dygraph_.getOptionForAxis("logscale", 'x');

  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
    var points = this.points[setIdx];
    var setName = this.setNames[setIdx];
    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);
    var axis = this.dygraph_.axisPropertiesForSeries(setName);
    // TODO (konigsberg): use optionsForAxis instead.
    var logscale = this.dygraph_.attributes_.getForSeries("logscale", setName);

    for (var j = 0; j < points.length; j++) {
      var point = points[j];

      // Range from 0-1 where 0 represents left and 1 represents right.
      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);
      // Range from 0-1 where 0 represents top and 1 represents bottom
      var yval = point.yval;
      if (isStacked) {
        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);
        if (yval !== null && !isNaN(yval)) {
          yval = point.yval_stacked;
        }
      }
      if (yval === null) {
        yval = NaN;
        if (!connectSeparated) {
          point.yval = NaN;
        }
      }
      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);
    }

    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);
  }
};

DygraphLayout.prototype._evaluateLineTicks = function () {
  var i, tick, label, pos, v, has_tick;
  this.xticks = [];
  for (i = 0; i < this.xTicks_.length; i++) {
    tick = this.xTicks_[i];
    label = tick.label;
    has_tick = !('label_v' in tick);
    v = has_tick ? tick.v : tick.label_v;
    pos = this.dygraph_.toPercentXCoord(v);
    if (pos >= 0.0 && pos < 1.0) {
      this.xticks.push({ pos: pos, label: label, has_tick: has_tick });
    }
  }

  this.yticks = [];
  for (i = 0; i < this.yAxes_.length; i++) {
    var axis = this.yAxes_[i];
    for (var j = 0; j < axis.ticks.length; j++) {
      tick = axis.ticks[j];
      label = tick.label;
      has_tick = !('label_v' in tick);
      v = has_tick ? tick.v : tick.label_v;
      pos = this.dygraph_.toPercentYCoord(v, i);
      if (pos > 0.0 && pos <= 1.0) {
        this.yticks.push({ axis: i, pos: pos, label: label, has_tick: has_tick });
      }
    }
  }
};

DygraphLayout.prototype._evaluateAnnotations = function () {
  // Add the annotations to the point to which they belong.
  // Make a map from (setName, xval) to annotation for quick lookups.
  var i;
  var annotations = {};
  for (i = 0; i < this.annotations.length; i++) {
    var a = this.annotations[i];
    annotations[a.xval + "," + a.series] = a;
  }

  this.annotated_points = [];

  // Exit the function early if there are no annotations.
  if (!this.annotations || !this.annotations.length) {
    return;
  }

  // TODO(antrob): loop through annotations not points.
  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
    var points = this.points[setIdx];
    for (i = 0; i < points.length; i++) {
      var p = points[i];
      var k = p.xval + "," + p.name;
      if (k in annotations) {
        p.annotation = annotations[k];
        this.annotated_points.push(p);
      }
    }
  }
};

/**
 * Convenience function to remove all the data sets from a graph
 */
DygraphLayout.prototype.removeAllDatasets = function () {
  delete this.points;
  delete this.setNames;
  delete this.setPointsLengths;
  delete this.setPointsOffsets;
  this.points = [];
  this.setNames = [];
  this.setPointsLengths = [];
  this.setPointsOffsets = [];
};

exports['default'] = DygraphLayout;
module.exports = exports['default'];

},{"./dygraph-utils":16}],13:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var OPTIONS_REFERENCE = null;

// For "production" code, this gets removed by uglifyjs.
if ("development" != 'production') {

  // NOTE: in addition to parsing as JS, this snippet is expected to be valid
  // JSON. This assumption cannot be checked in JS, but it will be checked when
  // documentation is generated by the generate-documentation.py script. For the
  // most part, this just means that you should always use double quotes.
  OPTIONS_REFERENCE = // <JSON>
  {
    "xValueParser": {
      "default": "parseFloat() or Date.parse()*",
      "labels": ["CSV parsing"],
      "type": "function(str) -> number",
      "description": "A function which parses x-values (i.e. the dependent series). Must return a number, even when the values are dates. In this case, millis since epoch are used. This is used primarily for parsing CSV data. *=Dygraphs is slightly more accepting in the dates which it will parse. See code for details."
    },
    "stackedGraph": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "If set, stack series on top of one another rather than drawing them independently. The first series specified in the input data will wind up on top of the chart and the last will be on bottom. NaN values are drawn as white areas without a line on top, see stackedGraphNaNFill for details."
    },
    "stackedGraphNaNFill": {
      "default": "all",
      "labels": ["Data Line display"],
      "type": "string",
      "description": "Controls handling of NaN values inside a stacked graph. NaN values are interpolated/extended for stacking purposes, but the actual point value remains NaN in the legend display. Valid option values are \"all\" (interpolate internally, repeat leftmost and rightmost value as needed), \"inside\" (interpolate internally only, use zero outside leftmost and rightmost value), and \"none\" (treat NaN as zero everywhere)."
    },
    "pointSize": {
      "default": "1",
      "labels": ["Data Line display"],
      "type": "integer",
      "description": "The size of the dot to draw on each point in pixels (see drawPoints). A dot is always drawn when a point is \"isolated\", i.e. there is a missing point on either side of it. This also controls the size of those dots."
    },
    "labelsDivStyles": {
      "default": "null",
      "labels": ["Legend"],
      "type": "{}",
      "description": "Additional styles to apply to the currently-highlighted points div. For example, { 'fontWeight': 'bold' } will make the labels bold. In general, it is better to use CSS to style the .dygraph-legend class than to use this property."
    },
    "drawPoints": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "Draw a small dot at each point, in addition to a line going through the point. This makes the individual data points easier to see, but can increase visual clutter in the chart. The small dot can be replaced with a custom rendering by supplying a <a href='#drawPointCallback'>drawPointCallback</a>."
    },
    "drawGapEdgePoints": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "Draw points at the edges of gaps in the data. This improves visibility of small data segments or other data irregularities."
    },
    "drawPointCallback": {
      "default": "null",
      "labels": ["Data Line display"],
      "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
      "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
      "description": "Draw a custom item when drawPoints is enabled. Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy).  Also see <a href='#drawHighlightPointCallback'>drawHighlightPointCallback</a>"
    },
    "height": {
      "default": "320",
      "labels": ["Overall display"],
      "type": "integer",
      "description": "Height, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
    },
    "zoomCallback": {
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(minDate, maxDate, yRanges)",
      "parameters": [["minDate", "milliseconds since epoch"], ["maxDate", "milliseconds since epoch."], ["yRanges", "is an array of [bottom, top] pairs, one for each y-axis."]],
      "description": "A function to call when the zoom window is changed (either by zooming in or out). When animatedZooms is set, zoomCallback is called once at the end of the transition (it will not be called for intermediate frames)."
    },
    "pointClickCallback": {
      "snippet": "function(e, point){<br>&nbsp;&nbsp;alert(point);<br>}",
      "default": "null",
      "labels": ["Callbacks", "Interactive Elements"],
      "type": "function(e, point)",
      "parameters": [["e", "the event object for the click"], ["point", "the point that was clicked See <a href='#point_properties'>Point properties</a> for details"]],
      "description": "A function to call when a data point is clicked. and the point that was clicked."
    },
    "color": {
      "default": "(see description)",
      "labels": ["Data Series Colors"],
      "type": "string",
      "example": "red",
      "description": "A per-series color definition. Used in conjunction with, and overrides, the colors option."
    },
    "colors": {
      "default": "(see description)",
      "labels": ["Data Series Colors"],
      "type": "array<string>",
      "example": "['red', '#00FF00']",
      "description": "List of colors for the data series. These can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\", etc. If not specified, equally-spaced points around a color wheel are used. Overridden by the 'color' option."
    },
    "connectSeparatedPoints": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "Usually, when Dygraphs encounters a missing value in a data series, it interprets this as a gap and draws it as such. If, instead, the missing values represents an x-value for which only a different series has data, then you'll want to connect the dots by setting this to true. To explicitly include a gap with this option set, use a value of NaN."
    },
    "highlightCallback": {
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(event, x, points, row, seriesName)",
      "description": "When set, this callback gets called every time a new point is highlighted.",
      "parameters": [["event", "the JavaScript mousemove event"], ["x", "the x-coordinate of the highlighted points"], ["points", "an array of highlighted points: <code>[ {name: 'series', yval: y-value}, &hellip; ]</code>"], ["row", "integer index of the highlighted row in the data table, starting from 0"], ["seriesName", "name of the highlighted series, only present if highlightSeriesOpts is set."]]
    },
    "drawHighlightPointCallback": {
      "default": "null",
      "labels": ["Data Line display"],
      "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
      "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
      "description": "Draw a custom item when a point is highlighted.  Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy) Also see <a href='#drawPointCallback'>drawPointCallback</a>"
    },
    "highlightSeriesOpts": {
      "default": "null",
      "labels": ["Interactive Elements"],
      "type": "Object",
      "description": "When set, the options from this object are applied to the timeseries closest to the mouse pointer for interactive highlighting. See also 'highlightCallback'. Example: highlightSeriesOpts: { strokeWidth: 3 }."
    },
    "highlightSeriesBackgroundAlpha": {
      "default": "0.5",
      "labels": ["Interactive Elements"],
      "type": "float",
      "description": "Fade the background while highlighting series. 1=fully visible background (disable fading), 0=hiddden background (show highlighted series only)."
    },
    "highlightSeriesBackgroundColor": {
      "default": "rgb(255, 255, 255)",
      "labels": ["Interactive Elements"],
      "type": "string",
      "description": "Sets the background color used to fade out the series in conjunction with 'highlightSeriesBackgroundAlpha'."
    },
    "includeZero": {
      "default": "false",
      "labels": ["Axis display"],
      "type": "boolean",
      "description": "Usually, dygraphs will use the range of the data plus some padding to set the range of the y-axis. If this option is set, the y-axis will always include zero, typically as the lowest value. This can be used to avoid exaggerating the variance in the data"
    },
    "rollPeriod": {
      "default": "1",
      "labels": ["Error Bars", "Rolling Averages"],
      "type": "integer &gt;= 1",
      "description": "Number of days over which to average data. Discussed extensively above."
    },
    "unhighlightCallback": {
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(event)",
      "parameters": [["event", "the mouse event"]],
      "description": "When set, this callback gets called every time the user stops highlighting any point by mousing out of the graph."
    },
    "axisTickSize": {
      "default": "3.0",
      "labels": ["Axis display"],
      "type": "number",
      "description": "The size of the line to display next to each tick mark on x- or y-axes."
    },
    "labelsSeparateLines": {
      "default": "false",
      "labels": ["Legend"],
      "type": "boolean",
      "description": "Put <code>&lt;br/&gt;</code> between lines in the label string. Often used in conjunction with <strong>labelsDiv</strong>."
    },
    "valueFormatter": {
      "default": "Depends on the type of your data.",
      "labels": ["Legend", "Value display/formatting"],
      "type": "function(num or millis, opts, seriesName, dygraph, row, col)",
      "description": "Function to provide a custom display format for the values displayed on mouseover. This does not affect the values that appear on tick marks next to the axes. To format those, see axisLabelFormatter. This is usually set on a <a href='per-axis.html'>per-axis</a> basis. .",
      "parameters": [["num_or_millis", "The value to be formatted. This is always a number. For date axes, it's millis since epoch. You can call new Date(millis) to get a Date object."], ["opts", "This is a function you can call to access various options (e.g. opts('labelsKMB')). It returns per-axis values for the option when available."], ["seriesName", "The name of the series from which the point came, e.g. 'X', 'Y', 'A', etc."], ["dygraph", "The dygraph object for which the formatting is being done"], ["row", "The row of the data from which this point comes. g.getValue(row, 0) will return the x-value for this point."], ["col", "The column of the data from which this point comes. g.getValue(row, col) will return the original y-value for this point. This can be used to get the full confidence interval for the point, or access un-rolled values for the point."]]
    },
    "annotationMouseOverHandler": {
      "default": "null",
      "labels": ["Annotations"],
      "type": "function(annotation, point, dygraph, event)",
      "description": "If provided, this function is called whenever the user mouses over an annotation."
    },
    "annotationMouseOutHandler": {
      "default": "null",
      "labels": ["Annotations"],
      "type": "function(annotation, point, dygraph, event)",
      "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
      "description": "If provided, this function is called whenever the user mouses out of an annotation."
    },
    "annotationClickHandler": {
      "default": "null",
      "labels": ["Annotations"],
      "type": "function(annotation, point, dygraph, event)",
      "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
      "description": "If provided, this function is called whenever the user clicks on an annotation."
    },
    "annotationDblClickHandler": {
      "default": "null",
      "labels": ["Annotations"],
      "type": "function(annotation, point, dygraph, event)",
      "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
      "description": "If provided, this function is called whenever the user double-clicks on an annotation."
    },
    "drawCallback": {
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(dygraph, is_initial)",
      "parameters": [["dygraph", "The graph being drawn"], ["is_initial", "True if this is the initial draw, false for subsequent draws."]],
      "description": "When set, this callback gets called every time the dygraph is drawn. This includes the initial draw, after zooming and repeatedly while panning."
    },
    "labelsKMG2": {
      "default": "false",
      "labels": ["Value display/formatting"],
      "type": "boolean",
      "description": "Show k/M/G for kilo/Mega/Giga on y-axis. This is different than <code>labelsKMB</code> in that it uses base 2, not 10."
    },
    "delimiter": {
      "default": ",",
      "labels": ["CSV parsing"],
      "type": "string",
      "description": "The delimiter to look for when separating fields of a CSV file. Setting this to a tab is not usually necessary, since tab-delimited data is auto-detected."
    },
    "axisLabelFontSize": {
      "default": "14",
      "labels": ["Axis display"],
      "type": "integer",
      "description": "Size of the font (in pixels) to use in the axis labels, both x- and y-axis."
    },
    "underlayCallback": {
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(context, area, dygraph)",
      "parameters": [["context", "the canvas drawing context on which to draw"], ["area", "An object with {x,y,w,h} properties describing the drawing area."], ["dygraph", "the reference graph"]],
      "description": "When set, this callback gets called before the chart is drawn. It details on how to use this."
    },
    "width": {
      "default": "480",
      "labels": ["Overall display"],
      "type": "integer",
      "description": "Width, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
    },
    "interactionModel": {
      "default": "...",
      "labels": ["Interactive Elements"],
      "type": "Object",
      "description": "TODO(konigsberg): document this"
    },
    "ticker": {
      "default": "Dygraph.dateTicker or Dygraph.numericTicks",
      "labels": ["Axis display"],
      "type": "function(min, max, pixels, opts, dygraph, vals) -> [{v: ..., label: ...}, ...]",
      "parameters": [["min", ""], ["max", ""], ["pixels", ""], ["opts", ""], ["dygraph", "the reference graph"], ["vals", ""]],
      "description": "This lets you specify an arbitrary function to generate tick marks on an axis. The tick marks are an array of (value, label) pairs. The built-in functions go to great lengths to choose good tick marks so, if you set this option, you'll most likely want to call one of them and modify the result. See dygraph-tickers.js for an extensive discussion. This is set on a <a href='per-axis.html'>per-axis</a> basis."
    },
    "xAxisHeight": {
      "default": "(null)",
      "labels": ["Axis display"],
      "type": "integer",
      "description": "Height, in pixels, of the x-axis. If not set explicitly, this is computed based on axisLabelFontSize and axisTickSize."
    },
    "showLabelsOnHighlight": {
      "default": "true",
      "labels": ["Interactive Elements", "Legend"],
      "type": "boolean",
      "description": "Whether to show the legend upon mouseover."
    },
    "axis": {
      "default": "(none)",
      "labels": ["Axis display"],
      "type": "string",
      "description": "Set to either 'y1' or 'y2' to assign a series to a y-axis (primary or secondary). Must be set per-series."
    },
    "pixelsPerLabel": {
      "default": "70 (x-axis) or 30 (y-axes)",
      "labels": ["Axis display", "Grid"],
      "type": "integer",
      "description": "Number of pixels to require between each x- and y-label. Larger values will yield a sparser axis with fewer ticks. This is set on a <a href='per-axis.html'>per-axis</a> basis."
    },
    "labelsDiv": {
      "default": "null",
      "labels": ["Legend"],
      "type": "DOM element or string",
      "example": "<code style='font-size: small'>document.getElementById('foo')</code>or<code>'foo'",
      "description": "Show data labels in an external div, rather than on the graph.  This value can either be a div element or a div id."
    },
    "fractions": {
      "default": "false",
      "labels": ["CSV parsing", "Error Bars"],
      "type": "boolean",
      "description": "When set, attempt to parse each cell in the CSV file as \"a/b\", where a and b are integers. The ratio will be plotted. This allows computation of Wilson confidence intervals (see below)."
    },
    "logscale": {
      "default": "false",
      "labels": ["Axis display"],
      "type": "boolean",
      "description": "When set for the y-axis or x-axis, the graph shows that axis in log scale. Any values less than or equal to zero are not displayed. Showing log scale with ranges that go below zero will result in an unviewable graph.\n\n Not compatible with showZero. connectSeparatedPoints is ignored. This is ignored for date-based x-axes."
    },
    "strokeWidth": {
      "default": "1.0",
      "labels": ["Data Line display"],
      "type": "float",
      "example": "0.5, 2.0",
      "description": "The width of the lines connecting data points. This can be used to increase the contrast or some graphs."
    },
    "strokePattern": {
      "default": "null",
      "labels": ["Data Line display"],
      "type": "array<integer>",
      "example": "[10, 2, 5, 2]",
      "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed lines."
    },
    "strokeBorderWidth": {
      "default": "null",
      "labels": ["Data Line display"],
      "type": "float",
      "example": "1.0",
      "description": "Draw a border around graph lines to make crossing lines more easily distinguishable. Useful for graphs with many lines."
    },
    "strokeBorderColor": {
      "default": "white",
      "labels": ["Data Line display"],
      "type": "string",
      "example": "red, #ccffdd",
      "description": "Color for the line border used if strokeBorderWidth is set."
    },
    "wilsonInterval": {
      "default": "true",
      "labels": ["Error Bars"],
      "type": "boolean",
      "description": "Use in conjunction with the \"fractions\" option. Instead of plotting +/- N standard deviations, dygraphs will compute a Wilson confidence interval and plot that. This has more reasonable behavior for ratios close to 0 or 1."
    },
    "fillGraph": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "Should the area underneath the graph be filled? This option is not compatible with error bars. This may be set on a <a href='per-axis.html'>per-series</a> basis."
    },
    "highlightCircleSize": {
      "default": "3",
      "labels": ["Interactive Elements"],
      "type": "integer",
      "description": "The size in pixels of the dot drawn over highlighted points."
    },
    "gridLineColor": {
      "default": "rgb(128,128,128)",
      "labels": ["Grid"],
      "type": "red, blue",
      "description": "The color of the gridlines. This may be set on a per-axis basis to define each axis' grid separately."
    },
    "gridLinePattern": {
      "default": "null",
      "labels": ["Grid"],
      "type": "array<integer>",
      "example": "[10, 2, 5, 2]",
      "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed gridlines."
    },
    "visibility": {
      "default": "[true, true, ...]",
      "labels": ["Data Line display"],
      "type": "Array of booleans",
      "description": "Which series should initially be visible? Once the Dygraph has been constructed, you can access and modify the visibility of each series using the <code>visibility</code> and <code>setVisibility</code> methods."
    },
    "valueRange": {
      "default": "Full range of the input is shown",
      "labels": ["Axis display"],
      "type": "Array of two numbers",
      "example": "[10, 110]",
      "description": "Explicitly set the vertical range of the graph to [low, high]. This may be set on a per-axis basis to define each y-axis separately. If either limit is unspecified, it will be calculated automatically (e.g. [null, 30] to automatically calculate just the lower bound)"
    },
    "labelsDivWidth": {
      "default": "250",
      "labels": ["Legend"],
      "type": "integer",
      "description": "Width (in pixels) of the div which shows information on the currently-highlighted points."
    },
    "colorSaturation": {
      "default": "1.0",
      "labels": ["Data Series Colors"],
      "type": "float (0.0 - 1.0)",
      "description": "If <strong>colors</strong> is not specified, saturation of the automatically-generated data series colors."
    },
    "hideOverlayOnMouseOut": {
      "default": "true",
      "labels": ["Interactive Elements", "Legend"],
      "type": "boolean",
      "description": "Whether to hide the legend when the mouse leaves the chart area."
    },
    "legend": {
      "default": "onmouseover",
      "labels": ["Legend"],
      "type": "string",
      "description": "When to display the legend. By default, it only appears when a user mouses over the chart. Set it to \"always\" to always display a legend of some sort. When set to \"follow\", legend follows highlighted points."
    },
    "legendFormatter": {
      "default": "null",
      "labels": ["Legend"],
      "type": "function(data): string",
      "params": [["data", "An object containing information about the selection (or lack of a selection). This includes formatted values and series information. See <a href=\"https://github.com/danvk/dygraphs/pull/683\">here</a> for sample values."]],
      "description": "Set this to supply a custom formatter for the legend. See <a href=\"https://github.com/danvk/dygraphs/pull/683\">this comment</a> and the <a href=\"tests/legend-formatter.html\">legendFormatter demo</a> for usage."
    },
    "labelsShowZeroValues": {
      "default": "true",
      "labels": ["Legend"],
      "type": "boolean",
      "description": "Show zero value labels in the labelsDiv."
    },
    "stepPlot": {
      "default": "false",
      "labels": ["Data Line display"],
      "type": "boolean",
      "description": "When set, display the graph as a step plot instead of a line plot. This option may either be set for the whole graph or for single series."
    },
    "labelsUTC": {
      "default": "false",
      "labels": ["Value display/formatting", "Axis display"],
      "type": "boolean",
      "description": "Show date/time labels according to UTC (instead of local time)."
    },
    "labelsKMB": {
      "default": "false",
      "labels": ["Value display/formatting"],
      "type": "boolean",
      "description": "Show K/M/B for thousands/millions/billions on y-axis."
    },
    "rightGap": {
      "default": "5",
      "labels": ["Overall display"],
      "type": "integer",
      "description": "Number of pixels to leave blank at the right edge of the Dygraph. This makes it easier to highlight the right-most data point."
    },
    "avoidMinZero": {
      "default": "false",
      "labels": ["Deprecated"],
      "type": "boolean",
      "description": "Deprecated, please use yRangePad instead. When set, the heuristic that fixes the Y axis at zero for a data set with the minimum Y value of zero is disabled. \nThis is particularly useful for data sets that contain many zero values, especially for step plots which may otherwise have lines not visible running along the bottom axis."
    },
    "drawAxesAtZero": {
      "default": "false",
      "labels": ["Axis display"],
      "type": "boolean",
      "description": "When set, draw the X axis at the Y=0 position and the Y axis at the X=0 position if those positions are inside the graph's visible area. Otherwise, draw the axes at the bottom or left graph edge as usual."
    },
    "xRangePad": {
      "default": "0",
      "labels": ["Axis display"],
      "type": "float",
      "description": "Add the specified amount of extra space (in pixels) around the X-axis value range to ensure points at the edges remain visible."
    },
    "yRangePad": {
      "default": "null",
      "labels": ["Axis display"],
      "type": "float",
      "description": "If set, add the specified amount of extra space (in pixels) around the Y-axis value range to ensure points at the edges remain visible. If unset, use the traditional Y padding algorithm."
    },
    "axisLabelFormatter": {
      "default": "Depends on the data type",
      "labels": ["Axis display"],
      "type": "function(number or Date, granularity, opts, dygraph)",
      "parameters": [["number or date", "Either a number (for a numeric axis) or a Date object (for a date axis)"], ["granularity", "specifies how fine-grained the axis is. For date axes, this is a reference to the time granularity enumeration, defined in dygraph-tickers.js, e.g. Dygraph.WEEKLY."], ["opts", "a function which provides access to various options on the dygraph, e.g. opts('labelsKMB')."], ["dygraph", "the referenced graph"]],
      "description": "Function to call to format the tick values that appear along an axis. This is usually set on a <a href='per-axis.html'>per-axis</a> basis."
    },
    "clickCallback": {
      "snippet": "function(e, date_millis){<br>&nbsp;&nbsp;alert(new Date(date_millis));<br>}",
      "default": "null",
      "labels": ["Callbacks"],
      "type": "function(e, x, points)",
      "parameters": [["e", "The event object for the click"], ["x", "The x value that was clicked (for dates, this is milliseconds since epoch)"], ["points", "The closest points along that date. See <a href='#point_properties'>Point properties</a> for details."]],
      "description": "A function to call when the canvas is clicked."
    },
    "labels": {
      "default": "[\"X\", \"Y1\", \"Y2\", ...]*",
      "labels": ["Legend"],
      "type": "array<string>",
      "description": "A name for each data series, including the independent (X) series. For CSV files and DataTable objections, this is determined by context. For raw data, this must be specified. If it is not, default values are supplied and a warning is logged."
    },
    "dateWindow": {
      "default": "Full range of the input is shown",
      "labels": ["Axis display"],
      "type": "Array of two numbers",
      "example": "[<br>&nbsp;&nbsp;Date.parse('2006-01-01'),<br>&nbsp;&nbsp;(new Date()).valueOf()<br>]",
      "description": "Initially zoom in on a section of the graph. Is of the form [earliest, latest], where earliest/latest are milliseconds since epoch. If the data for the x-axis is numeric, the values in dateWindow must also be numbers."
    },
    "showRoller": {
      "default": "false",
      "labels": ["Interactive Elements", "Rolling Averages"],
      "type": "boolean",
      "description": "If the rolling average period text box should be shown."
    },
    "sigma": {
      "default": "2.0",
      "labels": ["Error Bars"],
      "type": "float",
      "description": "When errorBars is set, shade this many standard deviations above/below each point."
    },
    "customBars": {
      "default": "false",
      "labels": ["CSV parsing", "Error Bars"],
      "type": "boolean",
      "description": "When set, parse each CSV cell as \"low;middle;high\". Error bars will be drawn for each point between low and high, with the series itself going through middle."
    },
    "colorValue": {
      "default": "1.0",
      "labels": ["Data Series Colors"],
      "type": "float (0.0 - 1.0)",
      "description": "If colors is not specified, value of the data series colors, as in hue/saturation/value. (0.0-1.0, default 0.5)"
    },
    "errorBars": {
      "default": "false",
      "labels": ["CSV parsing", "Error Bars"],
      "type": "boolean",
      "description": "Does the data contain standard deviations? Setting this to true alters the input format (see above)."
    },
    "displayAnnotations": {
      "default": "false",
      "labels": ["Annotations"],
      "type": "boolean",
      "description": "Only applies when Dygraphs is used as a GViz chart. Causes string columns following a data series to be interpreted as annotations on points in that series. This is the same format used by Google's AnnotatedTimeLine chart."
    },
    "panEdgeFraction": {
      "default": "null",
      "labels": ["Axis display", "Interactive Elements"],
      "type": "float",
      "description": "A value representing the farthest a graph may be panned, in percent of the display. For example, a value of 0.1 means that the graph can only be panned 10% pased the edges of the displayed values. null means no bounds."
    },
    "title": {
      "labels": ["Chart labels"],
      "type": "string",
      "default": "null",
      "description": "Text to display above the chart. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-title' classes."
    },
    "titleHeight": {
      "default": "18",
      "labels": ["Chart labels"],
      "type": "integer",
      "description": "Height of the chart title, in pixels. This also controls the default font size of the title. If you style the title on your own, this controls how much space is set aside above the chart for the title's div."
    },
    "xlabel": {
      "labels": ["Chart labels"],
      "type": "string",
      "default": "null",
      "description": "Text to display below the chart's x-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-xlabel' classes."
    },
    "xLabelHeight": {
      "labels": ["Chart labels"],
      "type": "integer",
      "default": "18",
      "description": "Height of the x-axis label, in pixels. This also controls the default font size of the x-axis label. If you style the label on your own, this controls how much space is set aside below the chart for the x-axis label's div."
    },
    "ylabel": {
      "labels": ["Chart labels"],
      "type": "string",
      "default": "null",
      "description": "Text to display to the left of the chart's y-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-ylabel' classes. The text will be rotated 90 degrees by default, so CSS rules may behave in unintuitive ways. No additional space is set aside for a y-axis label. If you need more space, increase the width of the y-axis tick labels using the yAxisLabelWidth option. If you need a wider div for the y-axis label, either style it that way with CSS (but remember that it's rotated, so width is controlled by the 'height' property) or set the yLabelWidth option."
    },
    "y2label": {
      "labels": ["Chart labels"],
      "type": "string",
      "default": "null",
      "description": "Text to display to the right of the chart's secondary y-axis. This label is only displayed if a secondary y-axis is present. See <a href='http://dygraphs.com/tests/two-axes.html'>this test</a> for an example of how to do this. The comments for the 'ylabel' option generally apply here as well. This label gets a 'dygraph-y2label' instead of a 'dygraph-ylabel' class."
    },
    "yLabelWidth": {
      "labels": ["Chart labels"],
      "type": "integer",
      "default": "18",
      "description": "Width of the div which contains the y-axis label. Since the y-axis label appears rotated 90 degrees, this actually affects the height of its div."
    },
    "isZoomedIgnoreProgrammaticZoom": {
      "default": "false",
      "labels": ["Zooming"],
      "type": "boolean",
      "description": "When this option is passed to updateOptions() along with either the <code>dateWindow</code> or <code>valueRange</code> options, the zoom flags are not changed to reflect a zoomed state. This is primarily useful for when the display area of a chart is changed programmatically and also where manual zooming is allowed and use is made of the <code>isZoomed</code> method to determine this."
    },
    "drawGrid": {
      "default": "true for x and y, false for y2",
      "labels": ["Grid"],
      "type": "boolean",
      "description": "Whether to display gridlines in the chart. This may be set on a per-axis basis to define the visibility of each axis' grid separately."
    },
    "independentTicks": {
      "default": "true for y, false for y2",
      "labels": ["Axis display", "Grid"],
      "type": "boolean",
      "description": "Only valid for y and y2, has no effect on x: This option defines whether the y axes should align their ticks or if they should be independent. Possible combinations: 1.) y=true, y2=false (default): y is the primary axis and the y2 ticks are aligned to the the ones of y. (only 1 grid) 2.) y=false, y2=true: y2 is the primary axis and the y ticks are aligned to the the ones of y2. (only 1 grid) 3.) y=true, y2=true: Both axis are independent and have their own ticks. (2 grids) 4.) y=false, y2=false: Invalid configuration causes an error."
    },
    "drawAxis": {
      "default": "true for x and y, false for y2",
      "labels": ["Axis display"],
      "type": "boolean",
      "description": "Whether to draw the specified axis. This may be set on a per-axis basis to define the visibility of each axis separately. Setting this to false also prevents axis ticks from being drawn and reclaims the space for the chart grid/lines."
    },
    "gridLineWidth": {
      "default": "0.3",
      "labels": ["Grid"],
      "type": "float",
      "description": "Thickness (in pixels) of the gridlines drawn under the chart. The vertical/horizontal gridlines can be turned off entirely by using the drawGrid option. This may be set on a per-axis basis to define each axis' grid separately."
    },
    "axisLineWidth": {
      "default": "0.3",
      "labels": ["Axis display"],
      "type": "float",
      "description": "Thickness (in pixels) of the x- and y-axis lines."
    },
    "axisLineColor": {
      "default": "black",
      "labels": ["Axis display"],
      "type": "string",
      "description": "Color of the x- and y-axis lines. Accepts any value which the HTML canvas strokeStyle attribute understands, e.g. 'black' or 'rgb(0, 100, 255)'."
    },
    "fillAlpha": {
      "default": "0.15",
      "labels": ["Error Bars", "Data Series Colors"],
      "type": "float (0.0 - 1.0)",
      "description": "Error bars (or custom bars) for each series are drawn in the same color as the series, but with partial transparency. This sets the transparency. A value of 0.0 means that the error bars will not be drawn, whereas a value of 1.0 means that the error bars will be as dark as the line for the series itself. This can be used to produce chart lines whose thickness varies at each point."
    },
    "axisLabelColor": {
      "default": "black",
      "labels": ["Axis display"],
      "type": "string",
      "description": "Color for x- and y-axis labels. This is a CSS color string."
    },
    "axisLabelWidth": {
      "default": "50 (y-axis), 60 (x-axis)",
      "labels": ["Axis display", "Chart labels"],
      "type": "integer",
      "description": "Width (in pixels) of the containing divs for x- and y-axis labels. For the y-axis, this also controls the width of the y-axis. Note that for the x-axis, this is independent from pixelsPerLabel, which controls the spacing between labels."
    },
    "sigFigs": {
      "default": "null",
      "labels": ["Value display/formatting"],
      "type": "integer",
      "description": "By default, dygraphs displays numbers with a fixed number of digits after the decimal point. If you'd prefer to have a fixed number of significant figures, set this option to that number of sig figs. A value of 2, for instance, would cause 1 to be display as 1.0 and 1234 to be displayed as 1.23e+3."
    },
    "digitsAfterDecimal": {
      "default": "2",
      "labels": ["Value display/formatting"],
      "type": "integer",
      "description": "Unless it's run in scientific mode (see the <code>sigFigs</code> option), dygraphs displays numbers with <code>digitsAfterDecimal</code> digits after the decimal point. Trailing zeros are not displayed, so with a value of 2 you'll get '0', '0.1', '0.12', '123.45' but not '123.456' (it will be rounded to '123.46'). Numbers with absolute value less than 0.1^digitsAfterDecimal (i.e. those which would show up as '0.00') will be displayed in scientific notation."
    },
    "maxNumberWidth": {
      "default": "6",
      "labels": ["Value display/formatting"],
      "type": "integer",
      "description": "When displaying numbers in normal (not scientific) mode, large numbers will be displayed with many trailing zeros (e.g. 100000000 instead of 1e9). This can lead to unwieldy y-axis labels. If there are more than <code>maxNumberWidth</code> digits to the left of the decimal in a number, dygraphs will switch to scientific notation, even when not operating in scientific mode. If you'd like to see all those digits, set this to something large, like 20 or 30."
    },
    "file": {
      "default": "(set when constructed)",
      "labels": ["Data"],
      "type": "string (URL of CSV or CSV), GViz DataTable or 2D Array",
      "description": "Sets the data being displayed in the chart. This can only be set when calling updateOptions; it cannot be set from the constructor. For a full description of valid data formats, see the <a href='http://dygraphs.com/data.html'>Data Formats</a> page."
    },
    "timingName": {
      "default": "null",
      "labels": ["Debugging"],
      "type": "string",
      "description": "Set this option to log timing information. The value of the option will be logged along with the timimg, so that you can distinguish multiple dygraphs on the same page."
    },
    "showRangeSelector": {
      "default": "false",
      "labels": ["Range Selector"],
      "type": "boolean",
      "description": "Show or hide the range selector widget."
    },
    "rangeSelectorHeight": {
      "default": "40",
      "labels": ["Range Selector"],
      "type": "integer",
      "description": "Height, in pixels, of the range selector widget. This option can only be specified at Dygraph creation time."
    },
    "rangeSelectorPlotStrokeColor": {
      "default": "#808FAB",
      "labels": ["Range Selector"],
      "type": "string",
      "description": "The range selector mini plot stroke color. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\". You can also specify null or \"\" to turn off stroke."
    },
    "rangeSelectorPlotFillColor": {
      "default": "#A7B1C4",
      "labels": ["Range Selector"],
      "type": "string",
      "description": "The range selector mini plot fill color. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\". You can also specify null or \"\" to turn off fill."
    },
    "rangeSelectorPlotFillGradientColor": {
      "default": "white",
      "labels": ["Range Selector"],
      "type": "string",
      "description": "The top color for the range selector mini plot fill color gradient. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"rgba(255,100,200,42)\" or \"yellow\". You can also specify null or \"\" to disable the gradient and fill with one single color."
    },
    "rangeSelectorBackgroundStrokeColor": {
      "default": "gray",
      "labels": ["Range Selector"],
      "type": "string",
      "description": "The color of the lines below and on both sides of the range selector mini plot. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\"."
    },
    "rangeSelectorBackgroundLineWidth": {
      "default": "1",
      "labels": ["Range Selector"],
      "type": "float",
      "description": "The width of the lines below and on both sides of the range selector mini plot."
    },
    "rangeSelectorPlotLineWidth": {
      "default": "1.5",
      "labels": ["Range Selector"],
      "type": "float",
      "description": "The width of the range selector mini plot line."
    },
    "rangeSelectorForegroundStrokeColor": {
      "default": "black",
      "labels": ["Range Selector"],
      "type": "string",
      "description": "The color of the lines in the interactive layer of the range selector. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\"."
    },
    "rangeSelectorForegroundLineWidth": {
      "default": "1",
      "labels": ["Range Selector"],
      "type": "float",
      "description": "The width the lines in the interactive layer of the range selector."
    },
    "rangeSelectorAlpha": {
      "default": "0.6",
      "labels": ["Range Selector"],
      "type": "float (0.0 - 1.0)",
      "description": "The transparency of the veil that is drawn over the unselected portions of the range selector mini plot. A value of 0 represents full transparency and the unselected portions of the mini plot will appear as normal. A value of 1 represents full opacity and the unselected portions of the mini plot will be hidden."
    },
    "showInRangeSelector": {
      "default": "null",
      "labels": ["Range Selector"],
      "type": "boolean",
      "description": "Mark this series for inclusion in the range selector. The mini plot curve will be an average of all such series. If this is not specified for any series, the default behavior is to average all the series. Setting it for one series will result in that series being charted alone in the range selector."
    },
    "animatedZooms": {
      "default": "false",
      "labels": ["Interactive Elements"],
      "type": "boolean",
      "description": "Set this option to animate the transition between zoom windows. Applies to programmatic and interactive zooms. Note that if you also set a drawCallback, it will be called several times on each zoom. If you set a zoomCallback, it will only be called after the animation is complete."
    },
    "plotter": {
      "default": "[DygraphCanvasRenderer.Plotters.fillPlotter, DygraphCanvasRenderer.Plotters.errorPlotter, DygraphCanvasRenderer.Plotters.linePlotter]",
      "labels": ["Data Line display"],
      "type": "array or function",
      "description": "A function (or array of functions) which plot each data series on the chart. TODO(danvk): more details! May be set per-series."
    },
    "axes": {
      "default": "null",
      "labels": ["Configuration"],
      "type": "Object",
      "description": "Defines per-axis options. Valid keys are 'x', 'y' and 'y2'. Only some options may be set on a per-axis basis. If an option may be set in this way, it will be noted on this page. See also documentation on <a href='http://dygraphs.com/per-axis.html'>per-series and per-axis options</a>."
    },
    "series": {
      "default": "null",
      "labels": ["Series"],
      "type": "Object",
      "description": "Defines per-series options. Its keys match the y-axis label names, and the values are dictionaries themselves that contain options specific to that series."
    },
    "plugins": {
      "default": "[]",
      "labels": ["Configuration"],
      "type": "Array<plugin>",
      "description": "Defines per-graph plugins. Useful for per-graph customization"
    },
    "dataHandler": {
      "default": "(depends on data)",
      "labels": ["Data"],
      "type": "Dygraph.DataHandler",
      "description": "Custom DataHandler. This is an advanced customization. See http://bit.ly/151E7Aq."
    }
  }; // </JSON>
  // NOTE: in addition to parsing as JS, this snippet is expected to be valid
  // JSON. This assumption cannot be checked in JS, but it will be checked when
  // documentation is generated by the generate-documentation.py script. For the
  // most part, this just means that you should always use double quotes.

  // Do a quick sanity check on the options reference.
  var warn = function warn(msg) {
    if (window.console) window.console.warn(msg);
  };
  var flds = ['type', 'default', 'description'];
  var valid_cats = ['Annotations', 'Axis display', 'Chart labels', 'CSV parsing', 'Callbacks', 'Data', 'Data Line display', 'Data Series Colors', 'Error Bars', 'Grid', 'Interactive Elements', 'Range Selector', 'Legend', 'Overall display', 'Rolling Averages', 'Series', 'Value display/formatting', 'Zooming', 'Debugging', 'Configuration', 'Deprecated'];
  var i;
  var cats = {};
  for (i = 0; i < valid_cats.length; i++) cats[valid_cats[i]] = true;

  for (var k in OPTIONS_REFERENCE) {
    if (!OPTIONS_REFERENCE.hasOwnProperty(k)) continue;
    var op = OPTIONS_REFERENCE[k];
    for (i = 0; i < flds.length; i++) {
      if (!op.hasOwnProperty(flds[i])) {
        warn('Option ' + k + ' missing "' + flds[i] + '" property');
      } else if (typeof op[flds[i]] != 'string') {
        warn(k + '.' + flds[i] + ' must be of type string');
      }
    }
    var labels = op.labels;
    if (typeof labels !== 'object') {
      warn('Option "' + k + '" is missing a "labels": [...] option');
    } else {
      for (i = 0; i < labels.length; i++) {
        if (!cats.hasOwnProperty(labels[i])) {
          warn('Option "' + k + '" has label "' + labels[i] + '", which is invalid.');
        }
      }
    }
  }
}

exports["default"] = OPTIONS_REFERENCE;
module.exports = exports["default"];

},{}],14:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview DygraphOptions is responsible for parsing and returning
 * information about options.
 */

// TODO: remove this jshint directive & fix the warnings.
/*jshint sub:true */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraphDefaultAttrs = require('./dygraph-default-attrs');

var _dygraphDefaultAttrs2 = _interopRequireDefault(_dygraphDefaultAttrs);

var _dygraphOptionsReference = require('./dygraph-options-reference');

var _dygraphOptionsReference2 = _interopRequireDefault(_dygraphOptionsReference);

/*
 * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)
 * global_ - global attributes (common among all graphs, AIUI)
 * user - attributes set by the user
 * series_ - { seriesName -> { idx, yAxis, options }}
 */

/**
 * This parses attributes into an object that can be easily queried.
 *
 * It doesn't necessarily mean that all options are available, specifically
 * if labels are not yet available, since those drive details of the per-series
 * and per-axis options.
 *
 * @param {Dygraph} dygraph The chart to which these options belong.
 * @constructor
 */
var DygraphOptions = function DygraphOptions(dygraph) {
  /**
   * The dygraph.
   * @type {!Dygraph}
   */
  this.dygraph_ = dygraph;

  /**
   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }
   * @type {Array.<{series : Array.<string>, options : Object}>} @private
   */
  this.yAxes_ = [];

  /**
   * Contains x-axis specific options, which are stored in the options key.
   * This matches the yAxes_ object structure (by being a dictionary with an
   * options element) allowing for shared code.
   * @type {options: Object} @private
   */
  this.xAxis_ = {};
  this.series_ = {};

  // Once these two objects are initialized, you can call get();
  this.global_ = this.dygraph_.attrs_;
  this.user_ = this.dygraph_.user_attrs_ || {};

  /**
   * A list of series in columnar order.
   * @type {Array.<string>}
   */
  this.labels_ = [];

  this.highlightSeries_ = this.get("highlightSeriesOpts") || {};
  this.reparseSeries();
};

/**
 * Not optimal, but does the trick when you're only using two axes.
 * If we move to more axes, this can just become a function.
 *
 * @type {Object.<number>}
 * @private
 */
DygraphOptions.AXIS_STRING_MAPPINGS_ = {
  'y': 0,
  'Y': 0,
  'y1': 0,
  'Y1': 0,
  'y2': 1,
  'Y2': 1
};

/**
 * @param {string|number} axis
 * @private
 */
DygraphOptions.axisToIndex_ = function (axis) {
  if (typeof axis == "string") {
    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {
      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];
    }
    throw "Unknown axis : " + axis;
  }
  if (typeof axis == "number") {
    if (axis === 0 || axis === 1) {
      return axis;
    }
    throw "Dygraphs only supports two y-axes, indexed from 0-1.";
  }
  if (axis) {
    throw "Unknown axis : " + axis;
  }
  // No axis specification means axis 0.
  return 0;
};

/**
 * Reparses options that are all related to series. This typically occurs when
 * options are either updated, or source data has been made available.
 *
 * TODO(konigsberg): The method name is kind of weak; fix.
 */
DygraphOptions.prototype.reparseSeries = function () {
  var labels = this.get("labels");
  if (!labels) {
    return; // -- can't do more for now, will parse after getting the labels.
  }

  this.labels_ = labels.slice(1);

  this.yAxes_ = [{ series: [], options: {} }]; // Always one axis at least.
  this.xAxis_ = { options: {} };
  this.series_ = {};

  // Series are specified in the series element:
  //
  // {
  //   labels: [ "X", "foo", "bar" ],
  //   pointSize: 3,
  //   series : {
  //     foo : {}, // options for foo
  //     bar : {} // options for bar
  //   }
  // }
  //
  // So, if series is found, it's expected to contain per-series data, otherwise set a
  // default.
  var seriesDict = this.user_.series || {};
  for (var idx = 0; idx < this.labels_.length; idx++) {
    var seriesName = this.labels_[idx];
    var optionsForSeries = seriesDict[seriesName] || {};
    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries["axis"]);

    this.series_[seriesName] = {
      idx: idx,
      yAxis: yAxis,
      options: optionsForSeries };

    if (!this.yAxes_[yAxis]) {
      this.yAxes_[yAxis] = { series: [seriesName], options: {} };
    } else {
      this.yAxes_[yAxis].series.push(seriesName);
    }
  }

  var axis_opts = this.user_["axes"] || {};
  utils.update(this.yAxes_[0].options, axis_opts["y"] || {});
  if (this.yAxes_.length > 1) {
    utils.update(this.yAxes_[1].options, axis_opts["y2"] || {});
  }
  utils.update(this.xAxis_.options, axis_opts["x"] || {});

  // For "production" code, this gets removed by uglifyjs.
  if ("development" != 'production') {
    this.validateOptions_();
  }
};

/**
 * Get a global value.
 *
 * @param {string} name the name of the option.
 */
DygraphOptions.prototype.get = function (name) {
  var result = this.getGlobalUser_(name);
  if (result !== null) {
    return result;
  }
  return this.getGlobalDefault_(name);
};

DygraphOptions.prototype.getGlobalUser_ = function (name) {
  if (this.user_.hasOwnProperty(name)) {
    return this.user_[name];
  }
  return null;
};

DygraphOptions.prototype.getGlobalDefault_ = function (name) {
  if (this.global_.hasOwnProperty(name)) {
    return this.global_[name];
  }
  if (_dygraphDefaultAttrs2['default'].hasOwnProperty(name)) {
    return _dygraphDefaultAttrs2['default'][name];
  }
  return null;
};

/**
 * Get a value for a specific axis. If there is no specific value for the axis,
 * the global value is returned.
 *
 * @param {string} name the name of the option.
 * @param {string|number} axis the axis to search. Can be the string representation
 * ("y", "y2") or the axis number (0, 1).
 */
DygraphOptions.prototype.getForAxis = function (name, axis) {
  var axisIdx;
  var axisString;

  // Since axis can be a number or a string, straighten everything out here.
  if (typeof axis == 'number') {
    axisIdx = axis;
    axisString = axisIdx === 0 ? "y" : "y2";
  } else {
    if (axis == "y1") {
      axis = "y";
    } // Standardize on 'y'. Is this bad? I think so.
    if (axis == "y") {
      axisIdx = 0;
    } else if (axis == "y2") {
      axisIdx = 1;
    } else if (axis == "x") {
      axisIdx = -1; // simply a placeholder for below.
    } else {
        throw "Unknown axis " + axis;
      }
    axisString = axis;
  }

  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];

  // Search the user-specified axis option first.
  if (userAxis) {
    // This condition could be removed if we always set up this.yAxes_ for y2.
    var axisOptions = userAxis.options;
    if (axisOptions.hasOwnProperty(name)) {
      return axisOptions[name];
    }
  }

  // User-specified global options second.
  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.
  if (!(axis === 'x' && name === 'logscale')) {
    var result = this.getGlobalUser_(name);
    if (result !== null) {
      return result;
    }
  }
  // Default axis options third.
  var defaultAxisOptions = _dygraphDefaultAttrs2['default'].axes[axisString];
  if (defaultAxisOptions.hasOwnProperty(name)) {
    return defaultAxisOptions[name];
  }

  // Default global options last.
  return this.getGlobalDefault_(name);
};

/**
 * Get a value for a specific series. If there is no specific value for the series,
 * the value for the axis is returned (and afterwards, the global value.)
 *
 * @param {string} name the name of the option.
 * @param {string} series the series to search.
 */
DygraphOptions.prototype.getForSeries = function (name, series) {
  // Honors indexes as series.
  if (series === this.dygraph_.getHighlightSeries()) {
    if (this.highlightSeries_.hasOwnProperty(name)) {
      return this.highlightSeries_[name];
    }
  }

  if (!this.series_.hasOwnProperty(series)) {
    throw "Unknown series: " + series;
  }

  var seriesObj = this.series_[series];
  var seriesOptions = seriesObj["options"];
  if (seriesOptions.hasOwnProperty(name)) {
    return seriesOptions[name];
  }

  return this.getForAxis(name, seriesObj["yAxis"]);
};

/**
 * Returns the number of y-axes on the chart.
 * @return {number} the number of axes.
 */
DygraphOptions.prototype.numAxes = function () {
  return this.yAxes_.length;
};

/**
 * Return the y-axis for a given series, specified by name.
 */
DygraphOptions.prototype.axisForSeries = function (series) {
  return this.series_[series].yAxis;
};

/**
 * Returns the options for the specified axis.
 */
// TODO(konigsberg): this is y-axis specific. Support the x axis.
DygraphOptions.prototype.axisOptions = function (yAxis) {
  return this.yAxes_[yAxis].options;
};

/**
 * Return the series associated with an axis.
 */
DygraphOptions.prototype.seriesForAxis = function (yAxis) {
  return this.yAxes_[yAxis].series;
};

/**
 * Return the list of all series, in their columnar order.
 */
DygraphOptions.prototype.seriesNames = function () {
  return this.labels_;
};

// For "production" code, this gets removed by uglifyjs.
if ("development" != 'production') {

  /**
   * Validate all options.
   * This requires OPTIONS_REFERENCE, which is only available in debug builds.
   * @private
   */
  DygraphOptions.prototype.validateOptions_ = function () {
    if (typeof _dygraphOptionsReference2['default'] === 'undefined') {
      throw 'Called validateOptions_ in prod build.';
    }

    var that = this;
    var validateOption = function validateOption(optionName) {
      if (!_dygraphOptionsReference2['default'][optionName]) {
        that.warnInvalidOption_(optionName);
      }
    };

    var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];
    var names = this.seriesNames();
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (this.series_.hasOwnProperty(name)) {
        optionsDicts.push(this.series_[name].options);
      }
    }
    for (var i = 0; i < optionsDicts.length; i++) {
      var dict = optionsDicts[i];
      if (!dict) continue;
      for (var optionName in dict) {
        if (dict.hasOwnProperty(optionName)) {
          validateOption(optionName);
        }
      }
    }
  };

  var WARNINGS = {}; // Only show any particular warning once.

  /**
   * Logs a warning about invalid options.
   * TODO: make this throw for testing
   * @private
   */
  DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {
    if (!WARNINGS[optionName]) {
      WARNINGS[optionName] = true;
      var isSeries = this.labels_.indexOf(optionName) >= 0;
      if (isSeries) {
        console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');
      } else {
        console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');
        throw "invalid option " + optionName;
      }
    }
  };

  // Reset list of previously-shown warnings. Used for testing.
  DygraphOptions.resetWarnings_ = function () {
    WARNINGS = {};
  };
}

exports['default'] = DygraphOptions;
module.exports = exports['default'];

},{"./dygraph-default-attrs":9,"./dygraph-options-reference":13,"./dygraph-utils":16}],15:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview Description of this file.
 * @author danvk@google.com (Dan Vanderkam)
 *
 * A ticker is a function with the following interface:
 *
 * function(a, b, pixels, options_view, dygraph, forced_values);
 * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },
 *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },
 *      ...
 *    ]
 *
 * The returned value is called a "tick list".
 *
 * Arguments
 * ---------
 *
 * [a, b] is the range of the axis for which ticks are being generated. For a
 * numeric axis, these will simply be numbers. For a date axis, these will be
 * millis since epoch (convertable to Date objects using "new Date(a)" and "new
 * Date(b)").
 *
 * opts provides access to chart- and axis-specific options. It can be used to
 * access number/date formatting code/options, check for a log scale, etc.
 *
 * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the
 * minimum amount of space to be allotted to each label. For instance, if
 * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return
 * between zero and ten (400/40) ticks.
 *
 * dygraph is the Dygraph object for which an axis is being constructed.
 *
 * forced_values is used for secondary y-axes. The tick positions are typically
 * set by the primary y-axis, so the secondary y-axis has no choice in where to
 * put these. It simply has to generate labels for these data values.
 *
 * Tick lists
 * ----------
 * Typically a tick will have both a grid/tick line and a label at one end of
 * that line (at the bottom for an x-axis, at left or right for the y-axis).
 *
 * A tick may be missing one of these two components:
 * - If "label_v" is specified instead of "v", then there will be no tick or
 *   gridline, just a label.
 * - Similarly, if "label" is not specified, then there will be a gridline
 *   without a label.
 *
 * This flexibility is useful in a few situations:
 * - For log scales, some of the tick lines may be too close to all have labels.
 * - For date scales where years are being displayed, it is desirable to display
 *   tick marks at the beginnings of years but labels (e.g. "2006") in the
 *   middle of the years.
 */

/*jshint sub:true */
/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */
var TickList = undefined; // the ' = undefined' keeps jshint happy.

/** @typedef {function(
 *    number,
 *    number,
 *    number,
 *    function(string):*,
 *    Dygraph=,
 *    Array.<number>=
 *  ): TickList}
 */
var Ticker = undefined; // the ' = undefined' keeps jshint happy.

/** @type {Ticker} */
var numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {
  var nonLogscaleOpts = function nonLogscaleOpts(opt) {
    if (opt === 'logscale') return false;
    return opts(opt);
  };
  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);
};

exports.numericLinearTicks = numericLinearTicks;
/** @type {Ticker} */
var numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {
  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
  var ticks = [];
  var i, j, tickV, nTicks;
  if (vals) {
    for (i = 0; i < vals.length; i++) {
      ticks.push({ v: vals[i] });
    }
  } else {
    // TODO(danvk): factor this log-scale block out into a separate function.
    if (opts("logscale")) {
      nTicks = Math.floor(pixels / pixels_per_tick);
      var minIdx = utils.binarySearch(a, PREFERRED_LOG_TICK_VALUES, 1);
      var maxIdx = utils.binarySearch(b, PREFERRED_LOG_TICK_VALUES, -1);
      if (minIdx == -1) {
        minIdx = 0;
      }
      if (maxIdx == -1) {
        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;
      }
      // Count the number of tick values would appear, if we can get at least
      // nTicks / 4 accept them.
      var lastDisplayed = null;
      if (maxIdx - minIdx >= nTicks / 4) {
        for (var idx = maxIdx; idx >= minIdx; idx--) {
          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];
          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;
          var tick = { v: tickValue };
          if (lastDisplayed === null) {
            lastDisplayed = {
              tickValue: tickValue,
              pixel_coord: pixel_coord
            };
          } else {
            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {
              lastDisplayed = {
                tickValue: tickValue,
                pixel_coord: pixel_coord
              };
            } else {
              tick.label = "";
            }
          }
          ticks.push(tick);
        }
        // Since we went in backwards order.
        ticks.reverse();
      }
    }

    // ticks.length won't be 0 if the log scale function finds values to insert.
    if (ticks.length === 0) {
      // Basic idea:
      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.
      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).
      // The first spacing greater than pixelsPerYLabel is what we use.
      // TODO(danvk): version that works on a log scale.
      var kmg2 = opts("labelsKMG2");
      var mults, base;
      if (kmg2) {
        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];
        base = 16;
      } else {
        mults = [1, 2, 5, 10, 20, 50, 100];
        base = 10;
      }

      // Get the maximum number of permitted ticks based on the
      // graph's pixel size and pixels_per_tick setting.
      var max_ticks = Math.ceil(pixels / pixels_per_tick);

      // Now calculate the data unit equivalent of this tick spacing.
      // Use abs() since graphs may have a reversed Y axis.
      var units_per_tick = Math.abs(b - a) / max_ticks;

      // Based on this, get a starting scale which is the largest
      // integer power of the chosen base (10 or 16) that still remains
      // below the requested pixels_per_tick spacing.
      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));
      var base_scale = Math.pow(base, base_power);

      // Now try multiples of the starting scale until we find one
      // that results in tick marks spaced sufficiently far apart.
      // The "mults" array should cover the range 1 .. base^2 to
      // adjust for rounding and edge effects.
      var scale, low_val, high_val, spacing;
      for (j = 0; j < mults.length; j++) {
        scale = base_scale * mults[j];
        low_val = Math.floor(a / scale) * scale;
        high_val = Math.ceil(b / scale) * scale;
        nTicks = Math.abs(high_val - low_val) / scale;
        spacing = pixels / nTicks;
        if (spacing > pixels_per_tick) break;
      }

      // Construct the set of ticks.
      // Allow reverse y-axis if it's explicitly requested.
      if (low_val > high_val) scale *= -1;
      for (i = 0; i <= nTicks; i++) {
        tickV = low_val + i * scale;
        ticks.push({ v: tickV });
      }
    }
  }

  var formatter = /**@type{AxisLabelFormatter}*/opts('axisLabelFormatter');

  // Add labels to the ticks.
  for (i = 0; i < ticks.length; i++) {
    if (ticks[i].label !== undefined) continue; // Use current label.
    // TODO(danvk): set granularity to something appropriate here.
    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);
  }

  return ticks;
};

exports.numericTicks = numericTicks;
/** @type {Ticker} */
var dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {
  var chosen = pickDateTickGranularity(a, b, pixels, opts);

  if (chosen >= 0) {
    return getDateAxis(a, b, chosen, opts, dygraph);
  } else {
    // this can happen if self.width_ is zero.
    return [];
  }
};

exports.dateTicker = dateTicker;
// Time granularity enumeration
var Granularity = {
  SECONDLY: 0,
  TWO_SECONDLY: 1,
  FIVE_SECONDLY: 2,
  TEN_SECONDLY: 3,
  THIRTY_SECONDLY: 4,
  MINUTELY: 5,
  TWO_MINUTELY: 6,
  FIVE_MINUTELY: 7,
  TEN_MINUTELY: 8,
  THIRTY_MINUTELY: 9,
  HOURLY: 10,
  TWO_HOURLY: 11,
  SIX_HOURLY: 12,
  DAILY: 13,
  TWO_DAILY: 14,
  WEEKLY: 15,
  MONTHLY: 16,
  QUARTERLY: 17,
  BIANNUAL: 18,
  ANNUAL: 19,
  DECADAL: 20,
  CENTENNIAL: 21,
  NUM_GRANULARITIES: 22
};

exports.Granularity = Granularity;
// Date components enumeration (in the order of the arguments in Date)
// TODO: make this an @enum
var DateField = {
  DATEFIELD_Y: 0,
  DATEFIELD_M: 1,
  DATEFIELD_D: 2,
  DATEFIELD_HH: 3,
  DATEFIELD_MM: 4,
  DATEFIELD_SS: 5,
  DATEFIELD_MS: 6,
  NUM_DATEFIELDS: 7
};

/**
 * The value of datefield will start at an even multiple of "step", i.e.
 *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.
 *
 * For granularities <= HOURLY, ticks are generated every `spacing` ms.
 *
 * At coarser granularities, ticks are generated by incrementing `datefield` by
 *   `step`. In this case, the `spacing` value is only used to estimate the
 *   number of ticks. It should roughly correspond to the spacing between
 *   adjacent ticks.
 *
 * @type {Array.<{datefield:number, step:number, spacing:number}>}
 */
var TICK_PLACEMENT = [];
TICK_PLACEMENT[Granularity.SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 1, spacing: 1000 * 1 };
TICK_PLACEMENT[Granularity.TWO_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 2, spacing: 1000 * 2 };
TICK_PLACEMENT[Granularity.FIVE_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 5, spacing: 1000 * 5 };
TICK_PLACEMENT[Granularity.TEN_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 10, spacing: 1000 * 10 };
TICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 30, spacing: 1000 * 30 };
TICK_PLACEMENT[Granularity.MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 1, spacing: 1000 * 60 };
TICK_PLACEMENT[Granularity.TWO_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 2, spacing: 1000 * 60 * 2 };
TICK_PLACEMENT[Granularity.FIVE_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 5, spacing: 1000 * 60 * 5 };
TICK_PLACEMENT[Granularity.TEN_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 10, spacing: 1000 * 60 * 10 };
TICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 30, spacing: 1000 * 60 * 30 };
TICK_PLACEMENT[Granularity.HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 1, spacing: 1000 * 3600 };
TICK_PLACEMENT[Granularity.TWO_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 2, spacing: 1000 * 3600 * 2 };
TICK_PLACEMENT[Granularity.SIX_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 6, spacing: 1000 * 3600 * 6 };
TICK_PLACEMENT[Granularity.DAILY] = { datefield: DateField.DATEFIELD_D, step: 1, spacing: 1000 * 86400 };
TICK_PLACEMENT[Granularity.TWO_DAILY] = { datefield: DateField.DATEFIELD_D, step: 2, spacing: 1000 * 86400 * 2 };
TICK_PLACEMENT[Granularity.WEEKLY] = { datefield: DateField.DATEFIELD_D, step: 7, spacing: 1000 * 604800 };
TICK_PLACEMENT[Granularity.MONTHLY] = { datefield: DateField.DATEFIELD_M, step: 1, spacing: 1000 * 7200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 12
TICK_PLACEMENT[Granularity.QUARTERLY] = { datefield: DateField.DATEFIELD_M, step: 3, spacing: 1000 * 21600 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 4
TICK_PLACEMENT[Granularity.BIANNUAL] = { datefield: DateField.DATEFIELD_M, step: 6, spacing: 1000 * 43200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 2
TICK_PLACEMENT[Granularity.ANNUAL] = { datefield: DateField.DATEFIELD_Y, step: 1, spacing: 1000 * 86400 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 1
TICK_PLACEMENT[Granularity.DECADAL] = { datefield: DateField.DATEFIELD_Y, step: 10, spacing: 1000 * 864000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 10
TICK_PLACEMENT[Granularity.CENTENNIAL] = { datefield: DateField.DATEFIELD_Y, step: 100, spacing: 1000 * 8640000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 100

/**
 * This is a list of human-friendly values at which to show tick marks on a log
 * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:
 * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...
 * NOTE: this assumes that utils.LOG_SCALE = 10.
 * @type {Array.<number>}
 */
var PREFERRED_LOG_TICK_VALUES = (function () {
  var vals = [];
  for (var power = -39; power <= 39; power++) {
    var range = Math.pow(10, power);
    for (var mult = 1; mult <= 9; mult++) {
      var val = range * mult;
      vals.push(val);
    }
  }
  return vals;
})();

/**
 * Determine the correct granularity of ticks on a date axis.
 *
 * @param {number} a Left edge of the chart (ms)
 * @param {number} b Right edge of the chart (ms)
 * @param {number} pixels Size of the chart in the relevant dimension (width).
 * @param {function(string):*} opts Function mapping from option name -&gt; value.
 * @return {number} The appropriate axis granularity for this chart. See the
 *     enumeration of possible values in dygraph-tickers.js.
 */
var pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {
  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {
    var num_ticks = numDateTicks(a, b, i);
    if (pixels / num_ticks >= pixels_per_tick) {
      return i;
    }
  }
  return -1;
};

/**
 * Compute the number of ticks on a date axis for a given granularity.
 * @param {number} start_time
 * @param {number} end_time
 * @param {number} granularity (one of the granularities enumerated above)
 * @return {number} (Approximate) number of ticks that would result.
 */
var numDateTicks = function numDateTicks(start_time, end_time, granularity) {
  var spacing = TICK_PLACEMENT[granularity].spacing;
  return Math.round(1.0 * (end_time - start_time) / spacing);
};

/**
 * Compute the positions and labels of ticks on a date axis for a given granularity.
 * @param {number} start_time
 * @param {number} end_time
 * @param {number} granularity (one of the granularities enumerated above)
 * @param {function(string):*} opts Function mapping from option name -&gt; value.
 * @param {Dygraph=} dg
 * @return {!TickList}
 */
var getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {
  var formatter = /** @type{AxisLabelFormatter} */opts("axisLabelFormatter");
  var utc = opts("labelsUTC");
  var accessors = utc ? utils.DateAccessorsUTC : utils.DateAccessorsLocal;

  var datefield = TICK_PLACEMENT[granularity].datefield;
  var step = TICK_PLACEMENT[granularity].step;
  var spacing = TICK_PLACEMENT[granularity].spacing;

  // Choose a nice tick position before the initial instant.
  // Currently, this code deals properly with the existent daily granularities:
  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).
  // Other daily granularities (say TWO_DAILY) should also be handled specially
  // by setting the start_date_offset to 0.
  var start_date = new Date(start_time);
  var date_array = [];
  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);
  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);
  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);
  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);
  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);
  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);
  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);

  var start_date_offset = date_array[datefield] % step;
  if (granularity == Granularity.WEEKLY) {
    // This will put the ticks on Sundays.
    start_date_offset = accessors.getDay(start_date);
  }

  date_array[datefield] -= start_date_offset;
  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {
    // The minimum value is 1 for the day of month, and 0 for all other fields.
    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;
  }

  // Generate the ticks.
  // For granularities not coarser than HOURLY we use the fact that:
  //   the number of milliseconds between ticks is constant
  //   and equal to the defined spacing.
  // Otherwise we rely on the 'roll over' property of the Date functions:
  //   when some date field is set to a value outside of its logical range,
  //   the excess 'rolls over' the next (more significant) field.
  // However, when using local time with DST transitions,
  // there are dates that do not represent any time value at all
  // (those in the hour skipped at the 'spring forward'),
  // and the JavaScript engines usually return an equivalent value.
  // Hence we have to check that the date is properly increased at each step,
  // returning a date at a nice tick position.
  var ticks = [];
  var tick_date = accessors.makeDate.apply(null, date_array);
  var tick_time = tick_date.getTime();
  if (granularity <= Granularity.HOURLY) {
    if (tick_time < start_time) {
      tick_time += spacing;
      tick_date = new Date(tick_time);
    }
    while (tick_time <= end_time) {
      ticks.push({ v: tick_time,
        label: formatter.call(dg, tick_date, granularity, opts, dg)
      });
      tick_time += spacing;
      tick_date = new Date(tick_time);
    }
  } else {
    if (tick_time < start_time) {
      date_array[datefield] += step;
      tick_date = accessors.makeDate.apply(null, date_array);
      tick_time = tick_date.getTime();
    }
    while (tick_time <= end_time) {
      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {
        ticks.push({ v: tick_time,
          label: formatter.call(dg, tick_date, granularity, opts, dg)
        });
      }
      date_array[datefield] += step;
      tick_date = accessors.makeDate.apply(null, date_array);
      tick_time = tick_date.getTime();
    }
  }
  return ticks;
};
exports.getDateAxis = getDateAxis;

},{"./dygraph-utils":16}],16:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/**
 * @fileoverview This file contains utility functions used by dygraphs. These
 * are typically static (i.e. not related to any particular dygraph). Examples
 * include date/time formatting functions, basic algorithms (e.g. binary
 * search) and generic DOM-manipulation functions.
 */

/*global Dygraph:false, Node:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeEvent = removeEvent;
exports.cancelEvent = cancelEvent;
exports.hsvToRGB = hsvToRGB;
exports.findPos = findPos;
exports.pageX = pageX;
exports.pageY = pageY;
exports.dragGetX_ = dragGetX_;
exports.dragGetY_ = dragGetY_;
exports.isOK = isOK;
exports.isValidPoint = isValidPoint;
exports.floatFormat = floatFormat;
exports.zeropad = zeropad;
exports.hmsString_ = hmsString_;
exports.dateString_ = dateString_;
exports.round_ = round_;
exports.binarySearch = binarySearch;
exports.dateParser = dateParser;
exports.dateStrToMillis = dateStrToMillis;
exports.update = update;
exports.updateDeep = updateDeep;
exports.isArrayLike = isArrayLike;
exports.isDateLike = isDateLike;
exports.clone = clone;
exports.createCanvas = createCanvas;
exports.getContextPixelRatio = getContextPixelRatio;
exports.isAndroid = isAndroid;
exports.Iterator = Iterator;
exports.createIterator = createIterator;
exports.repeatAndCleanup = repeatAndCleanup;
exports.isPixelChangingOptionList = isPixelChangingOptionList;
exports.detectLineDelimiter = detectLineDelimiter;
exports.isNodeContainedBy = isNodeContainedBy;
exports.pow = pow;
exports.toRGB_ = toRGB_;
exports.isCanvasSupported = isCanvasSupported;
exports.parseFloat_ = parseFloat_;
exports.numberValueFormatter = numberValueFormatter;
exports.numberAxisLabelFormatter = numberAxisLabelFormatter;
exports.dateAxisLabelFormatter = dateAxisLabelFormatter;
exports.dateValueFormatter = dateValueFormatter;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphTickers = require('./dygraph-tickers');

var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

var LOG_SCALE = 10;
exports.LOG_SCALE = LOG_SCALE;
var LN_TEN = Math.log(LOG_SCALE);

exports.LN_TEN = LN_TEN;
/**
 * @private
 * @param {number} x
 * @return {number}
 */
var log10 = function log10(x) {
  return Math.log(x) / LN_TEN;
};

exports.log10 = log10;
/**
 * @private
 * @param {number} r0
 * @param {number} r1
 * @param {number} pct
 * @return {number}
 */
var logRangeFraction = function logRangeFraction(r0, r1, pct) {
  // Computing the inverse of toPercentXCoord. The function was arrived at with
  // the following steps:
  //
  // Original calcuation:
  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));
  //
  // Multiply both sides by the right-side demoninator.
  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])
  //
  // add log(xRange[0]) to both sides
  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);
  //
  // Swap both sides of the equation,
  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))
  //
  // Use both sides as the exponent in 10^exp and we're done.
  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))

  var logr0 = log10(r0);
  var logr1 = log10(r1);
  var exponent = logr0 + pct * (logr1 - logr0);
  var value = Math.pow(LOG_SCALE, exponent);
  return value;
};

exports.logRangeFraction = logRangeFraction;
/** A dotted line stroke pattern. */
var DOTTED_LINE = [2, 2];
exports.DOTTED_LINE = DOTTED_LINE;
/** A dashed line stroke pattern. */
var DASHED_LINE = [7, 3];
exports.DASHED_LINE = DASHED_LINE;
/** A dot dash stroke pattern. */
var DOT_DASH_LINE = [7, 2, 2, 2];

exports.DOT_DASH_LINE = DOT_DASH_LINE;
// Directions for panning and zooming. Use bit operations when combined
// values are possible.
var HORIZONTAL = 1;
exports.HORIZONTAL = HORIZONTAL;
var VERTICAL = 2;

exports.VERTICAL = VERTICAL;
/**
 * Return the 2d context for a dygraph canvas.
 *
 * This method is only exposed for the sake of replacing the function in
 * automated tests.
 *
 * @param {!HTMLCanvasElement} canvas
 * @return {!CanvasRenderingContext2D}
 * @private
 */
var getContext = function getContext(canvas) {
  return (/** @type{!CanvasRenderingContext2D}*/canvas.getContext("2d")
  );
};

exports.getContext = getContext;
/**
 * Add an event handler.
 * @param {!Node} elem The element to add the event to.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 * @private
 */
var addEvent = function addEvent(elem, type, fn) {
  elem.addEventListener(type, fn, false);
};

exports.addEvent = addEvent;
/**
 * Remove an event handler.
 * @param {!Node} elem The element to remove the event from.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 */

function removeEvent(elem, type, fn) {
  elem.removeEventListener(type, fn, false);
}

;

/**
 * Cancels further processing of an event. This is useful to prevent default
 * browser actions, e.g. highlighting text on a double-click.
 * Based on the article at
 * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel
 * @param {!Event} e The event whose normal behavior should be canceled.
 * @private
 */

function cancelEvent(e) {
  e = e ? e : window.event;
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.cancelBubble = true;
  e.cancel = true;
  e.returnValue = false;
  return false;
}

;

/**
 * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This
 * is used to generate default series colors which are evenly spaced on the
 * color wheel.
 * @param { number } hue Range is 0.0-1.0.
 * @param { number } saturation Range is 0.0-1.0.
 * @param { number } value Range is 0.0-1.0.
 * @return { string } "rgb(r,g,b)" where r, g and b range from 0-255.
 * @private
 */

function hsvToRGB(hue, saturation, value) {
  var red;
  var green;
  var blue;
  if (saturation === 0) {
    red = value;
    green = value;
    blue = value;
  } else {
    var i = Math.floor(hue * 6);
    var f = hue * 6 - i;
    var p = value * (1 - saturation);
    var q = value * (1 - saturation * f);
    var t = value * (1 - saturation * (1 - f));
    switch (i) {
      case 1:
        red = q;green = value;blue = p;break;
      case 2:
        red = p;green = value;blue = t;break;
      case 3:
        red = p;green = q;blue = value;break;
      case 4:
        red = t;green = p;blue = value;break;
      case 5:
        red = value;green = p;blue = q;break;
      case 6: // fall through
      case 0:
        red = value;green = t;blue = p;break;
    }
  }
  red = Math.floor(255 * red + 0.5);
  green = Math.floor(255 * green + 0.5);
  blue = Math.floor(255 * blue + 0.5);
  return 'rgb(' + red + ',' + green + ',' + blue + ')';
}

;

/**
 * Find the coordinates of an object relative to the top left of the page.
 *
 * @param {Node} obj
 * @return {{x:number,y:number}}
 * @private
 */

function findPos(obj) {
  var p = obj.getBoundingClientRect(),
      w = window,
      d = document.documentElement;

  return {
    x: p.left + (w.pageXOffset || d.scrollLeft),
    y: p.top + (w.pageYOffset || d.scrollTop)
  };
}

;

/**
 * Returns the x-coordinate of the event in a coordinate system where the
 * top-left corner of the page (not the window) is (0,0).
 * Taken from MochiKit.Signal
 * @param {!Event} e
 * @return {number}
 * @private
 */

function pageX(e) {
  return !e.pageX || e.pageX < 0 ? 0 : e.pageX;
}

;

/**
 * Returns the y-coordinate of the event in a coordinate system where the
 * top-left corner of the page (not the window) is (0,0).
 * Taken from MochiKit.Signal
 * @param {!Event} e
 * @return {number}
 * @private
 */

function pageY(e) {
  return !e.pageY || e.pageY < 0 ? 0 : e.pageY;
}

;

/**
 * Converts page the x-coordinate of the event to pixel x-coordinates on the
 * canvas (i.e. DOM Coords).
 * @param {!Event} e Drag event.
 * @param {!DygraphInteractionContext} context Interaction context object.
 * @return {number} The amount by which the drag has moved to the right.
 */

function dragGetX_(e, context) {
  return pageX(e) - context.px;
}

;

/**
 * Converts page the y-coordinate of the event to pixel y-coordinates on the
 * canvas (i.e. DOM Coords).
 * @param {!Event} e Drag event.
 * @param {!DygraphInteractionContext} context Interaction context object.
 * @return {number} The amount by which the drag has moved down.
 */

function dragGetY_(e, context) {
  return pageY(e) - context.py;
}

;

/**
 * This returns true unless the parameter is 0, null, undefined or NaN.
 * TODO(danvk): rename this function to something like 'isNonZeroNan'.
 *
 * @param {number} x The number to consider.
 * @return {boolean} Whether the number is zero or NaN.
 * @private
 */

function isOK(x) {
  return !!x && !isNaN(x);
}

;

/**
 * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid
 *     points are {x, y} objects
 * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid
 * @return {boolean} Whether the point has numeric x and y.
 * @private
 */

function isValidPoint(p, opt_allowNaNY) {
  if (!p) return false; // null or undefined object
  if (p.yval === null) return false; // missing point
  if (p.x === null || p.x === undefined) return false;
  if (p.y === null || p.y === undefined) return false;
  if (isNaN(p.x) || !opt_allowNaNY && isNaN(p.y)) return false;
  return true;
}

;

/**
 * Number formatting function which mimicks the behavior of %g in printf, i.e.
 * either exponential or fixed format (without trailing 0s) is used depending on
 * the length of the generated string.  The advantage of this format is that
 * there is a predictable upper bound on the resulting string length,
 * significant figures are not dropped, and normal numbers are not displayed in
 * exponential notation.
 *
 * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.
 * It creates strings which are too long for absolute values between 10^-4 and
 * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for
 * output examples.
 *
 * @param {number} x The number to format
 * @param {number=} opt_precision The precision to use, default 2.
 * @return {string} A string formatted like %g in printf.  The max generated
 *                  string length should be precision + 6 (e.g 1.123e+300).
 */

function floatFormat(x, opt_precision) {
  // Avoid invalid precision values; [1, 21] is the valid range.
  var p = Math.min(Math.max(1, opt_precision || 2), 21);

  // This is deceptively simple.  The actual algorithm comes from:
  //
  // Max allowed length = p + 4
  // where 4 comes from 'e+n' and '.'.
  //
  // Length of fixed format = 2 + y + p
  // where 2 comes from '0.' and y = # of leading zeroes.
  //
  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is
  // 1.0e-3.
  //
  // Since the behavior of toPrecision() is identical for larger numbers, we
  // don't have to worry about the other bound.
  //
  // Finally, the argument for toExponential() is the number of trailing digits,
  // so we take off 1 for the value before the '.'.
  return Math.abs(x) < 1.0e-3 && x !== 0.0 ? x.toExponential(p - 1) : x.toPrecision(p);
}

;

/**
 * Converts '9' to '09' (useful for dates)
 * @param {number} x
 * @return {string}
 * @private
 */

function zeropad(x) {
  if (x < 10) return "0" + x;else return "" + x;
}

;

/**
 * Date accessors to get the parts of a calendar date (year, month,
 * day, hour, minute, second and millisecond) according to local time,
 * and factory method to call the Date constructor with an array of arguments.
 */
var DateAccessorsLocal = {
  getFullYear: function getFullYear(d) {
    return d.getFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getMonth();
  },
  getDate: function getDate(d) {
    return d.getDate();
  },
  getHours: function getHours(d) {
    return d.getHours();
  },
  getMinutes: function getMinutes(d) {
    return d.getMinutes();
  },
  getSeconds: function getSeconds(d) {
    return d.getSeconds();
  },
  getMilliseconds: function getMilliseconds(d) {
    return d.getMilliseconds();
  },
  getDay: function getDay(d) {
    return d.getDay();
  },
  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
    return new Date(y, m, d, hh, mm, ss, ms);
  }
};

exports.DateAccessorsLocal = DateAccessorsLocal;
/**
 * Date accessors to get the parts of a calendar date (year, month,
 * day of month, hour, minute, second and millisecond) according to UTC time,
 * and factory method to call the Date constructor with an array of arguments.
 */
var DateAccessorsUTC = {
  getFullYear: function getFullYear(d) {
    return d.getUTCFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getUTCMonth();
  },
  getDate: function getDate(d) {
    return d.getUTCDate();
  },
  getHours: function getHours(d) {
    return d.getUTCHours();
  },
  getMinutes: function getMinutes(d) {
    return d.getUTCMinutes();
  },
  getSeconds: function getSeconds(d) {
    return d.getUTCSeconds();
  },
  getMilliseconds: function getMilliseconds(d) {
    return d.getUTCMilliseconds();
  },
  getDay: function getDay(d) {
    return d.getUTCDay();
  },
  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));
  }
};

exports.DateAccessorsUTC = DateAccessorsUTC;
/**
 * Return a string version of the hours, minutes and seconds portion of a date.
 * @param {number} hh The hours (from 0-23)
 * @param {number} mm The minutes (from 0-59)
 * @param {number} ss The seconds (from 0-59)
 * @return {string} A time of the form "HH:MM" or "HH:MM:SS"
 * @private
 */

function hmsString_(hh, mm, ss) {
  var ret = zeropad(hh) + ":" + zeropad(mm);
  if (ss) {
    ret += ":" + zeropad(ss);
  }
  return ret;
}

;

/**
 * Convert a JS date (millis since epoch) to a formatted string.
 * @param {number} time The JavaScript time value (ms since epoch)
 * @param {boolean} utc Wether output UTC or local time
 * @return {string} A date of one of these forms:
 *     "YYYY/MM/DD", "YYYY/MM/DD HH:MM" or "YYYY/MM/DD HH:MM:SS"
 * @private
 */

function dateString_(time, utc) {
  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;
  var date = new Date(time);
  var y = accessors.getFullYear(date);
  var m = accessors.getMonth(date);
  var d = accessors.getDate(date);
  var hh = accessors.getHours(date);
  var mm = accessors.getMinutes(date);
  var ss = accessors.getSeconds(date);
  // Get a year string:
  var year = "" + y;
  // Get a 0 padded month string
  var month = zeropad(m + 1); //months are 0-offset, sigh
  // Get a 0 padded day string
  var day = zeropad(d);
  var frac = hh * 3600 + mm * 60 + ss;
  var ret = year + "/" + month + "/" + day;
  if (frac) {
    ret += " " + hmsString_(hh, mm, ss);
  }
  return ret;
}

;

/**
 * Round a number to the specified number of digits past the decimal point.
 * @param {number} num The number to round
 * @param {number} places The number of decimals to which to round
 * @return {number} The rounded number
 * @private
 */

function round_(num, places) {
  var shift = Math.pow(10, places);
  return Math.round(num * shift) / shift;
}

;

/**
 * Implementation of binary search over an array.
 * Currently does not work when val is outside the range of arry's values.
 * @param {number} val the value to search for
 * @param {Array.<number>} arry is the value over which to search
 * @param {number} abs If abs > 0, find the lowest entry greater than val
 *     If abs < 0, find the highest entry less than val.
 *     If abs == 0, find the entry that equals val.
 * @param {number=} low The first index in arry to consider (optional)
 * @param {number=} high The last index in arry to consider (optional)
 * @return {number} Index of the element, or -1 if it isn't found.
 * @private
 */

function binarySearch(_x, _x2, _x3, _x4, _x5) {
  var _again = true;

  _function: while (_again) {
    var val = _x,
        arry = _x2,
        abs = _x3,
        low = _x4,
        high = _x5;
    _again = false;

    if (low === null || low === undefined || high === null || high === undefined) {
      low = 0;
      high = arry.length - 1;
    }
    if (low > high) {
      return -1;
    }
    if (abs === null || abs === undefined) {
      abs = 0;
    }
    var validIndex = function validIndex(idx) {
      return idx >= 0 && idx < arry.length;
    };
    var mid = parseInt((low + high) / 2, 10);
    var element = arry[mid];
    var idx;
    if (element == val) {
      return mid;
    } else if (element > val) {
      if (abs > 0) {
        // Accept if element > val, but also if prior element < val.
        idx = mid - 1;
        if (validIndex(idx) && arry[idx] < val) {
          return mid;
        }
      }
      _x = val;
      _x2 = arry;
      _x3 = abs;
      _x4 = low;
      _x5 = mid - 1;
      _again = true;
      validIndex = mid = element = idx = undefined;
      continue _function;
    } else if (element < val) {
      if (abs < 0) {
        // Accept if element < val, but also if prior element > val.
        idx = mid + 1;
        if (validIndex(idx) && arry[idx] > val) {
          return mid;
        }
      }
      _x = val;
      _x2 = arry;
      _x3 = abs;
      _x4 = mid + 1;
      _x5 = high;
      _again = true;
      validIndex = mid = element = idx = undefined;
      continue _function;
    }
    return -1; // can't actually happen, but makes closure compiler happy
  }
}

;

/**
 * Parses a date, returning the number of milliseconds since epoch. This can be
 * passed in as an xValueParser in the Dygraph constructor.
 * TODO(danvk): enumerate formats that this understands.
 *
 * @param {string} dateStr A date in a variety of possible string formats.
 * @return {number} Milliseconds since epoch.
 * @private
 */

function dateParser(dateStr) {
  var dateStrSlashed;
  var d;

  // Let the system try the format first, with one caveat:
  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.
  // dygraphs displays dates in local time, so this will result in surprising
  // inconsistencies. But if you specify "T" or "Z" (i.e. YYYY-MM-DDTHH:MM:SS),
  // then you probably know what you're doing, so we'll let you go ahead.
  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255
  if (dateStr.search("-") == -1 || dateStr.search("T") != -1 || dateStr.search("Z") != -1) {
    d = dateStrToMillis(dateStr);
    if (d && !isNaN(d)) return d;
  }

  if (dateStr.search("-") != -1) {
    // e.g. '2009-7-12' or '2009-07-12'
    dateStrSlashed = dateStr.replace("-", "/", "g");
    while (dateStrSlashed.search("-") != -1) {
      dateStrSlashed = dateStrSlashed.replace("-", "/");
    }
    d = dateStrToMillis(dateStrSlashed);
  } else if (dateStr.length == 8) {
    // e.g. '20090712'
    // TODO(danvk): remove support for this format. It's confusing.
    dateStrSlashed = dateStr.substr(0, 4) + "/" + dateStr.substr(4, 2) + "/" + dateStr.substr(6, 2);
    d = dateStrToMillis(dateStrSlashed);
  } else {
    // Any format that Date.parse will accept, e.g. "2009/07/12" or
    // "2009/07/12 12:34:56"
    d = dateStrToMillis(dateStr);
  }

  if (!d || isNaN(d)) {
    console.error("Couldn't parse " + dateStr + " as a date");
  }
  return d;
}

;

/**
 * This is identical to JavaScript's built-in Date.parse() method, except that
 * it doesn't get replaced with an incompatible method by aggressive JS
 * libraries like MooTools or Joomla.
 * @param {string} str The date string, e.g. "2011/05/06"
 * @return {number} millis since epoch
 * @private
 */

function dateStrToMillis(str) {
  return new Date(str).getTime();
}

;

// These functions are all based on MochiKit.
/**
 * Copies all the properties from o to self.
 *
 * @param {!Object} self
 * @param {!Object} o
 * @return {!Object}
 */

function update(self, o) {
  if (typeof o != 'undefined' && o !== null) {
    for (var k in o) {
      if (o.hasOwnProperty(k)) {
        self[k] = o[k];
      }
    }
  }
  return self;
}

;

/**
 * Copies all the properties from o to self.
 *
 * @param {!Object} self
 * @param {!Object} o
 * @return {!Object}
 * @private
 */

function updateDeep(self, o) {
  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
  function isNode(o) {
    return typeof Node === "object" ? o instanceof Node : typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
  }

  if (typeof o != 'undefined' && o !== null) {
    for (var k in o) {
      if (o.hasOwnProperty(k)) {
        if (o[k] === null) {
          self[k] = null;
        } else if (isArrayLike(o[k])) {
          self[k] = o[k].slice();
        } else if (isNode(o[k])) {
          // DOM objects are shallowly-copied.
          self[k] = o[k];
        } else if (typeof o[k] == 'object') {
          if (typeof self[k] != 'object' || self[k] === null) {
            self[k] = {};
          }
          updateDeep(self[k], o[k]);
        } else {
          self[k] = o[k];
        }
      }
    }
  }
  return self;
}

;

/**
 * @param {*} o
 * @return {boolean}
 * @private
 */

function isArrayLike(o) {
  var typ = typeof o;
  if (typ != 'object' && !(typ == 'function' && typeof o.item == 'function') || o === null || typeof o.length != 'number' || o.nodeType === 3) {
    return false;
  }
  return true;
}

;

/**
 * @param {Object} o
 * @return {boolean}
 * @private
 */

function isDateLike(o) {
  if (typeof o != "object" || o === null || typeof o.getTime != 'function') {
    return false;
  }
  return true;
}

;

/**
 * Note: this only seems to work for arrays.
 * @param {!Array} o
 * @return {!Array}
 * @private
 */

function clone(o) {
  // TODO(danvk): figure out how MochiKit's version works
  var r = [];
  for (var i = 0; i < o.length; i++) {
    if (isArrayLike(o[i])) {
      r.push(clone(o[i]));
    } else {
      r.push(o[i]);
    }
  }
  return r;
}

;

/**
 * Create a new canvas element.
 *
 * @return {!HTMLCanvasElement}
 * @private
 */

function createCanvas() {
  return document.createElement('canvas');
}

;

/**
 * Returns the context's pixel ratio, which is the ratio between the device
 * pixel ratio and the backing store ratio. Typically this is 1 for conventional
 * displays, and > 1 for HiDPI displays (such as the Retina MBP).
 * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.
 *
 * @param {!CanvasRenderingContext2D} context The canvas's 2d context.
 * @return {number} The ratio of the device pixel ratio and the backing store
 * ratio for the specified context.
 */

function getContextPixelRatio(context) {
  try {
    var devicePixelRatio = window.devicePixelRatio;
    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    if (devicePixelRatio !== undefined) {
      return devicePixelRatio / backingStoreRatio;
    } else {
      // At least devicePixelRatio must be defined for this ratio to make sense.
      // We default backingStoreRatio to 1: this does not exist on some browsers
      // (i.e. desktop Chrome).
      return 1;
    }
  } catch (e) {
    return 1;
  }
}

;

/**
 * Checks whether the user is on an Android browser.
 * Android does not fully support the <canvas> tag, e.g. w/r/t/ clipping.
 * @return {boolean}
 * @private
 */

function isAndroid() {
  return (/Android/.test(navigator.userAgent)
  );
}

;

/**
 * TODO(danvk): use @template here when it's better supported for classes.
 * @param {!Array} array
 * @param {number} start
 * @param {number} length
 * @param {function(!Array,?):boolean=} predicate
 * @constructor
 */

function Iterator(array, start, length, predicate) {
  start = start || 0;
  length = length || array.length;
  this.hasNext = true; // Use to identify if there's another element.
  this.peek = null; // Use for look-ahead
  this.start_ = start;
  this.array_ = array;
  this.predicate_ = predicate;
  this.end_ = Math.min(array.length, start + length);
  this.nextIdx_ = start - 1; // use -1 so initial advance works.
  this.next(); // ignoring result.
}

;

/**
 * @return {Object}
 */
Iterator.prototype.next = function () {
  if (!this.hasNext) {
    return null;
  }
  var obj = this.peek;

  var nextIdx = this.nextIdx_ + 1;
  var found = false;
  while (nextIdx < this.end_) {
    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {
      this.peek = this.array_[nextIdx];
      found = true;
      break;
    }
    nextIdx++;
  }
  this.nextIdx_ = nextIdx;
  if (!found) {
    this.hasNext = false;
    this.peek = null;
  }
  return obj;
};

/**
 * Returns a new iterator over array, between indexes start and
 * start + length, and only returns entries that pass the accept function
 *
 * @param {!Array} array the array to iterate over.
 * @param {number} start the first index to iterate over, 0 if absent.
 * @param {number} length the number of elements in the array to iterate over.
 *     This, along with start, defines a slice of the array, and so length
 *     doesn't imply the number of elements in the iterator when accept doesn't
 *     always accept all values. array.length when absent.
 * @param {function(?):boolean=} opt_predicate a function that takes
 *     parameters array and idx, which returns true when the element should be
 *     returned.  If omitted, all elements are accepted.
 * @private
 */

function createIterator(array, start, length, opt_predicate) {
  return new Iterator(array, start, length, opt_predicate);
}

;

// Shim layer with setTimeout fallback.
// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// Should be called with the window context:
//   Dygraph.requestAnimFrame.call(window, function() {})
var requestAnimFrame = (function () {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
})();

exports.requestAnimFrame = requestAnimFrame;
/**
 * Call a function at most maxFrames times at an attempted interval of
 * framePeriodInMillis, then call a cleanup function once. repeatFn is called
 * once immediately, then at most (maxFrames - 1) times asynchronously. If
 * maxFrames==1, then cleanup_fn() is also called synchronously.  This function
 * is used to sequence animation.
 * @param {function(number)} repeatFn Called repeatedly -- takes the frame
 *     number (from 0 to maxFrames-1) as an argument.
 * @param {number} maxFrames The max number of times to call repeatFn
 * @param {number} framePeriodInMillis Max requested time between frames.
 * @param {function()} cleanupFn A function to call after all repeatFn calls.
 * @private
 */

function repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis, cleanupFn) {
  var frameNumber = 0;
  var previousFrameNumber;
  var startTime = new Date().getTime();
  repeatFn(frameNumber);
  if (maxFrames == 1) {
    cleanupFn();
    return;
  }
  var maxFrameArg = maxFrames - 1;

  (function loop() {
    if (frameNumber >= maxFrames) return;
    requestAnimFrame.call(window, function () {
      // Determine which frame to draw based on the delay so far.  Will skip
      // frames if necessary.
      var currentTime = new Date().getTime();
      var delayInMillis = currentTime - startTime;
      previousFrameNumber = frameNumber;
      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);
      var frameDelta = frameNumber - previousFrameNumber;
      // If we predict that the subsequent repeatFn call will overshoot our
      // total frame target, so our last call will cause a stutter, then jump to
      // the last call immediately.  If we're going to cause a stutter, better
      // to do it faster than slower.
      var predictOvershootStutter = frameNumber + frameDelta > maxFrameArg;
      if (predictOvershootStutter || frameNumber >= maxFrameArg) {
        repeatFn(maxFrameArg); // Ensure final call with maxFrameArg.
        cleanupFn();
      } else {
        if (frameDelta !== 0) {
          // Don't call repeatFn with duplicate frames.
          repeatFn(frameNumber);
        }
        loop();
      }
    });
  })();
}

;

// A whitelist of options that do not change pixel positions.
var pixelSafeOptions = {
  'annotationClickHandler': true,
  'annotationDblClickHandler': true,
  'annotationMouseOutHandler': true,
  'annotationMouseOverHandler': true,
  'axisLabelColor': true,
  'axisLineColor': true,
  'axisLineWidth': true,
  'clickCallback': true,
  'drawCallback': true,
  'drawHighlightPointCallback': true,
  'drawPoints': true,
  'drawPointCallback': true,
  'drawGrid': true,
  'fillAlpha': true,
  'gridLineColor': true,
  'gridLineWidth': true,
  'hideOverlayOnMouseOut': true,
  'highlightCallback': true,
  'highlightCircleSize': true,
  'interactionModel': true,
  'isZoomedIgnoreProgrammaticZoom': true,
  'labelsDiv': true,
  'labelsDivStyles': true,
  'labelsDivWidth': true,
  'labelsKMB': true,
  'labelsKMG2': true,
  'labelsSeparateLines': true,
  'labelsShowZeroValues': true,
  'legend': true,
  'panEdgeFraction': true,
  'pixelsPerYLabel': true,
  'pointClickCallback': true,
  'pointSize': true,
  'rangeSelectorPlotFillColor': true,
  'rangeSelectorPlotFillGradientColor': true,
  'rangeSelectorPlotStrokeColor': true,
  'rangeSelectorBackgroundStrokeColor': true,
  'rangeSelectorBackgroundLineWidth': true,
  'rangeSelectorPlotLineWidth': true,
  'rangeSelectorForegroundStrokeColor': true,
  'rangeSelectorForegroundLineWidth': true,
  'rangeSelectorAlpha': true,
  'showLabelsOnHighlight': true,
  'showRoller': true,
  'strokeWidth': true,
  'underlayCallback': true,
  'unhighlightCallback': true,
  'zoomCallback': true
};

/**
 * This function will scan the option list and determine if they
 * require us to recalculate the pixel positions of each point.
 * TODO: move this into dygraph-options.js
 * @param {!Array.<string>} labels a list of options to check.
 * @param {!Object} attrs
 * @return {boolean} true if the graph needs new points else false.
 * @private
 */

function isPixelChangingOptionList(labels, attrs) {
  // Assume that we do not require new points.
  // This will change to true if we actually do need new points.

  // Create a dictionary of series names for faster lookup.
  // If there are no labels, then the dictionary stays empty.
  var seriesNamesDictionary = {};
  if (labels) {
    for (var i = 1; i < labels.length; i++) {
      seriesNamesDictionary[labels[i]] = true;
    }
  }

  // Scan through a flat (i.e. non-nested) object of options.
  // Returns true/false depending on whether new points are needed.
  var scanFlatOptions = function scanFlatOptions(options) {
    for (var property in options) {
      if (options.hasOwnProperty(property) && !pixelSafeOptions[property]) {
        return true;
      }
    }
    return false;
  };

  // Iterate through the list of updated options.
  for (var property in attrs) {
    if (!attrs.hasOwnProperty(property)) continue;

    // Find out of this field is actually a series specific options list.
    if (property == 'highlightSeriesOpts' || seriesNamesDictionary[property] && !attrs.series) {
      // This property value is a list of options for this series.
      if (scanFlatOptions(attrs[property])) return true;
    } else if (property == 'series' || property == 'axes') {
      // This is twice-nested options list.
      var perSeries = attrs[property];
      for (var series in perSeries) {
        if (perSeries.hasOwnProperty(series) && scanFlatOptions(perSeries[series])) {
          return true;
        }
      }
    } else {
      // If this was not a series specific option list, check if it's a pixel
      // changing property.
      if (!pixelSafeOptions[property]) return true;
    }
  }

  return false;
}

;

var Circles = {
  DEFAULT: function DEFAULT(g, name, ctx, canvasx, canvasy, color, radius) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);
    ctx.fill();
  }
  // For more shapes, include extras/shapes.js
};

exports.Circles = Circles;
/**
 * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.
 * @param {string} data
 * @return {?string} the delimiter that was detected (or null on failure).
 */

function detectLineDelimiter(data) {
  for (var i = 0; i < data.length; i++) {
    var code = data.charAt(i);
    if (code === '\r') {
      // Might actually be "\r\n".
      if (i + 1 < data.length && data.charAt(i + 1) === '\n') {
        return '\r\n';
      }
      return code;
    }
    if (code === '\n') {
      // Might actually be "\n\r".
      if (i + 1 < data.length && data.charAt(i + 1) === '\r') {
        return '\n\r';
      }
      return code;
    }
  }

  return null;
}

;

/**
 * Is one node contained by another?
 * @param {Node} containee The contained node.
 * @param {Node} container The container node.
 * @return {boolean} Whether containee is inside (or equal to) container.
 * @private
 */

function isNodeContainedBy(containee, container) {
  if (container === null || containee === null) {
    return false;
  }
  var containeeNode = /** @type {Node} */containee;
  while (containeeNode && containeeNode !== container) {
    containeeNode = containeeNode.parentNode;
  }
  return containeeNode === container;
}

;

// This masks some numeric issues in older versions of Firefox,
// where 1.0/Math.pow(10,2) != Math.pow(10,-2).
/** @type {function(number,number):number} */

function pow(base, exp) {
  if (exp < 0) {
    return 1.0 / Math.pow(base, -exp);
  }
  return Math.pow(base, exp);
}

;

var RGBA_RE = /^rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*([01](?:\.\d+)?))?\)$/;

/**
 * Helper for toRGB_ which parses strings of the form:
 * rgb(123, 45, 67)
 * rgba(123, 45, 67, 0.5)
 * @return parsed {r,g,b,a?} tuple or null.
 */
function parseRGBA(rgbStr) {
  var bits = RGBA_RE.exec(rgbStr);
  if (!bits) return null;
  var r = parseInt(bits[1], 10),
      g = parseInt(bits[2], 10),
      b = parseInt(bits[3], 10);
  if (bits[4]) {
    return { r: r, g: g, b: b, a: parseFloat(bits[4]) };
  } else {
    return { r: r, g: g, b: b };
  }
}

/**
 * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.
 *
 * @param {!string} colorStr Any valid CSS color string.
 * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.
 * @private
 */

function toRGB_(colorStr) {
  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM
  // manipulation.  If that fails (e.g. for named colors like 'red'), then
  // create a hidden DOM element and parse its computed color.
  var rgb = parseRGBA(colorStr);
  if (rgb) return rgb;

  var div = document.createElement('div');
  div.style.backgroundColor = colorStr;
  div.style.visibility = 'hidden';
  document.body.appendChild(div);
  var rgbStr = window.getComputedStyle(div, null).backgroundColor;
  document.body.removeChild(div);
  return parseRGBA(rgbStr);
}

;

/**
 * Checks whether the browser supports the &lt;canvas&gt; tag.
 * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an
 *     optimization if you have one.
 * @return {boolean} Whether the browser supports canvas.
 */

function isCanvasSupported(opt_canvasElement) {
  try {
    var canvas = opt_canvasElement || document.createElement("canvas");
    canvas.getContext("2d");
  } catch (e) {
    return false;
  }
  return true;
}

;

/**
 * Parses the value as a floating point number. This is like the parseFloat()
 * built-in, but with a few differences:
 * - the empty string is parsed as null, rather than NaN.
 * - if the string cannot be parsed at all, an error is logged.
 * If the string can't be parsed, this method returns null.
 * @param {string} x The string to be parsed
 * @param {number=} opt_line_no The line number from which the string comes.
 * @param {string=} opt_line The text of the line from which the string comes.
 */

function parseFloat_(x, opt_line_no, opt_line) {
  var val = parseFloat(x);
  if (!isNaN(val)) return val;

  // Try to figure out what happeend.
  // If the value is the empty string, parse it as null.
  if (/^ *$/.test(x)) return null;

  // If it was actually "NaN", return it as NaN.
  if (/^ *nan *$/i.test(x)) return NaN;

  // Looks like a parsing error.
  var msg = "Unable to parse '" + x + "' as a number";
  if (opt_line !== undefined && opt_line_no !== undefined) {
    msg += " on line " + (1 + (opt_line_no || 0)) + " ('" + opt_line + "') of CSV.";
  }
  console.error(msg);

  return null;
}

;

// Label constants for the labelsKMB and labelsKMG2 options.
// (i.e. '100000' -> '100K')
var KMB_LABELS = ['K', 'M', 'B', 'T', 'Q'];
var KMG2_BIG_LABELS = ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
var KMG2_SMALL_LABELS = ['m', 'u', 'n', 'p', 'f', 'a', 'z', 'y'];

/**
 * @private
 * Return a string version of a number. This respects the digitsAfterDecimal
 * and maxNumberWidth options.
 * @param {number} x The number to be formatted
 * @param {Dygraph} opts An options view
 */

function numberValueFormatter(x, opts) {
  var sigFigs = opts('sigFigs');

  if (sigFigs !== null) {
    // User has opted for a fixed number of significant figures.
    return floatFormat(x, sigFigs);
  }

  var digits = opts('digitsAfterDecimal');
  var maxNumberWidth = opts('maxNumberWidth');

  var kmb = opts('labelsKMB');
  var kmg2 = opts('labelsKMG2');

  var label;

  // switch to scientific notation if we underflow or overflow fixed display.
  if (x !== 0.0 && (Math.abs(x) >= Math.pow(10, maxNumberWidth) || Math.abs(x) < Math.pow(10, -digits))) {
    label = x.toExponential(digits);
  } else {
    label = '' + round_(x, digits);
  }

  if (kmb || kmg2) {
    var k;
    var k_labels = [];
    var m_labels = [];
    if (kmb) {
      k = 1000;
      k_labels = KMB_LABELS;
    }
    if (kmg2) {
      if (kmb) console.warn("Setting both labelsKMB and labelsKMG2. Pick one!");
      k = 1024;
      k_labels = KMG2_BIG_LABELS;
      m_labels = KMG2_SMALL_LABELS;
    }

    var absx = Math.abs(x);
    var n = pow(k, k_labels.length);
    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {
      if (absx >= n) {
        label = round_(x / n, digits) + k_labels[j];
        break;
      }
    }
    if (kmg2) {
      // TODO(danvk): clean up this logic. Why so different than kmb?
      var x_parts = String(x.toExponential()).split('e-');
      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {
        if (x_parts[1] % 3 > 0) {
          label = round_(x_parts[0] / pow(10, x_parts[1] % 3), digits);
        } else {
          label = Number(x_parts[0]).toFixed(2);
        }
        label += m_labels[Math.floor(x_parts[1] / 3) - 1];
      }
    }
  }

  return label;
}

;

/**
 * variant for use as an axisLabelFormatter.
 * @private
 */

function numberAxisLabelFormatter(x, granularity, opts) {
  return numberValueFormatter.call(this, x, opts);
}

;

/**
 * @type {!Array.<string>}
 * @private
 * @constant
 */
var SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

/**
 * Convert a JS date to a string appropriate to display on an axis that
 * is displaying values at the stated granularity. This respects the
 * labelsUTC option.
 * @param {Date} date The date to format
 * @param {number} granularity One of the Dygraph granularity constants
 * @param {Dygraph} opts An options view
 * @return {string} The date formatted as local time
 * @private
 */

function dateAxisLabelFormatter(date, granularity, opts) {
  var utc = opts('labelsUTC');
  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;

  var year = accessors.getFullYear(date),
      month = accessors.getMonth(date),
      day = accessors.getDate(date),
      hours = accessors.getHours(date),
      mins = accessors.getMinutes(date),
      secs = accessors.getSeconds(date),
      millis = accessors.getSeconds(date);

  if (granularity >= DygraphTickers.Granularity.DECADAL) {
    return '' + year;
  } else if (granularity >= DygraphTickers.Granularity.MONTHLY) {
    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;
  } else {
    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;
    if (frac === 0 || granularity >= DygraphTickers.Granularity.DAILY) {
      // e.g. '21 Jan' (%d%b)
      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];
    } else {
      return hmsString_(hours, mins, secs);
    }
  }
}

;
// alias in case anyone is referencing the old method.
// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;

/**
 * Return a string version of a JS date for a value label. This respects the
 * labelsUTC option.
 * @param {Date} date The date to be formatted
 * @param {Dygraph} opts An options view
 * @private
 */

function dateValueFormatter(d, opts) {
  return dateString_(d, opts('labelsUTC'));
}

;

},{"./dygraph-tickers":15}],17:[function(require,module,exports){
/**
 * @license
 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */ /**
 * @fileoverview Creates an interactive, zoomable graph based on a CSV file or
 * string. Dygraph can handle multiple series with or without error bars. The
 * date/value ranges will be automatically set. Dygraph uses the
 * &lt;canvas&gt; tag, so it only works in FF1.5+.
 * @author danvdk@gmail.com (Dan Vanderkam)

  Usage:
   <div id="graphdiv" style="width:800px; height:500px;"></div>
   <script type="text/javascript">
     new Dygraph(document.getElementById("graphdiv"),
                 "datafile.csv",  // CSV file with headers
                 { }); // options
   </script>

 The CSV file is of the form

   Date,SeriesA,SeriesB,SeriesC
   YYYYMMDD,A1,B1,C1
   YYYYMMDD,A2,B2,C2

 If the 'errorBars' option is set in the constructor, the input should be of
 the form
   Date,SeriesA,SeriesB,...
   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...
   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...

 If the 'fractions' option is set, the input should be of the form:

   Date,SeriesA,SeriesB,...
   YYYYMMDD,A1/B1,A2/B2,...
   YYYYMMDD,A1/B1,A2/B2,...

 And error bars will be calculated automatically using a binomial distribution.

 For further documentation and examples, see http://dygraphs.com/

 */'use strict';Object.defineProperty(exports,'__esModule',{value:true});function _interopRequireWildcard(obj){if(obj && obj.__esModule){return obj;}else {var newObj={};if(obj != null){for(var key in obj) {if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key] = obj[key];}}newObj['default'] = obj;return newObj;}}function _interopRequireDefault(obj){return obj && obj.__esModule?obj:{'default':obj};}var _dygraphLayout=require('./dygraph-layout');var _dygraphLayout2=_interopRequireDefault(_dygraphLayout);var _dygraphCanvas=require('./dygraph-canvas');var _dygraphCanvas2=_interopRequireDefault(_dygraphCanvas);var _dygraphOptions=require('./dygraph-options');var _dygraphOptions2=_interopRequireDefault(_dygraphOptions);var _dygraphInteractionModel=require('./dygraph-interaction-model');var _dygraphInteractionModel2=_interopRequireDefault(_dygraphInteractionModel);var _dygraphTickers=require('./dygraph-tickers');var DygraphTickers=_interopRequireWildcard(_dygraphTickers);var _dygraphUtils=require('./dygraph-utils');var utils=_interopRequireWildcard(_dygraphUtils);var _dygraphDefaultAttrs=require('./dygraph-default-attrs');var _dygraphDefaultAttrs2=_interopRequireDefault(_dygraphDefaultAttrs);var _dygraphOptionsReference=require('./dygraph-options-reference');var _dygraphOptionsReference2=_interopRequireDefault(_dygraphOptionsReference);var _iframeTarp=require('./iframe-tarp');var _iframeTarp2=_interopRequireDefault(_iframeTarp);var _datahandlerDefault=require('./datahandler/default');var _datahandlerDefault2=_interopRequireDefault(_datahandlerDefault);var _datahandlerBarsError=require('./datahandler/bars-error');var _datahandlerBarsError2=_interopRequireDefault(_datahandlerBarsError);var _datahandlerBarsCustom=require('./datahandler/bars-custom');var _datahandlerBarsCustom2=_interopRequireDefault(_datahandlerBarsCustom);var _datahandlerDefaultFractions=require('./datahandler/default-fractions');var _datahandlerDefaultFractions2=_interopRequireDefault(_datahandlerDefaultFractions);var _datahandlerBarsFractions=require('./datahandler/bars-fractions');var _datahandlerBarsFractions2=_interopRequireDefault(_datahandlerBarsFractions);var _datahandlerBars=require('./datahandler/bars');var _datahandlerBars2=_interopRequireDefault(_datahandlerBars);var _pluginsAnnotations=require('./plugins/annotations');var _pluginsAnnotations2=_interopRequireDefault(_pluginsAnnotations);var _pluginsAxes=require('./plugins/axes');var _pluginsAxes2=_interopRequireDefault(_pluginsAxes);var _pluginsChartLabels=require('./plugins/chart-labels');var _pluginsChartLabels2=_interopRequireDefault(_pluginsChartLabels);var _pluginsGrid=require('./plugins/grid');var _pluginsGrid2=_interopRequireDefault(_pluginsGrid);var _pluginsLegend=require('./plugins/legend');var _pluginsLegend2=_interopRequireDefault(_pluginsLegend);var _pluginsRangeSelector=require('./plugins/range-selector');var _pluginsRangeSelector2=_interopRequireDefault(_pluginsRangeSelector);var _dygraphGviz=require('./dygraph-gviz');var _dygraphGviz2=_interopRequireDefault(_dygraphGviz);"use strict"; /**
 * Creates an interactive, zoomable chart.
 *
 * @constructor
 * @param {div | String} div A div or the id of a div into which to construct
 * the chart.
 * @param {String | Function} file A file containing CSV data or a function
 * that returns this data. The most basic expected format for each line is
 * "YYYY/MM/DD,val1,val2,...". For more information, see
 * http://dygraphs.com/data.html.
 * @param {Object} attrs Various other attributes, e.g. errorBars determines
 * whether the input data contains error ranges. For a complete list of
 * options, see http://dygraphs.com/options.html.
 */var Dygraph=function Dygraph(div,data,opts){this.__init__(div,data,opts);};Dygraph.NAME = "Dygraph";Dygraph.VERSION = "1.1.0"; // Various default values
Dygraph.DEFAULT_ROLL_PERIOD = 1;Dygraph.DEFAULT_WIDTH = 480;Dygraph.DEFAULT_HEIGHT = 320; // For max 60 Hz. animation:
Dygraph.ANIMATION_STEPS = 12;Dygraph.ANIMATION_DURATION = 200; /**
 * Standard plotters. These may be used by clients.
 * Available plotters are:
 * - Dygraph.Plotters.linePlotter: draws central lines (most common)
 * - Dygraph.Plotters.errorPlotter: draws error bars
 * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)
 *
 * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].
 * This causes all the lines to be drawn over all the fills/error bars.
 */Dygraph.Plotters = _dygraphCanvas2['default']._Plotters; // Used for initializing annotation CSS rules only once.
Dygraph.addedAnnotationCSS = false; /**
 * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit
 * and context &lt;canvas&gt; inside of it. See the constructor for details.
 * on the parameters.
 * @param {Element} div the Element to render the graph into.
 * @param {string | Function} file Source data
 * @param {Object} attrs Miscellaneous other options
 * @private
 */Dygraph.prototype.__init__ = function(div,file,attrs){this.is_initial_draw_ = true;this.readyFns_ = []; // Support two-argument constructor
if(attrs === null || attrs === undefined){attrs = {};}attrs = Dygraph.copyUserAttrs_(attrs);if(typeof div == 'string'){div = document.getElementById(div);}if(!div){throw new Error('Constructing dygraph with a non-existent div!');} // Copy the important bits into the object
// TODO(danvk): most of these should just stay in the attrs_ dictionary.
this.maindiv_ = div;this.file_ = file;this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;this.previousVerticalX_ = -1;this.fractions_ = attrs.fractions || false;this.dateWindow_ = attrs.dateWindow || null;this.annotations_ = []; // Zoomed indicators - These indicate when the graph has been zoomed and on what axis.
this.zoomed_x_ = false;this.zoomed_y_ = false; // Clear the div. This ensure that, if multiple dygraphs are passed the same
// div, then only one will be drawn.
div.innerHTML = ""; // For historical reasons, the 'width' and 'height' options trump all CSS
// rules _except_ for an explicit 'width' or 'height' on the div.
// As an added convenience, if the div has zero height (like <div></div> does
// without any styles), then we use a default height/width.
if(div.style.width === '' && attrs.width){div.style.width = attrs.width + "px";}if(div.style.height === '' && attrs.height){div.style.height = attrs.height + "px";}if(div.style.height === '' && div.clientHeight === 0){div.style.height = Dygraph.DEFAULT_HEIGHT + "px";if(div.style.width === ''){div.style.width = Dygraph.DEFAULT_WIDTH + "px";}} // These will be zero if the dygraph's div is hidden. In that case,
// use the user-specified attributes if present. If not, use zero
// and assume the user will call resize to fix things later.
this.width_ = div.clientWidth || attrs.width || 0;this.height_ = div.clientHeight || attrs.height || 0; // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.
if(attrs.stackedGraph){attrs.fillGraph = true; // TODO(nikhilk): Add any other stackedGraph checks here.
} // DEPRECATION WARNING: All option processing should be moved from
// attrs_ and user_attrs_ to options_, which holds all this information.
//
// Dygraphs has many options, some of which interact with one another.
// To keep track of everything, we maintain two sets of options:
//
//  this.user_attrs_   only options explicitly set by the user.
//  this.attrs_        defaults, options derived from user_attrs_, data.
//
// Options are then accessed this.attr_('attr'), which first looks at
// user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent
// defaults without overriding behavior that the user specifically asks for.
this.user_attrs_ = {};utils.update(this.user_attrs_,attrs); // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.
this.attrs_ = {};utils.updateDeep(this.attrs_,_dygraphDefaultAttrs2['default']);this.boundaryIds_ = [];this.setIndexByName_ = {};this.datasetIndex_ = [];this.registeredEvents_ = [];this.eventListeners_ = {};this.attributes_ = new _dygraphOptions2['default'](this); // Create the containing DIV and other interactive elements
this.createInterface_(); // Activate plugins.
this.plugins_ = [];var plugins=Dygraph.PLUGINS.concat(this.getOption('plugins'));for(var i=0;i < plugins.length;i++) { // the plugins option may contain either plugin classes or instances.
// Plugin instances contain an activate method.
var Plugin=plugins[i]; // either a constructor or an instance.
var pluginInstance;if(typeof Plugin.activate !== 'undefined'){pluginInstance = Plugin;}else {pluginInstance = new Plugin();}var pluginDict={plugin:pluginInstance,events:{},options:{},pluginOptions:{}};var handlers=pluginInstance.activate(this);for(var eventName in handlers) {if(!handlers.hasOwnProperty(eventName))continue; // TODO(danvk): validate eventName.
pluginDict.events[eventName] = handlers[eventName];}this.plugins_.push(pluginDict);} // At this point, plugins can no longer register event handlers.
// Construct a map from event -> ordered list of [callback, plugin].
for(var i=0;i < this.plugins_.length;i++) {var plugin_dict=this.plugins_[i];for(var eventName in plugin_dict.events) {if(!plugin_dict.events.hasOwnProperty(eventName))continue;var callback=plugin_dict.events[eventName];var pair=[plugin_dict.plugin,callback];if(!(eventName in this.eventListeners_)){this.eventListeners_[eventName] = [pair];}else {this.eventListeners_[eventName].push(pair);}}}this.createDragInterface_();this.start_();}; /**
 * Triggers a cascade of events to the various plugins which are interested in them.
 * Returns true if the "default behavior" should be prevented, i.e. if one
 * of the event listeners called event.preventDefault().
 * @private
 */Dygraph.prototype.cascadeEvents_ = function(name,extra_props){if(!(name in this.eventListeners_))return false; // QUESTION: can we use objects & prototypes to speed this up?
var e={dygraph:this,cancelable:false,defaultPrevented:false,preventDefault:function preventDefault(){if(!e.cancelable)throw "Cannot call preventDefault on non-cancelable event.";e.defaultPrevented = true;},propagationStopped:false,stopPropagation:function stopPropagation(){e.propagationStopped = true;}};utils.update(e,extra_props);var callback_plugin_pairs=this.eventListeners_[name];if(callback_plugin_pairs){for(var i=callback_plugin_pairs.length - 1;i >= 0;i--) {var plugin=callback_plugin_pairs[i][0];var callback=callback_plugin_pairs[i][1];callback.call(plugin,e);if(e.propagationStopped)break;}}return e.defaultPrevented;}; /**
 * Fetch a plugin instance of a particular class. Only for testing.
 * @private
 * @param {!Class} type The type of the plugin.
 * @return {Object} Instance of the plugin, or null if there is none.
 */Dygraph.prototype.getPluginInstance_ = function(type){for(var i=0;i < this.plugins_.length;i++) {var p=this.plugins_[i];if(p.plugin instanceof type){return p.plugin;}}return null;}; /**
 * Returns the zoomed status of the chart for one or both axes.
 *
 * Axis is an optional parameter. Can be set to 'x' or 'y'.
 *
 * The zoomed status for an axis is set whenever a user zooms using the mouse
 * or when the dateWindow or valueRange are updated (unless the
 * isZoomedIgnoreProgrammaticZoom option is also specified).
 */Dygraph.prototype.isZoomed = function(axis){if(axis === null || axis === undefined){return this.zoomed_x_ || this.zoomed_y_;}if(axis === 'x')return this.zoomed_x_;if(axis === 'y')return this.zoomed_y_;throw "axis parameter is [" + axis + "] must be null, 'x' or 'y'.";}; /**
 * Returns information about the Dygraph object, including its containing ID.
 */Dygraph.prototype.toString = function(){var maindiv=this.maindiv_;var id=maindiv && maindiv.id?maindiv.id:maindiv;return "[Dygraph " + id + "]";}; /**
 * @private
 * Returns the value of an option. This may be set by the user (either in the
 * constructor or by calling updateOptions) or by dygraphs, and may be set to a
 * per-series value.
 * @param {string} name The name of the option, e.g. 'rollPeriod'.
 * @param {string} [seriesName] The name of the series to which the option
 * will be applied. If no per-series value of this option is available, then
 * the global value is returned. This is optional.
 * @return { ... } The value of the option.
 */Dygraph.prototype.attr_ = function(name,seriesName){ // For "production" code, this gets removed by uglifyjs.
if("development" != 'production'){if(typeof _dygraphOptionsReference2['default'] === 'undefined'){console.error('Must include options reference JS for testing');}else if(!_dygraphOptionsReference2['default'].hasOwnProperty(name)){console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.'); // Only log this error once.
_dygraphOptionsReference2['default'][name] = true;}}return seriesName?this.attributes_.getForSeries(name,seriesName):this.attributes_.get(name);}; /**
 * Returns the current value for an option, as set in the constructor or via
 * updateOptions. You may pass in an (optional) series name to get per-series
 * values for the option.
 *
 * All values returned by this method should be considered immutable. If you
 * modify them, there is no guarantee that the changes will be honored or that
 * dygraphs will remain in a consistent state. If you want to modify an option,
 * use updateOptions() instead.
 *
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {*} The value of the option.
 */Dygraph.prototype.getOption = function(name,opt_seriesName){return this.attr_(name,opt_seriesName);}; /**
 * Like getOption(), but specifically returns a number.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {number} The value of the option.
 * @private
 */Dygraph.prototype.getNumericOption = function(name,opt_seriesName){return  (/** @type{number} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a string.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {string} The value of the option.
 * @private
 */Dygraph.prototype.getStringOption = function(name,opt_seriesName){return  (/** @type{string} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a boolean.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {boolean} The value of the option.
 * @private
 */Dygraph.prototype.getBooleanOption = function(name,opt_seriesName){return  (/** @type{boolean} */this.getOption(name,opt_seriesName));}; /**
 * Like getOption(), but specifically returns a function.
 * This is a convenience function for working with the Closure Compiler.
 * @param {string} name The name of the option (e.g. 'strokeWidth')
 * @param {string=} opt_seriesName Series name to get per-series values.
 * @return {function(...)} The value of the option.
 * @private
 */Dygraph.prototype.getFunctionOption = function(name,opt_seriesName){return  (/** @type{function(...)} */this.getOption(name,opt_seriesName));};Dygraph.prototype.getOptionForAxis = function(name,axis){return this.attributes_.getForAxis(name,axis);}; /**
 * @private
 * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')
 * @return { ... } A function mapping string -> option value
 */Dygraph.prototype.optionsViewForAxis_ = function(axis){var self=this;return function(opt){var axis_opts=self.user_attrs_.axes;if(axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)){return axis_opts[axis][opt];} // I don't like that this is in a second spot.
if(axis === 'x' && opt === 'logscale'){ // return the default value.
// TODO(konigsberg): pull the default from a global default.
return false;} // user-specified attributes always trump defaults, even if they're less
// specific.
if(typeof self.user_attrs_[opt] != 'undefined'){return self.user_attrs_[opt];}axis_opts = self.attrs_.axes;if(axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)){return axis_opts[axis][opt];} // check old-style axis options
// TODO(danvk): add a deprecation warning if either of these match.
if(axis == 'y' && self.axes_[0].hasOwnProperty(opt)){return self.axes_[0][opt];}else if(axis == 'y2' && self.axes_[1].hasOwnProperty(opt)){return self.axes_[1][opt];}return self.attr_(opt);};}; /**
 * Returns the current rolling period, as set by the user or an option.
 * @return {number} The number of points in the rolling window
 */Dygraph.prototype.rollPeriod = function(){return this.rollPeriod_;}; /**
 * Returns the currently-visible x-range. This can be affected by zooming,
 * panning or a call to updateOptions.
 * Returns a two-element array: [left, right].
 * If the Dygraph has dates on the x-axis, these will be millis since epoch.
 */Dygraph.prototype.xAxisRange = function(){return this.dateWindow_?this.dateWindow_:this.xAxisExtremes();}; /**
 * Returns the lower- and upper-bound x-axis values of the
 * data set.
 */Dygraph.prototype.xAxisExtremes = function(){var pad=this.getNumericOption('xRangePad') / this.plotter_.area.w;if(this.numRows() === 0){return [0 - pad,1 + pad];}var left=this.rawData_[0][0];var right=this.rawData_[this.rawData_.length - 1][0];if(pad){ // Must keep this in sync with dygraph-layout _evaluateLimits()
var range=right - left;left -= range * pad;right += range * pad;}return [left,right];}; /**
 * Returns the currently-visible y-range for an axis. This can be affected by
 * zooming, panning or a call to updateOptions. Axis indices are zero-based. If
 * called with no arguments, returns the range of the first axis.
 * Returns a two-element array: [bottom, top].
 */Dygraph.prototype.yAxisRange = function(idx){if(typeof idx == "undefined")idx = 0;if(idx < 0 || idx >= this.axes_.length){return null;}var axis=this.axes_[idx];return [axis.computedValueRange[0],axis.computedValueRange[1]];}; /**
 * Returns the currently-visible y-ranges for each axis. This can be affected by
 * zooming, panning, calls to updateOptions, etc.
 * Returns an array of [bottom, top] pairs, one for each y-axis.
 */Dygraph.prototype.yAxisRanges = function(){var ret=[];for(var i=0;i < this.axes_.length;i++) {ret.push(this.yAxisRange(i));}return ret;}; // TODO(danvk): use these functions throughout dygraphs.
/**
 * Convert from data coordinates to canvas/div X/Y coordinates.
 * If specified, do this conversion for the coordinate system of a particular
 * axis. Uses the first axis by default.
 * Returns a two-element array: [X, Y]
 *
 * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord
 * instead of toDomCoords(null, y, axis).
 */Dygraph.prototype.toDomCoords = function(x,y,axis){return [this.toDomXCoord(x),this.toDomYCoord(y,axis)];}; /**
 * Convert from data x coordinates to canvas/div X coordinate.
 * If specified, do this conversion for the coordinate system of a particular
 * axis.
 * Returns a single value or null if x is null.
 */Dygraph.prototype.toDomXCoord = function(x){if(x === null){return null;}var area=this.plotter_.area;var xRange=this.xAxisRange();return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;}; /**
 * Convert from data x coordinates to canvas/div Y coordinate and optional
 * axis. Uses the first axis by default.
 *
 * returns a single value or null if y is null.
 */Dygraph.prototype.toDomYCoord = function(y,axis){var pct=this.toPercentYCoord(y,axis);if(pct === null){return null;}var area=this.plotter_.area;return area.y + pct * area.h;}; /**
 * Convert from canvas/div coords to data coordinates.
 * If specified, do this conversion for the coordinate system of a particular
 * axis. Uses the first axis by default.
 * Returns a two-element array: [X, Y].
 *
 * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord
 * instead of toDataCoords(null, y, axis).
 */Dygraph.prototype.toDataCoords = function(x,y,axis){return [this.toDataXCoord(x),this.toDataYCoord(y,axis)];}; /**
 * Convert from canvas/div x coordinate to data coordinate.
 *
 * If x is null, this returns null.
 */Dygraph.prototype.toDataXCoord = function(x){if(x === null){return null;}var area=this.plotter_.area;var xRange=this.xAxisRange();if(!this.attributes_.getForAxis("logscale",'x')){return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);}else {var pct=(x - area.x) / area.w;return utils.logRangeFraction(xRange[0],xRange[1],pct);}}; /**
 * Convert from canvas/div y coord to value.
 *
 * If y is null, this returns null.
 * if axis is null, this uses the first axis.
 */Dygraph.prototype.toDataYCoord = function(y,axis){if(y === null){return null;}var area=this.plotter_.area;var yRange=this.yAxisRange(axis);if(typeof axis == "undefined")axis = 0;if(!this.attributes_.getForAxis("logscale",axis)){return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);}else { // Computing the inverse of toDomCoord.
var pct=(y - area.y) / area.h; // Note reversed yRange, y1 is on top with pct==0.
return utils.logRangeFraction(yRange[1],yRange[0],pct);}}; /**
 * Converts a y for an axis to a percentage from the top to the
 * bottom of the drawing area.
 *
 * If the coordinate represents a value visible on the canvas, then
 * the value will be between 0 and 1, where 0 is the top of the canvas.
 * However, this method will return values outside the range, as
 * values can fall outside the canvas.
 *
 * If y is null, this returns null.
 * if axis is null, this uses the first axis.
 *
 * @param {number} y The data y-coordinate.
 * @param {number} [axis] The axis number on which the data coordinate lives.
 * @return {number} A fraction in [0, 1] where 0 = the top edge.
 */Dygraph.prototype.toPercentYCoord = function(y,axis){if(y === null){return null;}if(typeof axis == "undefined")axis = 0;var yRange=this.yAxisRange(axis);var pct;var logscale=this.attributes_.getForAxis("logscale",axis);if(logscale){var logr0=utils.log10(yRange[0]);var logr1=utils.log10(yRange[1]);pct = (logr1 - utils.log10(y)) / (logr1 - logr0);}else { // yRange[1] - y is unit distance from the bottom.
// yRange[1] - yRange[0] is the scale of the range.
// (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.
pct = (yRange[1] - y) / (yRange[1] - yRange[0]);}return pct;}; /**
 * Converts an x value to a percentage from the left to the right of
 * the drawing area.
 *
 * If the coordinate represents a value visible on the canvas, then
 * the value will be between 0 and 1, where 0 is the left of the canvas.
 * However, this method will return values outside the range, as
 * values can fall outside the canvas.
 *
 * If x is null, this returns null.
 * @param {number} x The data x-coordinate.
 * @return {number} A fraction in [0, 1] where 0 = the left edge.
 */Dygraph.prototype.toPercentXCoord = function(x){if(x === null){return null;}var xRange=this.xAxisRange();var pct;var logscale=this.attributes_.getForAxis("logscale",'x');if(logscale === true){ // logscale can be null so we test for true explicitly.
var logr0=utils.log10(xRange[0]);var logr1=utils.log10(xRange[1]);pct = (utils.log10(x) - logr0) / (logr1 - logr0);}else { // x - xRange[0] is unit distance from the left.
// xRange[1] - xRange[0] is the scale of the range.
// The full expression below is the % from the left.
pct = (x - xRange[0]) / (xRange[1] - xRange[0]);}return pct;}; /**
 * Returns the number of columns (including the independent variable).
 * @return {number} The number of columns.
 */Dygraph.prototype.numColumns = function(){if(!this.rawData_)return 0;return this.rawData_[0]?this.rawData_[0].length:this.attr_("labels").length;}; /**
 * Returns the number of rows (excluding any header/label row).
 * @return {number} The number of rows, less any header.
 */Dygraph.prototype.numRows = function(){if(!this.rawData_)return 0;return this.rawData_.length;}; /**
 * Returns the value in the given row and column. If the row and column exceed
 * the bounds on the data, returns null. Also returns null if the value is
 * missing.
 * @param {number} row The row number of the data (0-based). Row 0 is the
 *     first row of data, not a header row.
 * @param {number} col The column number of the data (0-based)
 * @return {number} The value in the specified cell or null if the row/col
 *     were out of range.
 */Dygraph.prototype.getValue = function(row,col){if(row < 0 || row > this.rawData_.length)return null;if(col < 0 || col > this.rawData_[row].length)return null;return this.rawData_[row][col];}; /**
 * Generates interface elements for the Dygraph: a containing div, a div to
 * display the current point, and a textbox to adjust the rolling average
 * period. Also creates the Renderer/Layout elements.
 * @private
 */Dygraph.prototype.createInterface_ = function(){ // Create the all-enclosing graph div
var enclosing=this.maindiv_;this.graphDiv = document.createElement("div"); // TODO(danvk): any other styles that are useful to set here?
this.graphDiv.style.textAlign = 'left'; // This is a CSS "reset"
this.graphDiv.style.position = 'relative';enclosing.appendChild(this.graphDiv); // Create the canvas for interactive parts of the chart.
this.canvas_ = utils.createCanvas();this.canvas_.style.position = "absolute"; // ... and for static parts of the chart.
this.hidden_ = this.createPlotKitCanvas_(this.canvas_);this.canvas_ctx_ = utils.getContext(this.canvas_);this.hidden_ctx_ = utils.getContext(this.hidden_);this.resizeElements_(); // The interactive parts of the graph are drawn on top of the chart.
this.graphDiv.appendChild(this.hidden_);this.graphDiv.appendChild(this.canvas_);this.mouseEventElement_ = this.createMouseEventElement_(); // Create the grapher
this.layout_ = new _dygraphLayout2['default'](this);var dygraph=this;this.mouseMoveHandler_ = function(e){dygraph.mouseMove_(e);};this.mouseOutHandler_ = function(e){ // The mouse has left the chart if:
// 1. e.target is inside the chart
// 2. e.relatedTarget is outside the chart
var target=e.target || e.fromElement;var relatedTarget=e.relatedTarget || e.toElement;if(utils.isNodeContainedBy(target,dygraph.graphDiv) && !utils.isNodeContainedBy(relatedTarget,dygraph.graphDiv)){dygraph.mouseOut_(e);}};this.addAndTrackEvent(window,'mouseout',this.mouseOutHandler_);this.addAndTrackEvent(this.mouseEventElement_,'mousemove',this.mouseMoveHandler_); // Don't recreate and register the resize handler on subsequent calls.
// This happens when the graph is resized.
if(!this.resizeHandler_){this.resizeHandler_ = function(e){dygraph.resize();}; // Update when the window is resized.
// TODO(danvk): drop frames depending on complexity of the chart.
this.addAndTrackEvent(window,'resize',this.resizeHandler_);}};Dygraph.prototype.resizeElements_ = function(){this.graphDiv.style.width = this.width_ + "px";this.graphDiv.style.height = this.height_ + "px";var canvasScale=utils.getContextPixelRatio(this.canvas_ctx_);this.canvas_.width = this.width_ * canvasScale;this.canvas_.height = this.height_ * canvasScale;this.canvas_.style.width = this.width_ + "px"; // for IE
this.canvas_.style.height = this.height_ + "px"; // for IE
if(canvasScale !== 1){this.canvas_ctx_.scale(canvasScale,canvasScale);}var hiddenScale=utils.getContextPixelRatio(this.hidden_ctx_);this.hidden_.width = this.width_ * hiddenScale;this.hidden_.height = this.height_ * hiddenScale;this.hidden_.style.width = this.width_ + "px"; // for IE
this.hidden_.style.height = this.height_ + "px"; // for IE
if(hiddenScale !== 1){this.hidden_ctx_.scale(hiddenScale,hiddenScale);}}; /**
 * Detach DOM elements in the dygraph and null out all data references.
 * Calling this when you're done with a dygraph can dramatically reduce memory
 * usage. See, e.g., the tests/perf.html example.
 */Dygraph.prototype.destroy = function(){this.canvas_ctx_.restore();this.hidden_ctx_.restore(); // Destroy any plugins, in the reverse order that they were registered.
for(var i=this.plugins_.length - 1;i >= 0;i--) {var p=this.plugins_.pop();if(p.plugin.destroy)p.plugin.destroy();}var removeRecursive=function removeRecursive(node){while(node.hasChildNodes()) {removeRecursive(node.firstChild);node.removeChild(node.firstChild);}};this.removeTrackedEvents_(); // remove mouse event handlers (This may not be necessary anymore)
utils.removeEvent(window,'mouseout',this.mouseOutHandler_);utils.removeEvent(this.mouseEventElement_,'mousemove',this.mouseMoveHandler_); // remove window handlers
utils.removeEvent(window,'resize',this.resizeHandler_);this.resizeHandler_ = null;removeRecursive(this.maindiv_);var nullOut=function nullOut(obj){for(var n in obj) {if(typeof obj[n] === 'object'){obj[n] = null;}}}; // These may not all be necessary, but it can't hurt...
nullOut(this.layout_);nullOut(this.plotter_);nullOut(this);}; /**
 * Creates the canvas on which the chart will be drawn. Only the Renderer ever
 * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots
 * or the zoom rectangles) is done on this.canvas_.
 * @param {Object} canvas The Dygraph canvas over which to overlay the plot
 * @return {Object} The newly-created canvas
 * @private
 */Dygraph.prototype.createPlotKitCanvas_ = function(canvas){var h=utils.createCanvas();h.style.position = "absolute"; // TODO(danvk): h should be offset from canvas. canvas needs to include
// some extra area to make it easier to zoom in on the far left and far
// right. h needs to be precisely the plot area, so that clipping occurs.
h.style.top = canvas.style.top;h.style.left = canvas.style.left;h.width = this.width_;h.height = this.height_;h.style.width = this.width_ + "px"; // for IE
h.style.height = this.height_ + "px"; // for IE
return h;}; /**
 * Creates an overlay element used to handle mouse events.
 * @return {Object} The mouse event element.
 * @private
 */Dygraph.prototype.createMouseEventElement_ = function(){return this.canvas_;}; /**
 * Generate a set of distinct colors for the data series. This is done with a
 * color wheel. Saturation/Value are customizable, and the hue is
 * equally-spaced around the color wheel. If a custom set of colors is
 * specified, that is used instead.
 * @private
 */Dygraph.prototype.setColors_ = function(){var labels=this.getLabels();var num=labels.length - 1;this.colors_ = [];this.colorsMap_ = {}; // These are used for when no custom colors are specified.
var sat=this.getNumericOption('colorSaturation') || 1.0;var val=this.getNumericOption('colorValue') || 0.5;var half=Math.ceil(num / 2);var colors=this.getOption('colors');var visibility=this.visibility();for(var i=0;i < num;i++) {if(!visibility[i]){continue;}var label=labels[i + 1];var colorStr=this.attributes_.getForSeries('color',label);if(!colorStr){if(colors){colorStr = colors[i % colors.length];}else { // alternate colors for high contrast.
var idx=i % 2?half + (i + 1) / 2:Math.ceil((i + 1) / 2);var hue=1.0 * idx / (1 + num);colorStr = utils.hsvToRGB(hue,sat,val);}}this.colors_.push(colorStr);this.colorsMap_[label] = colorStr;}}; /**
 * Return the list of colors. This is either the list of colors passed in the
 * attributes or the autogenerated list of rgb(r,g,b) strings.
 * This does not return colors for invisible series.
 * @return {Array.<string>} The list of colors.
 */Dygraph.prototype.getColors = function(){return this.colors_;}; /**
 * Returns a few attributes of a series, i.e. its color, its visibility, which
 * axis it's assigned to, and its column in the original data.
 * Returns null if the series does not exist.
 * Otherwise, returns an object with column, visibility, color and axis properties.
 * The "axis" property will be set to 1 for y1 and 2 for y2.
 * The "column" property can be fed back into getValue(row, column) to get
 * values for this series.
 */Dygraph.prototype.getPropertiesForSeries = function(series_name){var idx=-1;var labels=this.getLabels();for(var i=1;i < labels.length;i++) {if(labels[i] == series_name){idx = i;break;}}if(idx == -1)return null;return {name:series_name,column:idx,visible:this.visibility()[idx - 1],color:this.colorsMap_[series_name],axis:1 + this.attributes_.axisForSeries(series_name)};}; /**
 * Create the text box to adjust the averaging period
 * @private
 */Dygraph.prototype.createRollInterface_ = function(){ // Create a roller if one doesn't exist already.
if(!this.roller_){this.roller_ = document.createElement("input");this.roller_.type = "text";this.roller_.style.display = "none";this.graphDiv.appendChild(this.roller_);}var display=this.getBooleanOption('showRoller')?'block':'none';var area=this.plotter_.area;var textAttr={"position":"absolute","zIndex":10,"top":area.y + area.h - 25 + "px","left":area.x + 1 + "px","display":display};this.roller_.size = "2";this.roller_.value = this.rollPeriod_;for(var name in textAttr) {if(textAttr.hasOwnProperty(name)){this.roller_.style[name] = textAttr[name];}}var dygraph=this;this.roller_.onchange = function(){dygraph.adjustRoll(dygraph.roller_.value);};}; /**
 * Set up all the mouse handlers needed to capture dragging behavior for zoom
 * events.
 * @private
 */Dygraph.prototype.createDragInterface_ = function(){var context={ // Tracks whether the mouse is down right now
isZooming:false,isPanning:false, // is this drag part of a pan?
is2DPan:false, // if so, is that pan 1- or 2-dimensional?
dragStartX:null, // pixel coordinates
dragStartY:null, // pixel coordinates
dragEndX:null, // pixel coordinates
dragEndY:null, // pixel coordinates
dragDirection:null,prevEndX:null, // pixel coordinates
prevEndY:null, // pixel coordinates
prevDragDirection:null,cancelNextDblclick:false, // see comment in dygraph-interaction-model.js
// The value on the left side of the graph when a pan operation starts.
initialLeftmostDate:null, // The number of units each pixel spans. (This won't be valid for log
// scales)
xUnitsPerPixel:null, // TODO(danvk): update this comment
// The range in second/value units that the viewport encompasses during a
// panning operation.
dateRange:null, // Top-left corner of the canvas, in DOM coords
// TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.
px:0,py:0, // Values for use with panEdgeFraction, which limit how far outside the
// graph's data boundaries it can be panned.
boundedDates:null, // [minDate, maxDate]
boundedValues:null, // [[minValue, maxValue] ...]
// We cover iframes during mouse interactions. See comments in
// dygraph-utils.js for more info on why this is a good idea.
tarp:new _iframeTarp2['default'](), // contextB is the same thing as this context object but renamed.
initializeMouseDown:function initializeMouseDown(event,g,contextB){ // prevents mouse drags from selecting page text.
if(event.preventDefault){event.preventDefault(); // Firefox, Chrome, etc.
}else {event.returnValue = false; // IE
event.cancelBubble = true;}var canvasPos=utils.findPos(g.canvas_);contextB.px = canvasPos.x;contextB.py = canvasPos.y;contextB.dragStartX = utils.dragGetX_(event,contextB);contextB.dragStartY = utils.dragGetY_(event,contextB);contextB.cancelNextDblclick = false;contextB.tarp.cover();},destroy:function destroy(){var context=this;if(context.isZooming || context.isPanning){context.isZooming = false;context.dragStartX = null;context.dragStartY = null;}if(context.isPanning){context.isPanning = false;context.draggingDate = null;context.dateRange = null;for(var i=0;i < self.axes_.length;i++) {delete self.axes_[i].draggingValue;delete self.axes_[i].dragValueRange;}}context.tarp.uncover();}};var interactionModel=this.getOption("interactionModel"); // Self is the graph.
var self=this; // Function that binds the graph and context to the handler.
var bindHandler=function bindHandler(handler){return function(event){handler(event,self,context);};};for(var eventName in interactionModel) {if(!interactionModel.hasOwnProperty(eventName))continue;this.addAndTrackEvent(this.mouseEventElement_,eventName,bindHandler(interactionModel[eventName]));} // If the user releases the mouse button during a drag, but not over the
// canvas, then it doesn't count as a zooming action.
if(!interactionModel.willDestroyContextMyself){var mouseUpHandler=function mouseUpHandler(event){context.destroy();};this.addAndTrackEvent(document,'mouseup',mouseUpHandler);}}; /**
 * Draw a gray zoom rectangle over the desired area of the canvas. Also clears
 * up any previous zoom rectangles that were drawn. This could be optimized to
 * avoid extra redrawing, but it's tricky to avoid interactions with the status
 * dots.
 *
 * @param {number} direction the direction of the zoom rectangle. Acceptable
 *     values are utils.HORIZONTAL and utils.VERTICAL.
 * @param {number} startX The X position where the drag started, in canvas
 *     coordinates.
 * @param {number} endX The current X position of the drag, in canvas coords.
 * @param {number} startY The Y position where the drag started, in canvas
 *     coordinates.
 * @param {number} endY The current Y position of the drag, in canvas coords.
 * @param {number} prevDirection the value of direction on the previous call to
 *     this function. Used to avoid excess redrawing
 * @param {number} prevEndX The value of endX on the previous call to this
 *     function. Used to avoid excess redrawing
 * @param {number} prevEndY The value of endY on the previous call to this
 *     function. Used to avoid excess redrawing
 * @private
 */Dygraph.prototype.drawZoomRect_ = function(direction,startX,endX,startY,endY,prevDirection,prevEndX,prevEndY){var ctx=this.canvas_ctx_; // Clean up from the previous rect if necessary
if(prevDirection == utils.HORIZONTAL){ctx.clearRect(Math.min(startX,prevEndX),this.layout_.getPlotArea().y,Math.abs(startX - prevEndX),this.layout_.getPlotArea().h);}else if(prevDirection == utils.VERTICAL){ctx.clearRect(this.layout_.getPlotArea().x,Math.min(startY,prevEndY),this.layout_.getPlotArea().w,Math.abs(startY - prevEndY));} // Draw a light-grey rectangle to show the new viewing area
if(direction == utils.HORIZONTAL){if(endX && startX){ctx.fillStyle = "rgba(128,128,128,0.33)";ctx.fillRect(Math.min(startX,endX),this.layout_.getPlotArea().y,Math.abs(endX - startX),this.layout_.getPlotArea().h);}}else if(direction == utils.VERTICAL){if(endY && startY){ctx.fillStyle = "rgba(128,128,128,0.33)";ctx.fillRect(this.layout_.getPlotArea().x,Math.min(startY,endY),this.layout_.getPlotArea().w,Math.abs(endY - startY));}}}; /**
 * Clear the zoom rectangle (and perform no zoom).
 * @private
 */Dygraph.prototype.clearZoomRect_ = function(){this.currentZoomRectArgs_ = null;this.canvas_ctx_.clearRect(0,0,this.width_,this.height_);}; /**
 * Zoom to something containing [lowX, highX]. These are pixel coordinates in
 * the canvas. The exact zoom window may be slightly larger if there are no data
 * points near lowX or highX. Don't confuse this function with doZoomXDates,
 * which accepts dates that match the raw data. This function redraws the graph.
 *
 * @param {number} lowX The leftmost pixel value that should be visible.
 * @param {number} highX The rightmost pixel value that should be visible.
 * @private
 */Dygraph.prototype.doZoomX_ = function(lowX,highX){this.currentZoomRectArgs_ = null; // Find the earliest and latest dates contained in this canvasx range.
// Convert the call to date ranges of the raw data.
var minDate=this.toDataXCoord(lowX);var maxDate=this.toDataXCoord(highX);this.doZoomXDates_(minDate,maxDate);}; /**
 * Zoom to something containing [minDate, maxDate] values. Don't confuse this
 * method with doZoomX which accepts pixel coordinates. This function redraws
 * the graph.
 *
 * @param {number} minDate The minimum date that should be visible.
 * @param {number} maxDate The maximum date that should be visible.
 * @private
 */Dygraph.prototype.doZoomXDates_ = function(minDate,maxDate){ // TODO(danvk): when xAxisRange is null (i.e. "fit to data", the animation
// can produce strange effects. Rather than the x-axis transitioning slowly
// between values, it can jerk around.)
var old_window=this.xAxisRange();var new_window=[minDate,maxDate];this.zoomed_x_ = true;var that=this;this.doAnimatedZoom(old_window,new_window,null,null,function(){if(that.getFunctionOption("zoomCallback")){that.getFunctionOption("zoomCallback").call(that,minDate,maxDate,that.yAxisRanges());}});}; /**
 * Zoom to something containing [lowY, highY]. These are pixel coordinates in
 * the canvas. This function redraws the graph.
 *
 * @param {number} lowY The topmost pixel value that should be visible.
 * @param {number} highY The lowest pixel value that should be visible.
 * @private
 */Dygraph.prototype.doZoomY_ = function(lowY,highY){this.currentZoomRectArgs_ = null; // Find the highest and lowest values in pixel range for each axis.
// Note that lowY (in pixels) corresponds to the max Value (in data coords).
// This is because pixels increase as you go down on the screen, whereas data
// coordinates increase as you go up the screen.
var oldValueRanges=this.yAxisRanges();var newValueRanges=[];for(var i=0;i < this.axes_.length;i++) {var hi=this.toDataYCoord(lowY,i);var low=this.toDataYCoord(highY,i);newValueRanges.push([low,hi]);}this.zoomed_y_ = true;var that=this;this.doAnimatedZoom(null,null,oldValueRanges,newValueRanges,function(){if(that.getFunctionOption("zoomCallback")){var xRange=that.xAxisRange();that.getFunctionOption("zoomCallback").call(that,xRange[0],xRange[1],that.yAxisRanges());}});}; /**
 * Transition function to use in animations. Returns values between 0.0
 * (totally old values) and 1.0 (totally new values) for each frame.
 * @private
 */Dygraph.zoomAnimationFunction = function(frame,numFrames){var k=1.5;return (1.0 - Math.pow(k,-frame)) / (1.0 - Math.pow(k,-numFrames));}; /**
 * Reset the zoom to the original view coordinates. This is the same as
 * double-clicking on the graph.
 */Dygraph.prototype.resetZoom = function(){var dirty=false,dirtyX=false,dirtyY=false;if(this.dateWindow_ !== null){dirty = true;dirtyX = true;}for(var i=0;i < this.axes_.length;i++) {if(typeof this.axes_[i].valueWindow !== 'undefined' && this.axes_[i].valueWindow !== null){dirty = true;dirtyY = true;}} // Clear any selection, since it's likely to be drawn in the wrong place.
this.clearSelection();if(dirty){this.zoomed_x_ = false;this.zoomed_y_ = false; //calculate extremes to avoid lack of padding on reset.
var extremes=this.xAxisExtremes();var minDate=extremes[0],maxDate=extremes[1]; // TODO(danvk): merge this block w/ the code below.
if(!this.getBooleanOption("animatedZooms")){this.dateWindow_ = null;for(i = 0;i < this.axes_.length;i++) {if(this.axes_[i].valueWindow !== null){delete this.axes_[i].valueWindow;}}this.drawGraph_();if(this.getFunctionOption("zoomCallback")){this.getFunctionOption("zoomCallback").call(this,minDate,maxDate,this.yAxisRanges());}return;}var oldWindow=null,newWindow=null,oldValueRanges=null,newValueRanges=null;if(dirtyX){oldWindow = this.xAxisRange();newWindow = [minDate,maxDate];}if(dirtyY){oldValueRanges = this.yAxisRanges(); // TODO(danvk): this is pretty inefficient
var packed=this.gatherDatasets_(this.rolledSeries_,null);var extremes=packed.extremes; // this has the side-effect of modifying this.axes_.
// this doesn't make much sense in this context, but it's convenient (we
// need this.axes_[*].extremeValues) and not harmful since we'll be
// calling drawGraph_ shortly, which clobbers these values.
this.computeYAxisRanges_(extremes);newValueRanges = [];for(i = 0;i < this.axes_.length;i++) {var axis=this.axes_[i];newValueRanges.push(axis.valueRange !== null && axis.valueRange !== undefined?axis.valueRange:axis.extremeRange);}}var that=this;this.doAnimatedZoom(oldWindow,newWindow,oldValueRanges,newValueRanges,function(){that.dateWindow_ = null;for(var i=0;i < that.axes_.length;i++) {if(that.axes_[i].valueWindow !== null){delete that.axes_[i].valueWindow;}}if(that.getFunctionOption("zoomCallback")){that.getFunctionOption("zoomCallback").call(that,minDate,maxDate,that.yAxisRanges());}});}}; /**
 * Combined animation logic for all zoom functions.
 * either the x parameters or y parameters may be null.
 * @private
 */Dygraph.prototype.doAnimatedZoom = function(oldXRange,newXRange,oldYRanges,newYRanges,callback){var steps=this.getBooleanOption("animatedZooms")?Dygraph.ANIMATION_STEPS:1;var windows=[];var valueRanges=[];var step,frac;if(oldXRange !== null && newXRange !== null){for(step = 1;step <= steps;step++) {frac = Dygraph.zoomAnimationFunction(step,steps);windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0],oldXRange[1] * (1 - frac) + frac * newXRange[1]];}}if(oldYRanges !== null && newYRanges !== null){for(step = 1;step <= steps;step++) {frac = Dygraph.zoomAnimationFunction(step,steps);var thisRange=[];for(var j=0;j < this.axes_.length;j++) {thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0],oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);}valueRanges[step - 1] = thisRange;}}var that=this;utils.repeatAndCleanup(function(step){if(valueRanges.length){for(var i=0;i < that.axes_.length;i++) {var w=valueRanges[step][i];that.axes_[i].valueWindow = [w[0],w[1]];}}if(windows.length){that.dateWindow_ = windows[step];}that.drawGraph_();},steps,Dygraph.ANIMATION_DURATION / steps,callback);}; /**
 * Get the current graph's area object.
 *
 * Returns: {x, y, w, h}
 */Dygraph.prototype.getArea = function(){return this.plotter_.area;}; /**
 * Convert a mouse event to DOM coordinates relative to the graph origin.
 *
 * Returns a two-element array: [X, Y].
 */Dygraph.prototype.eventToDomCoords = function(event){if(event.offsetX && event.offsetY){return [event.offsetX,event.offsetY];}else {var eventElementPos=utils.findPos(this.mouseEventElement_);var canvasx=utils.pageX(event) - eventElementPos.x;var canvasy=utils.pageY(event) - eventElementPos.y;return [canvasx,canvasy];}}; /**
 * Given a canvas X coordinate, find the closest row.
 * @param {number} domX graph-relative DOM X coordinate
 * Returns {number} row number.
 * @private
 */Dygraph.prototype.findClosestRow = function(domX){var minDistX=Infinity;var closestRow=-1;var sets=this.layout_.points;for(var i=0;i < sets.length;i++) {var points=sets[i];var len=points.length;for(var j=0;j < len;j++) {var point=points[j];if(!utils.isValidPoint(point,true))continue;var dist=Math.abs(point.canvasx - domX);if(dist < minDistX){minDistX = dist;closestRow = point.idx;}}}return closestRow;}; /**
 * Given canvas X,Y coordinates, find the closest point.
 *
 * This finds the individual data point across all visible series
 * that's closest to the supplied DOM coordinates using the standard
 * Euclidean X,Y distance.
 *
 * @param {number} domX graph-relative DOM X coordinate
 * @param {number} domY graph-relative DOM Y coordinate
 * Returns: {row, seriesName, point}
 * @private
 */Dygraph.prototype.findClosestPoint = function(domX,domY){var minDist=Infinity;var dist,dx,dy,point,closestPoint,closestSeries,closestRow;for(var setIdx=this.layout_.points.length - 1;setIdx >= 0;--setIdx) {var points=this.layout_.points[setIdx];for(var i=0;i < points.length;++i) {point = points[i];if(!utils.isValidPoint(point))continue;dx = point.canvasx - domX;dy = point.canvasy - domY;dist = dx * dx + dy * dy;if(dist < minDist){minDist = dist;closestPoint = point;closestSeries = setIdx;closestRow = point.idx;}}}var name=this.layout_.setNames[closestSeries];return {row:closestRow,seriesName:name,point:closestPoint};}; /**
 * Given canvas X,Y coordinates, find the touched area in a stacked graph.
 *
 * This first finds the X data point closest to the supplied DOM X coordinate,
 * then finds the series which puts the Y coordinate on top of its filled area,
 * using linear interpolation between adjacent point pairs.
 *
 * @param {number} domX graph-relative DOM X coordinate
 * @param {number} domY graph-relative DOM Y coordinate
 * Returns: {row, seriesName, point}
 * @private
 */Dygraph.prototype.findStackedPoint = function(domX,domY){var row=this.findClosestRow(domX);var closestPoint,closestSeries;for(var setIdx=0;setIdx < this.layout_.points.length;++setIdx) {var boundary=this.getLeftBoundary_(setIdx);var rowIdx=row - boundary;var points=this.layout_.points[setIdx];if(rowIdx >= points.length)continue;var p1=points[rowIdx];if(!utils.isValidPoint(p1))continue;var py=p1.canvasy;if(domX > p1.canvasx && rowIdx + 1 < points.length){ // interpolate series Y value using next point
var p2=points[rowIdx + 1];if(utils.isValidPoint(p2)){var dx=p2.canvasx - p1.canvasx;if(dx > 0){var r=(domX - p1.canvasx) / dx;py += r * (p2.canvasy - p1.canvasy);}}}else if(domX < p1.canvasx && rowIdx > 0){ // interpolate series Y value using previous point
var p0=points[rowIdx - 1];if(utils.isValidPoint(p0)){var dx=p1.canvasx - p0.canvasx;if(dx > 0){var r=(p1.canvasx - domX) / dx;py += r * (p0.canvasy - p1.canvasy);}}} // Stop if the point (domX, py) is above this series' upper edge
if(setIdx === 0 || py < domY){closestPoint = p1;closestSeries = setIdx;}}var name=this.layout_.setNames[closestSeries];return {row:row,seriesName:name,point:closestPoint};}; /**
 * When the mouse moves in the canvas, display information about a nearby data
 * point and draw dots over those points in the data series. This function
 * takes care of cleanup of previously-drawn dots.
 * @param {Object} event The mousemove event from the browser.
 * @private
 */Dygraph.prototype.mouseMove_ = function(event){ // This prevents JS errors when mousing over the canvas before data loads.
var points=this.layout_.points;if(points === undefined || points === null)return;var canvasCoords=this.eventToDomCoords(event);var canvasx=canvasCoords[0];var canvasy=canvasCoords[1];var highlightSeriesOpts=this.getOption("highlightSeriesOpts");var selectionChanged=false;if(highlightSeriesOpts && !this.isSeriesLocked()){var closest;if(this.getBooleanOption("stackedGraph")){closest = this.findStackedPoint(canvasx,canvasy);}else {closest = this.findClosestPoint(canvasx,canvasy);}selectionChanged = this.setSelection(closest.row,closest.seriesName);}else {var idx=this.findClosestRow(canvasx);selectionChanged = this.setSelection(idx);}var callback=this.getFunctionOption("highlightCallback");if(callback && selectionChanged){callback.call(this,event,this.lastx_,this.selPoints_,this.lastRow_,this.highlightSet_);}}; /**
 * Fetch left offset from the specified set index or if not passed, the
 * first defined boundaryIds record (see bug #236).
 * @private
 */Dygraph.prototype.getLeftBoundary_ = function(setIdx){if(this.boundaryIds_[setIdx]){return this.boundaryIds_[setIdx][0];}else {for(var i=0;i < this.boundaryIds_.length;i++) {if(this.boundaryIds_[i] !== undefined){return this.boundaryIds_[i][0];}}return 0;}};Dygraph.prototype.animateSelection_ = function(direction){var totalSteps=10;var millis=30;if(this.fadeLevel === undefined)this.fadeLevel = 0;if(this.animateId === undefined)this.animateId = 0;var start=this.fadeLevel;var steps=direction < 0?start:totalSteps - start;if(steps <= 0){if(this.fadeLevel){this.updateSelection_(1.0);}return;}var thisId=++this.animateId;var that=this;var cleanupIfClearing=function cleanupIfClearing(){ // if we haven't reached fadeLevel 0 in the max frame time,
// ensure that the clear happens and just go to 0
if(that.fadeLevel !== 0 && direction < 0){that.fadeLevel = 0;that.clearSelection();}};utils.repeatAndCleanup(function(n){ // ignore simultaneous animations
if(that.animateId != thisId)return;that.fadeLevel += direction;if(that.fadeLevel === 0){that.clearSelection();}else {that.updateSelection_(that.fadeLevel / totalSteps);}},steps,millis,cleanupIfClearing);}; /**
 * Draw dots over the selectied points in the data series. This function
 * takes care of cleanup of previously-drawn dots.
 * @private
 */Dygraph.prototype.updateSelection_ = function(opt_animFraction){ /*var defaultPrevented = */this.cascadeEvents_('select',{selectedRow:this.lastRow_,selectedX:this.lastx_,selectedPoints:this.selPoints_}); // TODO(danvk): use defaultPrevented here?
// Clear the previously drawn vertical, if there is one
var i;var ctx=this.canvas_ctx_;if(this.getOption('highlightSeriesOpts')){ctx.clearRect(0,0,this.width_,this.height_);var alpha=1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');var backgroundColor=utils.toRGB_(this.getOption('highlightSeriesBackgroundColor'));if(alpha){ // Activating background fade includes an animation effect for a gradual
// fade. TODO(klausw): make this independently configurable if it causes
// issues? Use a shared preference to control animations?
var animateBackgroundFade=true;if(animateBackgroundFade){if(opt_animFraction === undefined){ // start a new animation
this.animateSelection_(1);return;}alpha *= opt_animFraction;}ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';ctx.fillRect(0,0,this.width_,this.height_);} // Redraw only the highlighted series in the interactive canvas (not the
// static plot canvas, which is where series are usually drawn).
this.plotter_._renderLineChart(this.highlightSet_,ctx);}else if(this.previousVerticalX_ >= 0){ // Determine the maximum highlight circle size.
var maxCircleSize=0;var labels=this.attr_('labels');for(i = 1;i < labels.length;i++) {var r=this.getNumericOption('highlightCircleSize',labels[i]);if(r > maxCircleSize)maxCircleSize = r;}var px=this.previousVerticalX_;ctx.clearRect(px - maxCircleSize - 1,0,2 * maxCircleSize + 2,this.height_);}if(this.selPoints_.length > 0){ // Draw colored circles over the center of each selected point
var canvasx=this.selPoints_[0].canvasx;ctx.save();for(i = 0;i < this.selPoints_.length;i++) {var pt=this.selPoints_[i];if(isNaN(pt.canvasy))continue;var circleSize=this.getNumericOption('highlightCircleSize',pt.name);var callback=this.getFunctionOption("drawHighlightPointCallback",pt.name);var color=this.plotter_.colors[pt.name];if(!callback){callback = utils.Circles.DEFAULT;}ctx.lineWidth = this.getNumericOption('strokeWidth',pt.name);ctx.strokeStyle = color;ctx.fillStyle = color;callback.call(this,this,pt.name,ctx,canvasx,pt.canvasy,color,circleSize,pt.idx);}ctx.restore();this.previousVerticalX_ = canvasx;}}; /**
 * Manually set the selected points and display information about them in the
 * legend. The selection can be cleared using clearSelection() and queried
 * using getSelection().
 * @param {number} row Row number that should be highlighted (i.e. appear with
 * hover dots on the chart).
 * @param {seriesName} optional series name to highlight that series with the
 * the highlightSeriesOpts setting.
 * @param { locked } optional If true, keep seriesName selected when mousing
 * over the graph, disabling closest-series highlighting. Call clearSelection()
 * to unlock it.
 */Dygraph.prototype.setSelection = function(row,opt_seriesName,opt_locked){ // Extract the points we've selected
this.selPoints_ = [];var changed=false;if(row !== false && row >= 0){if(row != this.lastRow_)changed = true;this.lastRow_ = row;for(var setIdx=0;setIdx < this.layout_.points.length;++setIdx) {var points=this.layout_.points[setIdx]; // Check if the point at the appropriate index is the point we're looking
// for.  If it is, just use it, otherwise search the array for a point
// in the proper place.
var setRow=row - this.getLeftBoundary_(setIdx);if(setRow < points.length && points[setRow].idx == row){var point=points[setRow];if(point.yval !== null)this.selPoints_.push(point);}else {for(var pointIdx=0;pointIdx < points.length;++pointIdx) {var point=points[pointIdx];if(point.idx == row){if(point.yval !== null){this.selPoints_.push(point);}break;}}}}}else {if(this.lastRow_ >= 0)changed = true;this.lastRow_ = -1;}if(this.selPoints_.length){this.lastx_ = this.selPoints_[0].xval;}else {this.lastx_ = -1;}if(opt_seriesName !== undefined){if(this.highlightSet_ !== opt_seriesName)changed = true;this.highlightSet_ = opt_seriesName;}if(opt_locked !== undefined){this.lockedSet_ = opt_locked;}if(changed){this.updateSelection_(undefined);}return changed;}; /**
 * The mouse has left the canvas. Clear out whatever artifacts remain
 * @param {Object} event the mouseout event from the browser.
 * @private
 */Dygraph.prototype.mouseOut_ = function(event){if(this.getFunctionOption("unhighlightCallback")){this.getFunctionOption("unhighlightCallback").call(this,event);}if(this.getBooleanOption("hideOverlayOnMouseOut") && !this.lockedSet_){this.clearSelection();}}; /**
 * Clears the current selection (i.e. points that were highlighted by moving
 * the mouse over the chart).
 */Dygraph.prototype.clearSelection = function(){this.cascadeEvents_('deselect',{});this.lockedSet_ = false; // Get rid of the overlay data
if(this.fadeLevel){this.animateSelection_(-1);return;}this.canvas_ctx_.clearRect(0,0,this.width_,this.height_);this.fadeLevel = 0;this.selPoints_ = [];this.lastx_ = -1;this.lastRow_ = -1;this.highlightSet_ = null;}; /**
 * Returns the number of the currently selected row. To get data for this row,
 * you can use the getValue method.
 * @return {number} row number, or -1 if nothing is selected
 */Dygraph.prototype.getSelection = function(){if(!this.selPoints_ || this.selPoints_.length < 1){return -1;}for(var setIdx=0;setIdx < this.layout_.points.length;setIdx++) {var points=this.layout_.points[setIdx];for(var row=0;row < points.length;row++) {if(points[row].x == this.selPoints_[0].x){return points[row].idx;}}}return -1;}; /**
 * Returns the name of the currently-highlighted series.
 * Only available when the highlightSeriesOpts option is in use.
 */Dygraph.prototype.getHighlightSeries = function(){return this.highlightSet_;}; /**
 * Returns true if the currently-highlighted series was locked
 * via setSelection(..., seriesName, true).
 */Dygraph.prototype.isSeriesLocked = function(){return this.lockedSet_;}; /**
 * Fires when there's data available to be graphed.
 * @param {string} data Raw CSV data to be plotted
 * @private
 */Dygraph.prototype.loadedEvent_ = function(data){this.rawData_ = this.parseCSV_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}; /**
 * Add ticks on the x-axis representing years, months, quarters, weeks, or days
 * @private
 */Dygraph.prototype.addXTicks_ = function(){ // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...
var range;if(this.dateWindow_){range = [this.dateWindow_[0],this.dateWindow_[1]];}else {range = this.xAxisExtremes();}var xAxisOptionsView=this.optionsViewForAxis_('x');var xTicks=xAxisOptionsView('ticker')(range[0],range[1],this.plotter_.area.w, // TODO(danvk): should be area.width
xAxisOptionsView,this); // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);
// console.log(msg);
this.layout_.setXTicks(xTicks);}; /**
 * Returns the correct handler class for the currently set options.
 * @private
 */Dygraph.prototype.getHandlerClass_ = function(){var handlerClass;if(this.attr_('dataHandler')){handlerClass = this.attr_('dataHandler');}else if(this.fractions_){if(this.getBooleanOption('errorBars')){handlerClass = _datahandlerBarsFractions2['default'];}else {handlerClass = _datahandlerDefaultFractions2['default'];}}else if(this.getBooleanOption('customBars')){handlerClass = _datahandlerBarsCustom2['default'];}else if(this.getBooleanOption('errorBars')){handlerClass = _datahandlerBarsError2['default'];}else {handlerClass = _datahandlerDefault2['default'];}return handlerClass;}; /**
 * @private
 * This function is called once when the chart's data is changed or the options
 * dictionary is updated. It is _not_ called when the user pans or zooms. The
 * idea is that values derived from the chart's data can be computed here,
 * rather than every time the chart is drawn. This includes things like the
 * number of axes, rolling averages, etc.
 */Dygraph.prototype.predraw_ = function(){var start=new Date(); // Create the correct dataHandler
this.dataHandler_ = new (this.getHandlerClass_())();this.layout_.computePlotArea(); // TODO(danvk): move more computations out of drawGraph_ and into here.
this.computeYAxes_();if(!this.is_initial_draw_){this.canvas_ctx_.restore();this.hidden_ctx_.restore();}this.canvas_ctx_.save();this.hidden_ctx_.save(); // Create a new plotter.
this.plotter_ = new _dygraphCanvas2['default'](this,this.hidden_,this.hidden_ctx_,this.layout_); // The roller sits in the bottom left corner of the chart. We don't know where
// this will be until the options are available, so it's positioned here.
this.createRollInterface_();this.cascadeEvents_('predraw'); // Convert the raw data (a 2D array) into the internal format and compute
// rolling averages.
this.rolledSeries_ = [null]; // x-axis is the first series and it's special
for(var i=1;i < this.numColumns();i++) { // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.
var series=this.dataHandler_.extractSeries(this.rawData_,i,this.attributes_);if(this.rollPeriod_ > 1){series = this.dataHandler_.rollingAverage(series,this.rollPeriod_,this.attributes_);}this.rolledSeries_.push(series);} // If the data or options have changed, then we'd better redraw.
this.drawGraph_(); // This is used to determine whether to do various animations.
var end=new Date();this.drawingTimeMs_ = end - start;}; /**
 * Point structure.
 *
 * xval_* and yval_* are the original unscaled data values,
 * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.
 * yval_stacked is the cumulative Y value used for stacking graphs,
 * and bottom/top/minus/plus are used for error bar graphs.
 *
 * @typedef {{
 *     idx: number,
 *     name: string,
 *     x: ?number,
 *     xval: ?number,
 *     y_bottom: ?number,
 *     y: ?number,
 *     y_stacked: ?number,
 *     y_top: ?number,
 *     yval_minus: ?number,
 *     yval: ?number,
 *     yval_plus: ?number,
 *     yval_stacked
 * }}
 */Dygraph.PointType = undefined; /**
 * Calculates point stacking for stackedGraph=true.
 *
 * For stacking purposes, interpolate or extend neighboring data across
 * NaN values based on stackedGraphNaNFill settings. This is for display
 * only, the underlying data value as shown in the legend remains NaN.
 *
 * @param {Array.<Dygraph.PointType>} points Point array for a single series.
 *     Updates each Point's yval_stacked property.
 * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y
 *     values for the series seen so far. Index is the row number. Updated
 *     based on the current series's values.
 * @param {Array.<number>} seriesExtremes Min and max values, updated
 *     to reflect the stacked values.
 * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or
 *     'none'.
 * @private
 */Dygraph.stackPoints_ = function(points,cumulativeYval,seriesExtremes,fillMethod){var lastXval=null;var prevPoint=null;var nextPoint=null;var nextPointIdx=-1; // Find the next stackable point starting from the given index.
var updateNextPoint=function updateNextPoint(idx){ // If we've previously found a non-NaN point and haven't gone past it yet,
// just use that.
if(nextPointIdx >= idx)return; // We haven't found a non-NaN point yet or have moved past it,
// look towards the right to find a non-NaN point.
for(var j=idx;j < points.length;++j) { // Clear out a previously-found point (if any) since it's no longer
// valid, we shouldn't use it for interpolation anymore.
nextPoint = null;if(!isNaN(points[j].yval) && points[j].yval !== null){nextPointIdx = j;nextPoint = points[j];break;}}};for(var i=0;i < points.length;++i) {var point=points[i];var xval=point.xval;if(cumulativeYval[xval] === undefined){cumulativeYval[xval] = 0;}var actualYval=point.yval;if(isNaN(actualYval) || actualYval === null){if(fillMethod == 'none'){actualYval = 0;}else { // Interpolate/extend for stacking purposes if possible.
updateNextPoint(i);if(prevPoint && nextPoint && fillMethod != 'none'){ // Use linear interpolation between prevPoint and nextPoint.
actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));}else if(prevPoint && fillMethod == 'all'){actualYval = prevPoint.yval;}else if(nextPoint && fillMethod == 'all'){actualYval = nextPoint.yval;}else {actualYval = 0;}}}else {prevPoint = point;}var stackedYval=cumulativeYval[xval];if(lastXval != xval){ // If an x-value is repeated, we ignore the duplicates.
stackedYval += actualYval;cumulativeYval[xval] = stackedYval;}lastXval = xval;point.yval_stacked = stackedYval;if(stackedYval > seriesExtremes[1]){seriesExtremes[1] = stackedYval;}if(stackedYval < seriesExtremes[0]){seriesExtremes[0] = stackedYval;}}}; /**
 * Loop over all fields and create datasets, calculating extreme y-values for
 * each series and extreme x-indices as we go.
 *
 * dateWindow is passed in as an explicit parameter so that we can compute
 * extreme values "speculatively", i.e. without actually setting state on the
 * dygraph.
 *
 * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where
 *     rolledSeries[seriesIndex][row] = raw point, where
 *     seriesIndex is the column number starting with 1, and
 *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].
 * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.
 * @return {{
 *     points: Array.<Array.<Dygraph.PointType>>,
 *     seriesExtremes: Array.<Array.<number>>,
 *     boundaryIds: Array.<number>}}
 * @private
 */Dygraph.prototype.gatherDatasets_ = function(rolledSeries,dateWindow){var boundaryIds=[];var points=[];var cumulativeYval=[]; // For stacked series.
var extremes={}; // series name -> [low, high]
var seriesIdx,sampleIdx;var firstIdx,lastIdx;var axisIdx; // Loop over the fields (series).  Go from the last to the first,
// because if they're stacked that's how we accumulate the values.
var num_series=rolledSeries.length - 1;var series;for(seriesIdx = num_series;seriesIdx >= 1;seriesIdx--) {if(!this.visibility()[seriesIdx - 1])continue; // Prune down to the desired range, if necessary (for zooming)
// Because there can be lines going to points outside of the visible area,
// we actually prune to visible points, plus one on either side.
if(dateWindow){series = rolledSeries[seriesIdx];var low=dateWindow[0];var high=dateWindow[1]; // TODO(danvk): do binary search instead of linear search.
// TODO(danvk): pass firstIdx and lastIdx directly to the renderer.
firstIdx = null;lastIdx = null;for(sampleIdx = 0;sampleIdx < series.length;sampleIdx++) {if(series[sampleIdx][0] >= low && firstIdx === null){firstIdx = sampleIdx;}if(series[sampleIdx][0] <= high){lastIdx = sampleIdx;}}if(firstIdx === null)firstIdx = 0;var correctedFirstIdx=firstIdx;var isInvalidValue=true;while(isInvalidValue && correctedFirstIdx > 0) {correctedFirstIdx--; // check if the y value is null.
isInvalidValue = series[correctedFirstIdx][1] === null;}if(lastIdx === null)lastIdx = series.length - 1;var correctedLastIdx=lastIdx;isInvalidValue = true;while(isInvalidValue && correctedLastIdx < series.length - 1) {correctedLastIdx++;isInvalidValue = series[correctedLastIdx][1] === null;}if(correctedFirstIdx !== firstIdx){firstIdx = correctedFirstIdx;}if(correctedLastIdx !== lastIdx){lastIdx = correctedLastIdx;}boundaryIds[seriesIdx - 1] = [firstIdx,lastIdx]; // .slice's end is exclusive, we want to include lastIdx.
series = series.slice(firstIdx,lastIdx + 1);}else {series = rolledSeries[seriesIdx];boundaryIds[seriesIdx - 1] = [0,series.length - 1];}var seriesName=this.attr_("labels")[seriesIdx];var seriesExtremes=this.dataHandler_.getExtremeYValues(series,dateWindow,this.getBooleanOption("stepPlot",seriesName));var seriesPoints=this.dataHandler_.seriesToPoints(series,seriesName,boundaryIds[seriesIdx - 1][0]);if(this.getBooleanOption("stackedGraph")){axisIdx = this.attributes_.axisForSeries(seriesName);if(cumulativeYval[axisIdx] === undefined){cumulativeYval[axisIdx] = [];}Dygraph.stackPoints_(seriesPoints,cumulativeYval[axisIdx],seriesExtremes,this.getBooleanOption("stackedGraphNaNFill"));}extremes[seriesName] = seriesExtremes;points[seriesIdx] = seriesPoints;}return {points:points,extremes:extremes,boundaryIds:boundaryIds};}; /**
 * Update the graph with new data. This method is called when the viewing area
 * has changed. If the underlying data or options have changed, predraw_ will
 * be called before drawGraph_ is called.
 *
 * @private
 */Dygraph.prototype.drawGraph_ = function(){var start=new Date(); // This is used to set the second parameter to drawCallback, below.
var is_initial_draw=this.is_initial_draw_;this.is_initial_draw_ = false;this.layout_.removeAllDatasets();this.setColors_();this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');var packed=this.gatherDatasets_(this.rolledSeries_,this.dateWindow_);var points=packed.points;var extremes=packed.extremes;this.boundaryIds_ = packed.boundaryIds;this.setIndexByName_ = {};var labels=this.attr_("labels");if(labels.length > 0){this.setIndexByName_[labels[0]] = 0;}var dataIdx=0;for(var i=1;i < points.length;i++) {this.setIndexByName_[labels[i]] = i;if(!this.visibility()[i - 1])continue;this.layout_.addDataset(labels[i],points[i]);this.datasetIndex_[i] = dataIdx++;}this.computeYAxisRanges_(extremes);this.layout_.setYAxes(this.axes_);this.addXTicks_(); // Save the X axis zoomed status as the updateOptions call will tend to set it erroneously
var tmp_zoomed_x=this.zoomed_x_; // Tell PlotKit to use this new data and render itself
this.zoomed_x_ = tmp_zoomed_x;this.layout_.evaluate();this.renderGraph_(is_initial_draw);if(this.getStringOption("timingName")){var end=new Date();console.log(this.getStringOption("timingName") + " - drawGraph: " + (end - start) + "ms");}}; /**
 * This does the work of drawing the chart. It assumes that the layout and axis
 * scales have already been set (e.g. by predraw_).
 *
 * @private
 */Dygraph.prototype.renderGraph_ = function(is_initial_draw){this.cascadeEvents_('clearChart');this.plotter_.clear();if(this.getFunctionOption('underlayCallback')){ // NOTE: we pass the dygraph object to this callback twice to avoid breaking
// users who expect a deprecated form of this callback.
this.getFunctionOption('underlayCallback').call(this,this.hidden_ctx_,this.layout_.getPlotArea(),this,this);}var e={canvas:this.hidden_,drawingContext:this.hidden_ctx_};this.cascadeEvents_('willDrawChart',e);this.plotter_.render();this.cascadeEvents_('didDrawChart',e);this.lastRow_ = -1; // because plugins/legend.js clears the legend
// TODO(danvk): is this a performance bottleneck when panning?
// The interaction canvas should already be empty in that situation.
this.canvas_.getContext('2d').clearRect(0,0,this.width_,this.height_);if(this.getFunctionOption("drawCallback") !== null){this.getFunctionOption("drawCallback").call(this,this,is_initial_draw);}if(is_initial_draw){this.readyFired_ = true;while(this.readyFns_.length > 0) {var fn=this.readyFns_.pop();fn(this);}}}; /**
 * @private
 * Determine properties of the y-axes which are independent of the data
 * currently being displayed. This includes things like the number of axes and
 * the style of the axes. It does not include the range of each axis and its
 * tick marks.
 * This fills in this.axes_.
 * axes_ = [ { options } ]
 *   indices are into the axes_ array.
 */Dygraph.prototype.computeYAxes_ = function(){ // Preserve valueWindow settings if they exist, and if the user hasn't
// specified a new valueRange.
var valueWindows,axis,index,opts,v;if(this.axes_ !== undefined && this.user_attrs_.hasOwnProperty("valueRange") === false){valueWindows = [];for(index = 0;index < this.axes_.length;index++) {valueWindows.push(this.axes_[index].valueWindow);}} // this.axes_ doesn't match this.attributes_.axes_.options. It's used for
// data computation as well as options storage.
// Go through once and add all the axes.
this.axes_ = [];for(axis = 0;axis < this.attributes_.numAxes();axis++) { // Add a new axis, making a copy of its per-axis options.
opts = {g:this};utils.update(opts,this.attributes_.axisOptions(axis));this.axes_[axis] = opts;} // Copy global valueRange option over to the first axis.
// NOTE(konigsberg): Are these two statements necessary?
// I tried removing it. The automated tests pass, and manually
// messing with tests/zoom.html showed no trouble.
v = this.attr_('valueRange');if(v)this.axes_[0].valueRange = v;if(valueWindows !== undefined){ // Restore valueWindow settings.
// When going from two axes back to one, we only restore
// one axis.
var idxCount=Math.min(valueWindows.length,this.axes_.length);for(index = 0;index < idxCount;index++) {this.axes_[index].valueWindow = valueWindows[index];}}for(axis = 0;axis < this.axes_.length;axis++) {if(axis === 0){opts = this.optionsViewForAxis_('y' + (axis?'2':''));v = opts("valueRange");if(v)this.axes_[axis].valueRange = v;}else { // To keep old behavior
var axes=this.user_attrs_.axes;if(axes && axes.y2){v = axes.y2.valueRange;if(v)this.axes_[axis].valueRange = v;}}}}; /**
 * Returns the number of y-axes on the chart.
 * @return {number} the number of axes.
 */Dygraph.prototype.numAxes = function(){return this.attributes_.numAxes();}; /**
 * @private
 * Returns axis properties for the given series.
 * @param {string} setName The name of the series for which to get axis
 * properties, e.g. 'Y1'.
 * @return {Object} The axis properties.
 */Dygraph.prototype.axisPropertiesForSeries = function(series){ // TODO(danvk): handle errors.
return this.axes_[this.attributes_.axisForSeries(series)];}; /**
 * @private
 * Determine the value range and tick marks for each axis.
 * @param {Object} extremes A mapping from seriesName -> [low, high]
 * This fills in the valueRange and ticks fields in each entry of this.axes_.
 */Dygraph.prototype.computeYAxisRanges_ = function(extremes){var isNullUndefinedOrNaN=function isNullUndefinedOrNaN(num){return isNaN(parseFloat(num));};var numAxes=this.attributes_.numAxes();var ypadCompat,span,series,ypad;var p_axis; // Compute extreme values, a span and tick marks for each axis.
for(var i=0;i < numAxes;i++) {var axis=this.axes_[i];var logscale=this.attributes_.getForAxis("logscale",i);var includeZero=this.attributes_.getForAxis("includeZero",i);var independentTicks=this.attributes_.getForAxis("independentTicks",i);series = this.attributes_.seriesForAxis(i); // Add some padding. This supports two Y padding operation modes:
//
// - backwards compatible (yRangePad not set):
//   10% padding for automatic Y ranges, but not for user-supplied
//   ranges, and move a close-to-zero edge to zero except if
//   avoidMinZero is set, since drawing at the edge results in
//   invisible lines. Unfortunately lines drawn at the edge of a
//   user-supplied range will still be invisible. If logscale is
//   set, add a variable amount of padding at the top but
//   none at the bottom.
//
// - new-style (yRangePad set by the user):
//   always add the specified Y padding.
//
ypadCompat = true;ypad = 0.1; // add 10%
if(this.getNumericOption('yRangePad') !== null){ypadCompat = false; // Convert pixel padding to ratio
ypad = this.getNumericOption('yRangePad') / this.plotter_.area.h;}if(series.length === 0){ // If no series are defined or visible then use a reasonable default
axis.extremeRange = [0,1];}else { // Calculate the extremes of extremes.
var minY=Infinity; // extremes[series[0]][0];
var maxY=-Infinity; // extremes[series[0]][1];
var extremeMinY,extremeMaxY;for(var j=0;j < series.length;j++) { // this skips invisible series
if(!extremes.hasOwnProperty(series[j]))continue; // Only use valid extremes to stop null data series' from corrupting the scale.
extremeMinY = extremes[series[j]][0];if(extremeMinY !== null){minY = Math.min(extremeMinY,minY);}extremeMaxY = extremes[series[j]][1];if(extremeMaxY !== null){maxY = Math.max(extremeMaxY,maxY);}} // Include zero if requested by the user.
if(includeZero && !logscale){if(minY > 0)minY = 0;if(maxY < 0)maxY = 0;} // Ensure we have a valid scale, otherwise default to [0, 1] for safety.
if(minY == Infinity)minY = 0;if(maxY == -Infinity)maxY = 1;span = maxY - minY; // special case: if we have no sense of scale, center on the sole value.
if(span === 0){if(maxY !== 0){span = Math.abs(maxY);}else { // ... and if the sole value is zero, use range 0-1.
maxY = 1;span = 1;}}var maxAxisY=maxY,minAxisY=minY;if(ypadCompat){if(logscale){maxAxisY = maxY + ypad * span;minAxisY = minY;}else {maxAxisY = maxY + ypad * span;minAxisY = minY - ypad * span; // Backwards-compatible behavior: Move the span to start or end at zero if it's
// close to zero, but not if avoidMinZero is set.
if(!this.getBooleanOption("avoidMinZero")){if(minAxisY < 0 && minY >= 0)minAxisY = 0;if(maxAxisY > 0 && maxY <= 0)maxAxisY = 0;}}}axis.extremeRange = [minAxisY,maxAxisY];}if(axis.valueWindow){ // This is only set if the user has zoomed on the y-axis. It is never set
// by a user. It takes precedence over axis.valueRange because, if you set
// valueRange, you'd still expect to be able to pan.
axis.computedValueRange = [axis.valueWindow[0],axis.valueWindow[1]];}else if(axis.valueRange){ // This is a user-set value range for this axis.
var y0=isNullUndefinedOrNaN(axis.valueRange[0])?axis.extremeRange[0]:axis.valueRange[0];var y1=isNullUndefinedOrNaN(axis.valueRange[1])?axis.extremeRange[1]:axis.valueRange[1];axis.computedValueRange = [y0,y1];}else {axis.computedValueRange = axis.extremeRange;}if(!axis.valueWindow && !ypadCompat){ // When using yRangePad, adjust the upper/lower bounds to add
// padding unless the user has zoomed/panned the Y axis range.
if(logscale){y0 = axis.computedValueRange[0];y1 = axis.computedValueRange[1];var y0pct=ypad / (2 * ypad - 1);var y1pct=(ypad - 1) / (2 * ypad - 1);axis.computedValueRange[0] = utils.logRangeFraction(y0,y1,y0pct);axis.computedValueRange[1] = utils.logRangeFraction(y0,y1,y1pct);}else {y0 = axis.computedValueRange[0];y1 = axis.computedValueRange[1];span = y1 - y0;axis.computedValueRange[0] = y0 - span * ypad;axis.computedValueRange[1] = y1 + span * ypad;}}if(independentTicks){axis.independentTicks = independentTicks;var opts=this.optionsViewForAxis_('y' + (i?'2':''));var ticker=opts('ticker');axis.ticks = ticker(axis.computedValueRange[0],axis.computedValueRange[1],this.plotter_.area.h,opts,this); // Define the first independent axis as primary axis.
if(!p_axis)p_axis = axis;}}if(p_axis === undefined){throw "Configuration Error: At least one axis has to have the \"independentTicks\" option activated.";} // Add ticks. By default, all axes inherit the tick positions of the
// primary axis. However, if an axis is specifically marked as having
// independent ticks, then that is permissible as well.
for(var i=0;i < numAxes;i++) {var axis=this.axes_[i];if(!axis.independentTicks){var opts=this.optionsViewForAxis_('y' + (i?'2':''));var ticker=opts('ticker');var p_ticks=p_axis.ticks;var p_scale=p_axis.computedValueRange[1] - p_axis.computedValueRange[0];var scale=axis.computedValueRange[1] - axis.computedValueRange[0];var tick_values=[];for(var k=0;k < p_ticks.length;k++) {var y_frac=(p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;var y_val=axis.computedValueRange[0] + y_frac * scale;tick_values.push(y_val);}axis.ticks = ticker(axis.computedValueRange[0],axis.computedValueRange[1],this.plotter_.area.h,opts,this,tick_values);}}}; /**
 * Detects the type of the str (date or numeric) and sets the various
 * formatting attributes in this.attrs_ based on this type.
 * @param {string} str An x value.
 * @private
 */Dygraph.prototype.detectTypeFromString_ = function(str){var isDate=false;var dashPos=str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2
if(dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))){isDate = true;}else if(str.length == 8 && str > '19700101' && str < '20371231'){ // TODO(danvk): remove support for this format.
isDate = true;}this.setXAxisOptions_(isDate);};Dygraph.prototype.setXAxisOptions_ = function(isDate){if(isDate){this.attrs_.xValueParser = utils.dateParser;this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;}else { /** @private (shut up, jsdoc!) */this.attrs_.xValueParser = function(x){return parseFloat(x);}; // TODO(danvk): use Dygraph.numberValueFormatter here?
/** @private (shut up, jsdoc!) */this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;}}; /**
 * @private
 * Parses a string in a special csv format.  We expect a csv file where each
 * line is a date point, and the first field in each line is the date string.
 * We also expect that all remaining fields represent series.
 * if the errorBars attribute is set, then interpret the fields as:
 * date, series1, stddev1, series2, stddev2, ...
 * @param {[Object]} data See above.
 *
 * @return [Object] An array with one entry for each row. These entries
 * are an array of cells in that row. The first entry is the parsed x-value for
 * the row. The second, third, etc. are the y-values. These can take on one of
 * three forms, depending on the CSV and constructor parameters:
 * 1. numeric value
 * 2. [ value, stddev ]
 * 3. [ low value, center value, high value ]
 */Dygraph.prototype.parseCSV_ = function(data){var ret=[];var line_delimiter=utils.detectLineDelimiter(data);var lines=data.split(line_delimiter || "\n");var vals,j; // Use the default delimiter or fall back to a tab if that makes sense.
var delim=this.getStringOption('delimiter');if(lines[0].indexOf(delim) == -1 && lines[0].indexOf('\t') >= 0){delim = '\t';}var start=0;if(!('labels' in this.user_attrs_)){ // User hasn't explicitly set labels, so they're (presumably) in the CSV.
start = 1;this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.
this.attributes_.reparseSeries();}var line_no=0;var xParser;var defaultParserSet=false; // attempt to auto-detect x value type
var expectedCols=this.attr_("labels").length;var outOfOrder=false;for(var i=start;i < lines.length;i++) {var line=lines[i];line_no = i;if(line.length === 0)continue; // skip blank lines
if(line[0] == '#')continue; // skip comment lines
var inFields=line.split(delim);if(inFields.length < 2)continue;var fields=[];if(!defaultParserSet){this.detectTypeFromString_(inFields[0]);xParser = this.getFunctionOption("xValueParser");defaultParserSet = true;}fields[0] = xParser(inFields[0],this); // If fractions are expected, parse the numbers as "A/B"
if(this.fractions_){for(j = 1;j < inFields.length;j++) { // TODO(danvk): figure out an appropriate way to flag parse errors.
vals = inFields[j].split("/");if(vals.length != 2){console.error('Expected fractional "num/den" values in CSV data ' + "but found a value '" + inFields[j] + "' on line " + (1 + i) + " ('" + line + "') which is not of this form.");fields[j] = [0,0];}else {fields[j] = [utils.parseFloat_(vals[0],i,line),utils.parseFloat_(vals[1],i,line)];}}}else if(this.getBooleanOption("errorBars")){ // If there are error bars, values are (value, stddev) pairs
if(inFields.length % 2 != 1){console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + "): '" + line + "'");}for(j = 1;j < inFields.length;j += 2) {fields[(j + 1) / 2] = [utils.parseFloat_(inFields[j],i,line),utils.parseFloat_(inFields[j + 1],i,line)];}}else if(this.getBooleanOption("customBars")){ // Bars are a low;center;high tuple
for(j = 1;j < inFields.length;j++) {var val=inFields[j];if(/^ *$/.test(val)){fields[j] = [null,null,null];}else {vals = val.split(";");if(vals.length == 3){fields[j] = [utils.parseFloat_(vals[0],i,line),utils.parseFloat_(vals[1],i,line),utils.parseFloat_(vals[2],i,line)];}else {console.warn('When using customBars, values must be either blank ' + 'or "low;center;high" tuples (got "' + val + '" on line ' + (1 + i));}}}}else { // Values are just numbers
for(j = 1;j < inFields.length;j++) {fields[j] = utils.parseFloat_(inFields[j],i,line);}}if(ret.length > 0 && fields[0] < ret[ret.length - 1][0]){outOfOrder = true;}if(fields.length != expectedCols){console.error("Number of columns in line " + i + " (" + fields.length + ") does not agree with number of labels (" + expectedCols + ") " + line);} // If the user specified the 'labels' option and none of the cells of the
// first row parsed correctly, then they probably double-specified the
// labels. We go with the values set in the option, discard this row and
// log a warning to the JS console.
if(i === 0 && this.attr_('labels')){var all_null=true;for(j = 0;all_null && j < fields.length;j++) {if(fields[j])all_null = false;}if(all_null){console.warn("The dygraphs 'labels' option is set, but the first row " + "of CSV data ('" + line + "') appears to also contain " + "labels. Will drop the CSV labels and use the option " + "labels.");continue;}}ret.push(fields);}if(outOfOrder){console.warn("CSV is out of order; order it correctly to speed loading.");ret.sort(function(a,b){return a[0] - b[0];});}return ret;}; /**
 * The user has provided their data as a pre-packaged JS array. If the x values
 * are numeric, this is the same as dygraphs' internal format. If the x values
 * are dates, we need to convert them from Date objects to ms since epoch.
 * @param {!Array} data
 * @return {Object} data with numeric x values.
 * @private
 */Dygraph.prototype.parseArray_ = function(data){ // Peek at the first x value to see if it's numeric.
if(data.length === 0){console.error("Can't plot empty data set");return null;}if(data[0].length === 0){console.error("Data set cannot contain an empty row");return null;}var i;if(this.attr_("labels") === null){console.warn("Using default labels. Set labels explicitly via 'labels' " + "in the options parameter");this.attrs_.labels = ["X"];for(i = 1;i < data[0].length;i++) {this.attrs_.labels.push("Y" + i); // Not user_attrs_.
}this.attributes_.reparseSeries();}else {var num_labels=this.attr_("labels");if(num_labels.length != data[0].length){console.error("Mismatch between number of labels (" + num_labels + ")" + " and number of columns in array (" + data[0].length + ")");return null;}}if(utils.isDateLike(data[0][0])){ // Some intelligent defaults for a date x-axis.
this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter; // Assume they're all dates.
var parsedData=utils.clone(data);for(i = 0;i < data.length;i++) {if(parsedData[i].length === 0){console.error("Row " + (1 + i) + " of data is empty");return null;}if(parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())){console.error("x value in row " + (1 + i) + " is not a Date");return null;}parsedData[i][0] = parsedData[i][0].getTime();}return parsedData;}else { // Some intelligent defaults for a numeric x-axis.
/** @private (shut up, jsdoc!) */this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = utils.numberAxisLabelFormatter;return data;}}; /**
 * Parses a DataTable object from gviz.
 * The data is expected to have a first column that is either a date or a
 * number. All subsequent columns must be numbers. If there is a clear mismatch
 * between this.xValueParser_ and the type of the first column, it will be
 * fixed. Fills out rawData_.
 * @param {!google.visualization.DataTable} data See above.
 * @private
 */Dygraph.prototype.parseDataTable_ = function(data){var shortTextForAnnotationNum=function shortTextForAnnotationNum(num){ // converts [0-9]+ [A-Z][a-z]*
// example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab
// and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz
var shortText=String.fromCharCode(65 /* A */ + num % 26);num = Math.floor(num / 26);while(num > 0) {shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26) + shortText.toLowerCase();num = Math.floor((num - 1) / 26);}return shortText;};var cols=data.getNumberOfColumns();var rows=data.getNumberOfRows();var indepType=data.getColumnType(0);if(indepType == 'date' || indepType == 'datetime'){this.attrs_.xValueParser = utils.dateParser;this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;}else if(indepType == 'number'){this.attrs_.xValueParser = function(x){return parseFloat(x);};this.attrs_.axes.x.valueFormatter = function(x){return x;};this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;}else {throw new Error("only 'date', 'datetime' and 'number' types are supported " + "for column 1 of DataTable input (Got '" + indepType + "')");} // Array of the column indices which contain data (and not annotations).
var colIdx=[];var annotationCols={}; // data index -> [annotation cols]
var hasAnnotations=false;var i,j;for(i = 1;i < cols;i++) {var type=data.getColumnType(i);if(type == 'number'){colIdx.push(i);}else if(type == 'string' && this.getBooleanOption('displayAnnotations')){ // This is OK -- it's an annotation column.
var dataIdx=colIdx[colIdx.length - 1];if(!annotationCols.hasOwnProperty(dataIdx)){annotationCols[dataIdx] = [i];}else {annotationCols[dataIdx].push(i);}hasAnnotations = true;}else {throw new Error("Only 'number' is supported as a dependent type with Gviz." + " 'string' is only supported if displayAnnotations is true");}} // Read column labels
// TODO(danvk): add support back for errorBars
var labels=[data.getColumnLabel(0)];for(i = 0;i < colIdx.length;i++) {labels.push(data.getColumnLabel(colIdx[i]));if(this.getBooleanOption("errorBars"))i += 1;}this.attrs_.labels = labels;cols = labels.length;var ret=[];var outOfOrder=false;var annotations=[];for(i = 0;i < rows;i++) {var row=[];if(typeof data.getValue(i,0) === 'undefined' || data.getValue(i,0) === null){console.warn("Ignoring row " + i + " of DataTable because of undefined or null first column.");continue;}if(indepType == 'date' || indepType == 'datetime'){row.push(data.getValue(i,0).getTime());}else {row.push(data.getValue(i,0));}if(!this.getBooleanOption("errorBars")){for(j = 0;j < colIdx.length;j++) {var col=colIdx[j];row.push(data.getValue(i,col));if(hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i,annotationCols[col][0]) !== null){var ann={};ann.series = data.getColumnLabel(col);ann.xval = row[0];ann.shortText = shortTextForAnnotationNum(annotations.length);ann.text = '';for(var k=0;k < annotationCols[col].length;k++) {if(k)ann.text += "\n";ann.text += data.getValue(i,annotationCols[col][k]);}annotations.push(ann);}} // Strip out infinities, which give dygraphs problems later on.
for(j = 0;j < row.length;j++) {if(!isFinite(row[j]))row[j] = null;}}else {for(j = 0;j < cols - 1;j++) {row.push([data.getValue(i,1 + 2 * j),data.getValue(i,2 + 2 * j)]);}}if(ret.length > 0 && row[0] < ret[ret.length - 1][0]){outOfOrder = true;}ret.push(row);}if(outOfOrder){console.warn("DataTable is out of order; order it correctly to speed loading.");ret.sort(function(a,b){return a[0] - b[0];});}this.rawData_ = ret;if(annotations.length > 0){this.setAnnotations(annotations,true);}this.attributes_.reparseSeries();}; /**
 * Signals to plugins that the chart data has updated.
 * This happens after the data has updated but before the chart has redrawn.
 */Dygraph.prototype.cascadeDataDidUpdateEvent_ = function(){ // TODO(danvk): there are some issues checking xAxisRange() and using
// toDomCoords from handlers of this event. The visible range should be set
// when the chart is drawn, not derived from the data.
this.cascadeEvents_('dataDidUpdate',{});}; /**
 * Get the CSV data. If it's in a function, call that function. If it's in a
 * file, do an XMLHttpRequest to get it.
 * @private
 */Dygraph.prototype.start_ = function(){var data=this.file_; // Functions can return references of all other types.
if(typeof data == 'function'){data = data();}if(utils.isArrayLike(data)){this.rawData_ = this.parseArray_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}else if(typeof data == 'object' && typeof data.getColumnRange == 'function'){ // must be a DataTable from gviz.
this.parseDataTable_(data);this.cascadeDataDidUpdateEvent_();this.predraw_();}else if(typeof data == 'string'){ // Heuristic: a newline means it's CSV data. Otherwise it's an URL.
var line_delimiter=utils.detectLineDelimiter(data);if(line_delimiter){this.loadedEvent_(data);}else { // REMOVE_FOR_IE
var req;if(window.XMLHttpRequest){ // Firefox, Opera, IE7, and other browsers will use the native object
req = new XMLHttpRequest();}else { // IE 5 and 6 will use the ActiveX control
req = new ActiveXObject("Microsoft.XMLHTTP");}var caller=this;req.onreadystatechange = function(){if(req.readyState == 4){if(req.status === 200 ||  // Normal http
req.status === 0){ // Chrome w/ --allow-file-access-from-files
caller.loadedEvent_(req.responseText);}}};req.open("GET",data,true);req.send(null);}}else {console.error("Unknown data format: " + typeof data);}}; /**
 * Changes various properties of the graph. These can include:
 * <ul>
 * <li>file: changes the source data for the graph</li>
 * <li>errorBars: changes whether the data contains stddev</li>
 * </ul>
 *
 * There's a huge variety of options that can be passed to this method. For a
 * full list, see http://dygraphs.com/options.html.
 *
 * @param {Object} input_attrs The new properties and values
 * @param {boolean} block_redraw Usually the chart is redrawn after every
 *     call to updateOptions(). If you know better, you can pass true to
 *     explicitly block the redraw. This can be useful for chaining
 *     updateOptions() calls, avoiding the occasional infinite loop and
 *     preventing redraws when it's not necessary (e.g. when updating a
 *     callback).
 */Dygraph.prototype.updateOptions = function(input_attrs,block_redraw){if(typeof block_redraw == 'undefined')block_redraw = false; // copyUserAttrs_ drops the "file" parameter as a convenience to us.
var file=input_attrs.file;var attrs=Dygraph.copyUserAttrs_(input_attrs); // TODO(danvk): this is a mess. Move these options into attr_.
if('rollPeriod' in attrs){this.rollPeriod_ = attrs.rollPeriod;}if('dateWindow' in attrs){this.dateWindow_ = attrs.dateWindow;if(!('isZoomedIgnoreProgrammaticZoom' in attrs)){this.zoomed_x_ = attrs.dateWindow !== null;}}if('valueRange' in attrs && !('isZoomedIgnoreProgrammaticZoom' in attrs)){this.zoomed_y_ = attrs.valueRange !== null;} // TODO(danvk): validate per-series options.
// Supported:
// strokeWidth
// pointSize
// drawPoints
// highlightCircleSize
// Check if this set options will require new points.
var requiresNewPoints=utils.isPixelChangingOptionList(this.attr_("labels"),attrs);utils.updateDeep(this.user_attrs_,attrs);this.attributes_.reparseSeries();if(file){ // This event indicates that the data is about to change, but hasn't yet.
// TODO(danvk): support cancelation of the update via this event.
this.cascadeEvents_('dataWillUpdate',{});this.file_ = file;if(!block_redraw)this.start_();}else {if(!block_redraw){if(requiresNewPoints){this.predraw_();}else {this.renderGraph_(false);}}}}; /**
 * Make a copy of input attributes, removing file as a convenience.
 */Dygraph.copyUserAttrs_ = function(attrs){var my_attrs={};for(var k in attrs) {if(!attrs.hasOwnProperty(k))continue;if(k == 'file')continue;if(attrs.hasOwnProperty(k))my_attrs[k] = attrs[k];}return my_attrs;}; /**
 * Resizes the dygraph. If no parameters are specified, resizes to fill the
 * containing div (which has presumably changed size since the dygraph was
 * instantiated. If the width/height are specified, the div will be resized.
 *
 * This is far more efficient than destroying and re-instantiating a
 * Dygraph, since it doesn't have to reparse the underlying data.
 *
 * @param {number} width Width (in pixels)
 * @param {number} height Height (in pixels)
 */Dygraph.prototype.resize = function(width,height){if(this.resize_lock){return;}this.resize_lock = true;if(width === null != (height === null)){console.warn("Dygraph.resize() should be called with zero parameters or " + "two non-NULL parameters. Pretending it was zero.");width = height = null;}var old_width=this.width_;var old_height=this.height_;if(width){this.maindiv_.style.width = width + "px";this.maindiv_.style.height = height + "px";this.width_ = width;this.height_ = height;}else {this.width_ = this.maindiv_.clientWidth;this.height_ = this.maindiv_.clientHeight;}if(old_width != this.width_ || old_height != this.height_){ // Resizing a canvas erases it, even when the size doesn't change, so
// any resize needs to be followed by a redraw.
this.resizeElements_();this.predraw_();}this.resize_lock = false;}; /**
 * Adjusts the number of points in the rolling average. Updates the graph to
 * reflect the new averaging period.
 * @param {number} length Number of points over which to average the data.
 */Dygraph.prototype.adjustRoll = function(length){this.rollPeriod_ = length;this.predraw_();}; /**
 * Returns a boolean array of visibility statuses.
 */Dygraph.prototype.visibility = function(){ // Do lazy-initialization, so that this happens after we know the number of
// data series.
if(!this.getOption("visibility")){this.attrs_.visibility = [];} // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.
while(this.getOption("visibility").length < this.numColumns() - 1) {this.attrs_.visibility.push(true);}return this.getOption("visibility");}; /**
 * Changes the visibility of one or more series.
 *
 * @param {number|number[]|object} num the series index or an array of series indices
 *                                     or a boolean array of visibility states by index
 *                                     or an object mapping series numbers, as keys, to 
 *                                     visibility state (boolean values)
 * @param {boolean} value the visibility state expressed as a boolean
 */Dygraph.prototype.setVisibility = function(num,value){var x=this.visibility();var numIsObject=false;if(!Array.isArray(num)){if(num !== null && typeof num === 'object'){numIsObject = true;}else {num = [num];}}if(numIsObject){for(var i in num) {if(num.hasOwnProperty(i)){if(i < 0 || i >= x.length){console.warn("Invalid series number in setVisibility: " + i);}else {x[i] = num[i];}}}}else {for(var i=0;i < num.length;i++) {if(typeof num[i] === 'boolean'){if(i >= x.length){console.warn("Invalid series number in setVisibility: " + i);}else {x[i] = num[i];}}else {if(num[i] < 0 || num[i] >= x.length){console.warn("Invalid series number in setVisibility: " + num[i]);}else {x[num[i]] = value;}}}}this.predraw_();}; /**
 * How large of an area will the dygraph render itself in?
 * This is used for testing.
 * @return A {width: w, height: h} object.
 * @private
 */Dygraph.prototype.size = function(){return {width:this.width_,height:this.height_};}; /**
 * Update the list of annotations and redraw the chart.
 * See dygraphs.com/annotations.html for more info on how to use annotations.
 * @param ann {Array} An array of annotation objects.
 * @param suppressDraw {Boolean} Set to "true" to block chart redraw (optional).
 */Dygraph.prototype.setAnnotations = function(ann,suppressDraw){ // Only add the annotation CSS rule once we know it will be used.
Dygraph.addAnnotationRule();this.annotations_ = ann;if(!this.layout_){console.warn("Tried to setAnnotations before dygraph was ready. " + "Try setting them in a ready() block. See " + "dygraphs.com/tests/annotation.html");return;}this.layout_.setAnnotations(this.annotations_);if(!suppressDraw){this.predraw_();}}; /**
 * Return the list of annotations.
 */Dygraph.prototype.annotations = function(){return this.annotations_;}; /**
 * Get the list of label names for this graph. The first column is the
 * x-axis, so the data series names start at index 1.
 *
 * Returns null when labels have not yet been defined.
 */Dygraph.prototype.getLabels = function(){var labels=this.attr_("labels");return labels?labels.slice():null;}; /**
 * Get the index of a series (column) given its name. The first column is the
 * x-axis, so the data series start with index 1.
 */Dygraph.prototype.indexFromSetName = function(name){return this.setIndexByName_[name];}; /**
 * Find the row number corresponding to the given x-value.
 * Returns null if there is no such x-value in the data.
 * If there are multiple rows with the same x-value, this will return the
 * first one.
 * @param {number} xVal The x-value to look for (e.g. millis since epoch).
 * @return {?number} The row number, which you can pass to getValue(), or null.
 */Dygraph.prototype.getRowForX = function(xVal){var low=0,high=this.numRows() - 1;while(low <= high) {var idx=high + low >> 1;var x=this.getValue(idx,0);if(x < xVal){low = idx + 1;}else if(x > xVal){high = idx - 1;}else if(low != idx){ // equal, but there may be an earlier match.
high = idx;}else {return idx;}}return null;}; /**
 * Trigger a callback when the dygraph has drawn itself and is ready to be
 * manipulated. This is primarily useful when dygraphs has to do an XHR for the
 * data (i.e. a URL is passed as the data source) and the chart is drawn
 * asynchronously. If the chart has already drawn, the callback will fire
 * immediately.
 *
 * This is a good place to call setAnnotation().
 *
 * @param {function(!Dygraph)} callback The callback to trigger when the chart
 *     is ready.
 */Dygraph.prototype.ready = function(callback){if(this.is_initial_draw_){this.readyFns_.push(callback);}else {callback.call(this,this);}}; /**
 * @private
 * Adds a default style for the annotation CSS classes to the document. This is
 * only executed when annotations are actually used. It is designed to only be
 * called once -- all calls after the first will return immediately.
 */Dygraph.addAnnotationRule = function(){ // TODO(danvk): move this function into plugins/annotations.js?
if(Dygraph.addedAnnotationCSS)return;var rule="border: 1px solid black; " + "background-color: white; " + "text-align: center;";var styleSheetElement=document.createElement("style");styleSheetElement.type = "text/css";document.getElementsByTagName("head")[0].appendChild(styleSheetElement); // Find the first style sheet that we can access.
// We may not add a rule to a style sheet from another domain for security
// reasons. This sometimes comes up when using gviz, since the Google gviz JS
// adds its own style sheets from google.com.
for(var i=0;i < document.styleSheets.length;i++) {if(document.styleSheets[i].disabled)continue;var mysheet=document.styleSheets[i];try{if(mysheet.insertRule){ // Firefox
var idx=mysheet.cssRules?mysheet.cssRules.length:0;mysheet.insertRule(".dygraphDefaultAnnotation { " + rule + " }",idx);}else if(mysheet.addRule){ // IE
mysheet.addRule(".dygraphDefaultAnnotation",rule);}Dygraph.addedAnnotationCSS = true;return;}catch(err) { // Was likely a security exception.
}}console.warn("Unable to add default annotation CSS rule; display may be off.");}; /**
 * Add an event handler. This event handler is kept until the graph is
 * destroyed with a call to graph.destroy().
 *
 * @param {!Node} elem The element to add the event to.
 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
 * @param {function(Event):(boolean|undefined)} fn The function to call
 *     on the event. The function takes one parameter: the event object.
 * @private
 */Dygraph.prototype.addAndTrackEvent = function(elem,type,fn){utils.addEvent(elem,type,fn);this.registeredEvents_.push({elem:elem,type:type,fn:fn});};Dygraph.prototype.removeTrackedEvents_ = function(){if(this.registeredEvents_){for(var idx=0;idx < this.registeredEvents_.length;idx++) {var reg=this.registeredEvents_[idx];utils.removeEvent(reg.elem,reg.type,reg.fn);}}this.registeredEvents_ = [];}; // Installed plugins, in order of precedence (most-general to most-specific).
Dygraph.PLUGINS = [_pluginsLegend2['default'],_pluginsAxes2['default'],_pluginsRangeSelector2['default'], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.
_pluginsChartLabels2['default'],_pluginsAnnotations2['default'],_pluginsGrid2['default']]; // There are many symbols which have historically been available through the
// Dygraph class. These are exported here for backwards compatibility.
Dygraph.GVizChart = _dygraphGviz2['default'];Dygraph.DASHED_LINE = utils.DASHED_LINE;Dygraph.DOT_DASH_LINE = utils.DOT_DASH_LINE;Dygraph.dateAxisLabelFormatter = utils.dateAxisLabelFormatter;Dygraph.toRGB_ = utils.toRGB_;Dygraph.findPos = utils.findPos;Dygraph.pageX = utils.pageX;Dygraph.pageY = utils.pageY;Dygraph.dateString_ = utils.dateString_;Dygraph.defaultInteractionModel = _dygraphInteractionModel2['default'].defaultModel;Dygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = _dygraphInteractionModel2['default'].nonInteractiveModel_;Dygraph.Circles = utils.Circles;Dygraph.Plugins = {Legend:_pluginsLegend2['default'],Axes:_pluginsAxes2['default'],Annotations:_pluginsAnnotations2['default'],ChartLabels:_pluginsChartLabels2['default'],Grid:_pluginsGrid2['default'],RangeSelector:_pluginsRangeSelector2['default']};Dygraph.DataHandlers = {DefaultHandler:_datahandlerDefault2['default'],BarsHandler:_datahandlerBars2['default'],CustomBarsHandler:_datahandlerBarsCustom2['default'],DefaultFractionHandler:_datahandlerDefaultFractions2['default'],ErrorBarsHandler:_datahandlerBarsError2['default'],FractionsBarsHandler:_datahandlerBarsFractions2['default']};Dygraph.startPan = _dygraphInteractionModel2['default'].startPan;Dygraph.startZoom = _dygraphInteractionModel2['default'].startZoom;Dygraph.movePan = _dygraphInteractionModel2['default'].movePan;Dygraph.moveZoom = _dygraphInteractionModel2['default'].moveZoom;Dygraph.endPan = _dygraphInteractionModel2['default'].endPan;Dygraph.endZoom = _dygraphInteractionModel2['default'].endZoom;Dygraph.numericLinearTicks = DygraphTickers.numericLinearTicks;Dygraph.numericTicks = DygraphTickers.numericTicks;Dygraph.dateTicker = DygraphTickers.dateTicker;Dygraph.Granularity = DygraphTickers.Granularity;Dygraph.getDateAxis = DygraphTickers.getDateAxis;Dygraph.floatFormat = utils.floatFormat;exports['default'] = Dygraph;module.exports = exports['default'];

},{"./datahandler/bars":4,"./datahandler/bars-custom":1,"./datahandler/bars-error":2,"./datahandler/bars-fractions":3,"./datahandler/default":7,"./datahandler/default-fractions":6,"./dygraph-canvas":8,"./dygraph-default-attrs":9,"./dygraph-gviz":10,"./dygraph-interaction-model":11,"./dygraph-layout":12,"./dygraph-options":14,"./dygraph-options-reference":13,"./dygraph-tickers":15,"./dygraph-utils":16,"./iframe-tarp":18,"./plugins/annotations":19,"./plugins/axes":20,"./plugins/chart-labels":21,"./plugins/grid":22,"./plugins/legend":23,"./plugins/range-selector":24}],18:[function(require,module,exports){
/**
 * To create a "drag" interaction, you typically register a mousedown event
 * handler on the element where the drag begins. In that handler, you register a
 * mouseup handler on the window to determine when the mouse is released,
 * wherever that release happens. This works well, except when the user releases
 * the mouse over an off-domain iframe. In that case, the mouseup event is
 * handled by the iframe and never bubbles up to the window handler.
 *
 * To deal with this issue, we cover iframes with high z-index divs to make sure
 * they don't capture mouseup.
 *
 * Usage:
 * element.addEventListener('mousedown', function() {
 *   var tarper = new IFrameTarp();
 *   tarper.cover();
 *   var mouseUpHandler = function() {
 *     ...
 *     window.removeEventListener(mouseUpHandler);
 *     tarper.uncover();
 *   };
 *   window.addEventListener('mouseup', mouseUpHandler);
 * };
 *
 * @constructor
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('./dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

function IFrameTarp() {
  /** @type {Array.<!HTMLDivElement>} */
  this.tarps = [];
};

/**
 * Find all the iframes in the document and cover them with high z-index
 * transparent divs.
 */
IFrameTarp.prototype.cover = function () {
  var iframes = document.getElementsByTagName("iframe");
  for (var i = 0; i < iframes.length; i++) {
    var iframe = iframes[i];
    var pos = utils.findPos(iframe),
        x = pos.x,
        y = pos.y,
        width = iframe.offsetWidth,
        height = iframe.offsetHeight;

    var div = document.createElement("div");
    div.style.position = "absolute";
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    div.style.width = width + 'px';
    div.style.height = height + 'px';
    div.style.zIndex = 999;
    document.body.appendChild(div);
    this.tarps.push(div);
  }
};

/**
 * Remove all the iframe covers. You should call this in a mouseup handler.
 */
IFrameTarp.prototype.uncover = function () {
  for (var i = 0; i < this.tarps.length; i++) {
    this.tarps[i].parentNode.removeChild(this.tarps[i]);
  }
  this.tarps = [];
};

exports["default"] = IFrameTarp;
module.exports = exports["default"];

},{"./dygraph-utils":16}],19:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/*global Dygraph:false */

"use strict";

/**
Current bits of jankiness:
- Uses dygraph.layout_ to get the parsed annotations.
- Uses dygraph.plotter_.area

It would be nice if the plugin didn't require so much special support inside
the core dygraphs classes, but annotations involve quite a bit of parsing and
layout.

TODO(danvk): cache DOM elements.
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var annotations = function annotations() {
  this.annotations_ = [];
};

annotations.prototype.toString = function () {
  return "Annotations Plugin";
};

annotations.prototype.activate = function (g) {
  return {
    clearChart: this.clearChart,
    didDrawChart: this.didDrawChart
  };
};

annotations.prototype.detachLabels = function () {
  for (var i = 0; i < this.annotations_.length; i++) {
    var a = this.annotations_[i];
    if (a.parentNode) a.parentNode.removeChild(a);
    this.annotations_[i] = null;
  }
  this.annotations_ = [];
};

annotations.prototype.clearChart = function (e) {
  this.detachLabels();
};

annotations.prototype.didDrawChart = function (e) {
  var g = e.dygraph;

  // Early out in the (common) case of zero annotations.
  var points = g.layout_.annotated_points;
  if (!points || points.length === 0) return;

  var containerDiv = e.canvas.parentNode;
  var annotationStyle = {
    "position": "absolute",
    "fontSize": g.getOption('axisLabelFontSize') + "px",
    "zIndex": 10,
    "overflow": "hidden"
  };

  var bindEvt = function bindEvt(eventName, classEventName, pt) {
    return function (annotation_event) {
      var a = pt.annotation;
      if (a.hasOwnProperty(eventName)) {
        a[eventName](a, pt, g, annotation_event);
      } else if (g.getOption(classEventName)) {
        g.getOption(classEventName)(a, pt, g, annotation_event);
      }
    };
  };

  // Add the annotations one-by-one.
  var area = e.dygraph.plotter_.area;

  // x-coord to sum of previous annotation's heights (used for stacking).
  var xToUsedHeight = {};

  for (var i = 0; i < points.length; i++) {
    var p = points[i];
    if (p.canvasx < area.x || p.canvasx > area.x + area.w || p.canvasy < area.y || p.canvasy > area.y + area.h) {
      continue;
    }

    var a = p.annotation;
    var tick_height = 6;
    if (a.hasOwnProperty("tickHeight")) {
      tick_height = a.tickHeight;
    }

    var div = document.createElement("div");
    for (var name in annotationStyle) {
      if (annotationStyle.hasOwnProperty(name)) {
        div.style[name] = annotationStyle[name];
      }
    }
    if (!a.hasOwnProperty('icon')) {
      div.className = "dygraphDefaultAnnotation";
    }
    if (a.hasOwnProperty('cssClass')) {
      div.className += " " + a.cssClass;
    }

    var width = a.hasOwnProperty('width') ? a.width : 16;
    var height = a.hasOwnProperty('height') ? a.height : 16;
    if (a.hasOwnProperty('icon')) {
      var img = document.createElement("img");
      img.src = a.icon;
      img.width = width;
      img.height = height;
      div.appendChild(img);
    } else if (p.annotation.hasOwnProperty('shortText')) {
      div.appendChild(document.createTextNode(p.annotation.shortText));
    }
    var left = p.canvasx - width / 2;
    div.style.left = left + "px";
    var divTop = 0;
    if (a.attachAtBottom) {
      var y = area.y + area.h - height - tick_height;
      if (xToUsedHeight[left]) {
        y -= xToUsedHeight[left];
      } else {
        xToUsedHeight[left] = 0;
      }
      xToUsedHeight[left] += tick_height + height;
      divTop = y;
    } else {
      divTop = p.canvasy - height - tick_height;
    }
    div.style.top = divTop + "px";
    div.style.width = width + "px";
    div.style.height = height + "px";
    div.title = p.annotation.text;
    div.style.color = g.colorsMap_[p.name];
    div.style.borderColor = g.colorsMap_[p.name];
    a.div = div;

    g.addAndTrackEvent(div, 'click', bindEvt('clickHandler', 'annotationClickHandler', p, this));
    g.addAndTrackEvent(div, 'mouseover', bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));
    g.addAndTrackEvent(div, 'mouseout', bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));
    g.addAndTrackEvent(div, 'dblclick', bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));

    containerDiv.appendChild(div);
    this.annotations_.push(div);

    var ctx = e.drawingContext;
    ctx.save();
    ctx.strokeStyle = g.colorsMap_[p.name];
    ctx.beginPath();
    if (!a.attachAtBottom) {
      ctx.moveTo(p.canvasx, p.canvasy);
      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);
    } else {
      var y = divTop + height;
      ctx.moveTo(p.canvasx, y);
      ctx.lineTo(p.canvasx, y + tick_height);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
};

annotations.prototype.destroy = function () {
  this.detachLabels();
};

exports["default"] = annotations;
module.exports = exports["default"];

},{}],20:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */

/*global Dygraph:false */

'use strict';

/*
Bits of jankiness:
- Direct layout access
- Direct area access
- Should include calculation of ticks, not just the drawing.

Options left to make axis-friendly.
  ('drawAxesAtZero')
  ('xAxisHeight')
*/

/**
 * Draws the axes. This includes the labels on the x- and y-axes, as well
 * as the tick marks on the axes.
 * It does _not_ draw the grid lines which span the entire chart.
 */
Object.defineProperty(exports, '__esModule', {
  value: true
});
var axes = function axes() {
  this.xlabels_ = [];
  this.ylabels_ = [];
};

axes.prototype.toString = function () {
  return 'Axes Plugin';
};

axes.prototype.activate = function (g) {
  return {
    layout: this.layout,
    clearChart: this.clearChart,
    willDrawChart: this.willDrawChart
  };
};

axes.prototype.layout = function (e) {
  var g = e.dygraph;

  if (g.getOptionForAxis('drawAxis', 'y')) {
    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');
    e.reserveSpaceLeft(w);
  }

  if (g.getOptionForAxis('drawAxis', 'x')) {
    var h;
    // NOTE: I think this is probably broken now, since g.getOption() now
    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always
    // has a value.)
    if (g.getOption('xAxisHeight')) {
      h = g.getOption('xAxisHeight');
    } else {
      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');
    }
    e.reserveSpaceBottom(h);
  }

  if (g.numAxes() == 2) {
    if (g.getOptionForAxis('drawAxis', 'y2')) {
      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');
      e.reserveSpaceRight(w);
    }
  } else if (g.numAxes() > 2) {
    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');
  }
};

axes.prototype.detachLabels = function () {
  function removeArray(ary) {
    for (var i = 0; i < ary.length; i++) {
      var el = ary[i];
      if (el.parentNode) el.parentNode.removeChild(el);
    }
  }

  removeArray(this.xlabels_);
  removeArray(this.ylabels_);
  this.xlabels_ = [];
  this.ylabels_ = [];
};

axes.prototype.clearChart = function (e) {
  this.detachLabels();
};

axes.prototype.willDrawChart = function (e) {
  var g = e.dygraph;

  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {
    return;
  }

  // Round pixels to half-integer boundaries for crisper drawing.
  function halfUp(x) {
    return Math.round(x) + 0.5;
  }
  function halfDown(y) {
    return Math.round(y) - 0.5;
  }

  var context = e.drawingContext;
  var containerDiv = e.canvas.parentNode;
  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.
  var canvasHeight = g.height_;

  var label, x, y, tick, i;

  var makeLabelStyle = function makeLabelStyle(axis) {
    return {
      position: 'absolute',
      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',
      zIndex: 10,
      color: g.getOptionForAxis('axisLabelColor', axis),
      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px',
      // height: g.getOptionForAxis('axisLabelFontSize', 'x') + 2 + "px",
      lineHeight: 'normal', // Something other than "normal" line-height screws up label positioning.
      overflow: 'hidden'
    };
  };

  var labelStyles = {
    x: makeLabelStyle('x'),
    y: makeLabelStyle('y'),
    y2: makeLabelStyle('y2')
  };

  var makeDiv = function makeDiv(txt, axis, prec_axis) {
    /*
     * This seems to be called with the following three sets of axis/prec_axis:
     * x: undefined
     * y: y1
     * y: y2
     */
    var div = document.createElement('div');
    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];
    for (var name in labelStyle) {
      if (labelStyle.hasOwnProperty(name)) {
        div.style[name] = labelStyle[name];
      }
    }
    var inner_div = document.createElement('div');
    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');
    inner_div.innerHTML = txt;
    div.appendChild(inner_div);
    return div;
  };

  // axis lines
  context.save();

  var layout = g.layout_;
  var area = e.dygraph.plotter_.area;

  // Helper for repeated axis-option accesses.
  var makeOptionGetter = function makeOptionGetter(axis) {
    return function (option) {
      return g.getOptionForAxis(option, axis);
    };
  };

  if (g.getOptionForAxis('drawAxis', 'y')) {
    if (layout.yticks && layout.yticks.length > 0) {
      var num_axes = g.numAxes();
      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = layout.yticks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tick = _step.value;

          if (tick.label === undefined) continue; // this tick only has a grid line.
          x = area.x;
          var sgn = 1;
          var prec_axis = 'y1';
          var getAxisOption = getOptions[0];
          if (tick.axis == 1) {
            // right-side y-axis
            x = area.x + area.w;
            sgn = -1;
            prec_axis = 'y2';
            getAxisOption = getOptions[1];
          }
          var fontSize = getAxisOption('axisLabelFontSize');
          y = area.y + tick.pos * area.h;

          /* Tick marks are currently clipped, so don't bother drawing them.
          context.beginPath();
          context.moveTo(halfUp(x), halfDown(y));
          context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));
          context.closePath();
          context.stroke();
          */

          label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);
          var top = y - fontSize / 2;
          if (top < 0) top = 0;

          if (top + fontSize + 3 > canvasHeight) {
            label.style.bottom = '0';
          } else {
            label.style.top = top + 'px';
          }
          if (tick.axis === 0) {
            label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';
            label.style.textAlign = 'right';
          } else if (tick.axis == 1) {
            label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';
            label.style.textAlign = 'left';
          }
          label.style.width = getAxisOption('axisLabelWidth') + 'px';
          containerDiv.appendChild(label);
          this.ylabels_.push(label);
        }

        // The lowest tick on the y-axis often overlaps with the leftmost
        // tick on the x-axis. Shift the bottom tick up a little bit to
        // compensate if necessary.
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var bottomTick = this.ylabels_[0];
      // Interested in the y2 axis also?
      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');
      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;
      if (bottom > canvasHeight - fontSize) {
        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';
      }
    }

    // draw a vertical line on the left to separate the chart from the labels.
    var axisX;
    if (g.getOption('drawAxesAtZero')) {
      var r = g.toPercentXCoord(0);
      if (r > 1 || r < 0 || isNaN(r)) r = 0;
      axisX = halfUp(area.x + r * area.w);
    } else {
      axisX = halfUp(area.x);
    }

    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');
    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');

    context.beginPath();
    context.moveTo(axisX, halfDown(area.y));
    context.lineTo(axisX, halfDown(area.y + area.h));
    context.closePath();
    context.stroke();

    // if there's a secondary y-axis, draw a vertical line for that, too.
    if (g.numAxes() == 2) {
      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');
      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');
      context.beginPath();
      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));
      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));
      context.closePath();
      context.stroke();
    }
  }

  if (g.getOptionForAxis('drawAxis', 'x')) {
    if (layout.xticks) {
      var getAxisOption = makeOptionGetter('x');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = layout.xticks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var tick = _step2.value;

          if (tick.label === undefined) continue; // this tick only has a grid line.
          x = area.x + tick.pos * area.w;
          y = area.y + area.h;

          /* Tick marks are currently clipped, so don't bother drawing them.
          context.beginPath();
          context.moveTo(halfUp(x), halfDown(y));
          context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));
          context.closePath();
          context.stroke();
          */

          label = makeDiv(tick.label, 'x');
          label.style.textAlign = 'center';
          label.style.top = y + getAxisOption('axisTickSize') + 'px';

          var left = x - getAxisOption('axisLabelWidth') / 2;
          if (left + getAxisOption('axisLabelWidth') > canvasWidth) {
            left = canvasWidth - getAxisOption('axisLabelWidth');
            label.style.textAlign = 'right';
          }
          if (left < 0) {
            left = 0;
            label.style.textAlign = 'left';
          }

          label.style.left = left + 'px';
          label.style.width = getAxisOption('axisLabelWidth') + 'px';
          containerDiv.appendChild(label);
          this.xlabels_.push(label);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');
    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');
    context.beginPath();
    var axisY;
    if (g.getOption('drawAxesAtZero')) {
      var r = g.toPercentYCoord(0, 0);
      if (r > 1 || r < 0) r = 1;
      axisY = halfDown(area.y + r * area.h);
    } else {
      axisY = halfDown(area.y + area.h);
    }
    context.moveTo(halfUp(area.x), axisY);
    context.lineTo(halfUp(area.x + area.w), axisY);
    context.closePath();
    context.stroke();
  }

  context.restore();
};

exports['default'] = axes;
module.exports = exports['default'];

},{}],21:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

"use strict";

// TODO(danvk): move chart label options out of dygraphs and into the plugin.
// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.

Object.defineProperty(exports, "__esModule", {
  value: true
});
var chart_labels = function chart_labels() {
  this.title_div_ = null;
  this.xlabel_div_ = null;
  this.ylabel_div_ = null;
  this.y2label_div_ = null;
};

chart_labels.prototype.toString = function () {
  return "ChartLabels Plugin";
};

chart_labels.prototype.activate = function (g) {
  return {
    layout: this.layout,
    // clearChart: this.clearChart,
    didDrawChart: this.didDrawChart
  };
};

// QUESTION: should there be a plugin-utils.js?
var createDivInRect = function createDivInRect(r) {
  var div = document.createElement('div');
  div.style.position = 'absolute';
  div.style.left = r.x + 'px';
  div.style.top = r.y + 'px';
  div.style.width = r.w + 'px';
  div.style.height = r.h + 'px';
  return div;
};

// Detach and null out any existing nodes.
chart_labels.prototype.detachLabels_ = function () {
  var els = [this.title_div_, this.xlabel_div_, this.ylabel_div_, this.y2label_div_];
  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    if (!el) continue;
    if (el.parentNode) el.parentNode.removeChild(el);
  }

  this.title_div_ = null;
  this.xlabel_div_ = null;
  this.ylabel_div_ = null;
  this.y2label_div_ = null;
};

var createRotatedDiv = function createRotatedDiv(g, box, axis, classes, html) {
  // TODO(danvk): is this outer div actually necessary?
  var div = document.createElement("div");
  div.style.position = 'absolute';
  if (axis == 1) {
    // NOTE: this is cheating. Should be positioned relative to the box.
    div.style.left = '0px';
  } else {
    div.style.left = box.x + 'px';
  }
  div.style.top = box.y + 'px';
  div.style.width = box.w + 'px';
  div.style.height = box.h + 'px';
  div.style.fontSize = g.getOption('yLabelWidth') - 2 + 'px';

  var inner_div = document.createElement("div");
  inner_div.style.position = 'absolute';
  inner_div.style.width = box.h + 'px';
  inner_div.style.height = box.w + 'px';
  inner_div.style.top = box.h / 2 - box.w / 2 + 'px';
  inner_div.style.left = box.w / 2 - box.h / 2 + 'px';
  inner_div.style.textAlign = 'center';

  // CSS rotation is an HTML5 feature which is not standardized. Hence every
  // browser has its own name for the CSS style.
  var val = 'rotate(' + (axis == 1 ? '-' : '') + '90deg)';
  inner_div.style.transform = val; // HTML5
  inner_div.style.WebkitTransform = val; // Safari/Chrome
  inner_div.style.MozTransform = val; // Firefox
  inner_div.style.OTransform = val; // Opera
  inner_div.style.msTransform = val; // IE9

  var class_div = document.createElement("div");
  class_div.className = classes;
  class_div.innerHTML = html;

  inner_div.appendChild(class_div);
  div.appendChild(inner_div);
  return div;
};

chart_labels.prototype.layout = function (e) {
  this.detachLabels_();

  var g = e.dygraph;
  var div = e.chart_div;
  if (g.getOption('title')) {
    // QUESTION: should this return an absolutely-positioned div instead?
    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));
    this.title_div_ = createDivInRect(title_rect);
    this.title_div_.style.textAlign = 'center';
    this.title_div_.style.fontSize = g.getOption('titleHeight') - 8 + 'px';
    this.title_div_.style.fontWeight = 'bold';
    this.title_div_.style.zIndex = 10;

    var class_div = document.createElement("div");
    class_div.className = 'dygraph-label dygraph-title';
    class_div.innerHTML = g.getOption('title');
    this.title_div_.appendChild(class_div);
    div.appendChild(this.title_div_);
  }

  if (g.getOption('xlabel')) {
    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));
    this.xlabel_div_ = createDivInRect(x_rect);
    this.xlabel_div_.style.textAlign = 'center';
    this.xlabel_div_.style.fontSize = g.getOption('xLabelHeight') - 2 + 'px';

    var class_div = document.createElement("div");
    class_div.className = 'dygraph-label dygraph-xlabel';
    class_div.innerHTML = g.getOption('xlabel');
    this.xlabel_div_.appendChild(class_div);
    div.appendChild(this.xlabel_div_);
  }

  if (g.getOption('ylabel')) {
    // It would make sense to shift the chart here to make room for the y-axis
    // label, but the default yAxisLabelWidth is large enough that this results
    // in overly-padded charts. The y-axis label should fit fine. If it
    // doesn't, the yAxisLabelWidth option can be increased.
    var y_rect = e.reserveSpaceLeft(0);

    this.ylabel_div_ = createRotatedDiv(g, y_rect, 1, // primary (left) y-axis
    'dygraph-label dygraph-ylabel', g.getOption('ylabel'));
    div.appendChild(this.ylabel_div_);
  }

  if (g.getOption('y2label') && g.numAxes() == 2) {
    // same logic applies here as for ylabel.
    var y2_rect = e.reserveSpaceRight(0);
    this.y2label_div_ = createRotatedDiv(g, y2_rect, 2, // secondary (right) y-axis
    'dygraph-label dygraph-y2label', g.getOption('y2label'));
    div.appendChild(this.y2label_div_);
  }
};

chart_labels.prototype.didDrawChart = function (e) {
  var g = e.dygraph;
  if (this.title_div_) {
    this.title_div_.children[0].innerHTML = g.getOption('title');
  }
  if (this.xlabel_div_) {
    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');
  }
  if (this.ylabel_div_) {
    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');
  }
  if (this.y2label_div_) {
    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');
  }
};

chart_labels.prototype.clearChart = function () {};

chart_labels.prototype.destroy = function () {
  this.detachLabels_();
};

exports["default"] = chart_labels;
module.exports = exports["default"];

},{}],22:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

/*

Current bits of jankiness:
- Direct layout access
- Direct area access

*/

"use strict";

/**
 * Draws the gridlines, i.e. the gray horizontal & vertical lines running the
 * length of the chart.
 *
 * @constructor
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
var grid = function grid() {};

grid.prototype.toString = function () {
  return "Gridline Plugin";
};

grid.prototype.activate = function (g) {
  return {
    willDrawChart: this.willDrawChart
  };
};

grid.prototype.willDrawChart = function (e) {
  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to
  // half-integers. This prevents them from drawing in two rows/cols.
  var g = e.dygraph;
  var ctx = e.drawingContext;
  var layout = g.layout_;
  var area = e.dygraph.plotter_.area;

  function halfUp(x) {
    return Math.round(x) + 0.5;
  }
  function halfDown(y) {
    return Math.round(y) - 0.5;
  }

  var x, y, i, ticks;
  if (g.getOptionForAxis('drawGrid', 'y')) {
    var axes = ["y", "y2"];
    var strokeStyles = [],
        lineWidths = [],
        drawGrid = [],
        stroking = [],
        strokePattern = [];
    for (var i = 0; i < axes.length; i++) {
      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);
      if (drawGrid[i]) {
        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);
        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);
        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);
        stroking[i] = strokePattern[i] && strokePattern[i].length >= 2;
      }
    }
    ticks = layout.yticks;
    ctx.save();
    // draw grids for the different y axes
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ticks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var tick = _step.value;

        if (!tick.has_tick) continue;
        var axis = tick.axis;
        if (drawGrid[axis]) {
          ctx.save();
          if (stroking[axis]) {
            if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);
          }
          ctx.strokeStyle = strokeStyles[axis];
          ctx.lineWidth = lineWidths[axis];

          x = halfUp(area.x);
          y = halfDown(area.y + tick.pos * area.h);
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + area.w, y);
          ctx.stroke();

          ctx.restore();
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    ctx.restore();
  }

  // draw grid for x axis
  if (g.getOptionForAxis('drawGrid', 'x')) {
    ticks = layout.xticks;
    ctx.save();
    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');
    var stroking = strokePattern && strokePattern.length >= 2;
    if (stroking) {
      if (ctx.setLineDash) ctx.setLineDash(strokePattern);
    }
    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');
    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = ticks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var tick = _step2.value;

        if (!tick.has_tick) continue;
        x = halfUp(area.x + tick.pos * area.w);
        y = halfDown(area.y + area.h);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, area.y);
        ctx.closePath();
        ctx.stroke();
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (stroking) {
      if (ctx.setLineDash) ctx.setLineDash([]);
    }
    ctx.restore();
  }
};

grid.prototype.destroy = function () {};

exports["default"] = grid;
module.exports = exports["default"];

},{}],23:[function(require,module,exports){
/**
 * @license
 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false */

/*
Current bits of jankiness:
- Uses two private APIs:
    1. Dygraph.optionsViewForAxis_
    2. dygraph.plotter_.area
- Registers for a "predraw" event, which should be renamed.
- I call calculateEmWidthInDiv more often than needed.
*/

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _dygraphUtils = require('../dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

/**
 * Creates the legend, which appears when the user hovers over the chart.
 * The legend can be either a user-specified or generated div.
 *
 * @constructor
 */
var Legend = function Legend() {
  this.legend_div_ = null;
  this.is_generated_div_ = false; // do we own this div, or was it user-specified?
};

Legend.prototype.toString = function () {
  return "Legend Plugin";
};

// (defined below)
var generateLegendDashHTML;

/**
 * This is called during the dygraph constructor, after options have been set
 * but before the data is available.
 *
 * Proper tasks to do here include:
 * - Reading your own options
 * - DOM manipulation
 * - Registering event listeners
 *
 * @param {Dygraph} g Graph instance.
 * @return {object.<string, function(ev)>} Mapping of event names to callbacks.
 */
Legend.prototype.activate = function (g) {
  var div;
  var divWidth = g.getOption('labelsDivWidth');

  var userLabelsDiv = g.getOption('labelsDiv');
  if (userLabelsDiv && null !== userLabelsDiv) {
    if (typeof userLabelsDiv == "string" || userLabelsDiv instanceof String) {
      div = document.getElementById(userLabelsDiv);
    } else {
      div = userLabelsDiv;
    }
  } else {
    // Default legend styles. These can be overridden in CSS by adding
    // "!important" after your rule, e.g. "left: 30px !important;"
    var messagestyle = {
      "position": "absolute",
      "fontSize": "14px",
      "zIndex": 10,
      "width": divWidth + "px",
      "top": "0px",
      "left": g.size().width - divWidth - 2 + "px",
      "background": "white",
      "lineHeight": "normal",
      "textAlign": "left",
      "overflow": "hidden" };

    // TODO(danvk): get rid of labelsDivStyles? CSS is better.
    utils.update(messagestyle, g.getOption('labelsDivStyles'));
    div = document.createElement("div");
    div.className = "dygraph-legend";
    for (var name in messagestyle) {
      if (!messagestyle.hasOwnProperty(name)) continue;

      try {
        div.style[name] = messagestyle[name];
      } catch (e) {
        console.warn("You are using unsupported css properties for your " + "browser in labelsDivStyles");
      }
    }

    // TODO(danvk): come up with a cleaner way to expose this.
    g.graphDiv.appendChild(div);
    this.is_generated_div_ = true;
  }

  this.legend_div_ = div;
  this.one_em_width_ = 10; // just a guess, will be updated.

  return {
    select: this.select,
    deselect: this.deselect,
    // TODO(danvk): rethink the name "predraw" before we commit to it in any API.
    predraw: this.predraw,
    didDrawChart: this.didDrawChart
  };
};

// Needed for dashed lines.
var calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {
  var sizeSpan = document.createElement('span');
  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');
  div.appendChild(sizeSpan);
  var oneEmWidth = sizeSpan.offsetWidth;
  div.removeChild(sizeSpan);
  return oneEmWidth;
};

var escapeHTML = function escapeHTML(str) {
  return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

Legend.prototype.select = function (e) {
  var xValue = e.selectedX;
  var points = e.selectedPoints;
  var row = e.selectedRow;

  var legendMode = e.dygraph.getOption('legend');
  if (legendMode === 'never') {
    this.legend_div_.style.display = 'none';
    return;
  }

  if (legendMode === 'follow') {
    // create floating legend div
    var area = e.dygraph.plotter_.area;
    var labelsDivWidth = e.dygraph.getOption('labelsDivWidth');
    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');
    // determine floating [left, top] coordinates of the legend div
    // within the plotter_ area
    // offset 50 px to the right and down from the first selection point
    // 50 px is guess based on mouse cursor size
    var leftLegend = points[0].x * area.w + 50;
    var topLegend = points[0].y * area.h - 50;

    // if legend floats to end of the chart area, it flips to the other
    // side of the selection point
    if (leftLegend + labelsDivWidth + 1 > area.w) {
      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);
    }

    e.dygraph.graphDiv.appendChild(this.legend_div_);
    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + "px";
    this.legend_div_.style.top = topLegend + "px";
  }

  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);
  this.legend_div_.innerHTML = html;
  this.legend_div_.style.display = '';
};

Legend.prototype.deselect = function (e) {
  var legendMode = e.dygraph.getOption('legend');
  if (legendMode !== 'always') {
    this.legend_div_.style.display = "none";
  }

  // Have to do this every time, since styles might have changed.
  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);
  this.one_em_width_ = oneEmWidth;

  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);
  this.legend_div_.innerHTML = html;
};

Legend.prototype.didDrawChart = function (e) {
  this.deselect(e);
};

// Right edge should be flush with the right edge of the charting area (which
// may not be the same as the right edge of the div, if we have two y-axes.
// TODO(danvk): is any of this really necessary? Could just set "right" in "activate".
/**
 * Position the labels div so that:
 * - its right edge is flush with the right edge of the charting area
 * - its top edge is flush with the top edge of the charting area
 * @private
 */
Legend.prototype.predraw = function (e) {
  // Don't touch a user-specified labelsDiv.
  if (!this.is_generated_div_) return;

  // TODO(danvk): only use real APIs for this.
  e.dygraph.graphDiv.appendChild(this.legend_div_);
  var area = e.dygraph.getArea();
  var labelsDivWidth = e.dygraph.getOption("labelsDivWidth");
  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + "px";
  this.legend_div_.style.top = area.y + "px";
  this.legend_div_.style.width = labelsDivWidth + "px";
};

/**
 * Called when dygraph.destroy() is called.
 * You should null out any references and detach any DOM elements.
 */
Legend.prototype.destroy = function () {
  this.legend_div_ = null;
};

/**
 * Generates HTML for the legend which is displayed when hovering over the
 * chart. If no selected points are specified, a default legend is returned
 * (this may just be the empty string).
 * @param {number} x The x-value of the selected points.
 * @param {Object} sel_points List of selected points for the given
 *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.
 * @param {number} oneEmWidth The pixel width for 1em in the legend. Only
 *   relevant when displaying a legend with no selection (i.e. {legend:
 *   'always'}) and with dashed lines.
 * @param {number} row The selected row index.
 * @private
 */
Legend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {
  // Data about the selection to pass to legendFormatter
  var data = {
    dygraph: g,
    x: x,
    series: []
  };

  var labelToSeries = {};
  var labels = g.getLabels();
  if (labels) {
    for (var i = 1; i < labels.length; i++) {
      var series = g.getPropertiesForSeries(labels[i]);
      var strokePattern = g.getOption('strokePattern', labels[i]);
      var seriesData = {
        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),
        label: labels[i],
        labelHTML: escapeHTML(labels[i]),
        isVisible: series.visible,
        color: series.color
      };

      data.series.push(seriesData);
      labelToSeries[labels[i]] = seriesData;
    }
  }

  if (typeof x !== 'undefined') {
    var xOptView = g.optionsViewForAxis_('x');
    var xvf = xOptView('valueFormatter');
    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);

    var yOptViews = [];
    var num_axes = g.numAxes();
    for (var i = 0; i < num_axes; i++) {
      // TODO(danvk): remove this use of a private API
      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));
    }

    var showZeros = g.getOption('labelsShowZeroValues');
    var highlightSeries = g.getHighlightSeries();
    for (i = 0; i < sel_points.length; i++) {
      var pt = sel_points[i];
      var seriesData = labelToSeries[pt.name];
      seriesData.y = pt.yval;

      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {
        seriesData.isVisible = false;
        continue;
      }

      var series = g.getPropertiesForSeries(pt.name);
      var yOptView = yOptViews[series.axis - 1];
      var fmtFunc = yOptView('valueFormatter');
      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));

      utils.update(seriesData, { yHTML: yHTML });

      if (pt.name == highlightSeries) {
        seriesData.isHighlighted = true;
      }
    }
  }

  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;
  return formatter.call(g, data);
};

Legend.defaultFormatter = function (data) {
  var g = data.dygraph;

  // TODO(danvk): deprecate this option in place of {legend: 'never'}
  // XXX should this logic be in the formatter?
  if (g.getOption('showLabelsOnHighlight') !== true) return '';

  var sepLines = g.getOption('labelsSeparateLines');
  var html;

  if (typeof data.x === 'undefined') {
    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.
    if (g.getOption('legend') != 'always') {
      return '';
    }

    html = '';
    for (var i = 0; i < data.series.length; i++) {
      var series = data.series[i];
      if (!series.isVisible) continue;

      if (html !== '') html += sepLines ? '<br/>' : ' ';
      html += "<span style='font-weight: bold; color: " + series.color + ";'>" + series.dashHTML + " " + series.labelHTML + "</span>";
    }
    return html;
  }

  html = data.xHTML + ':';
  for (var i = 0; i < data.series.length; i++) {
    var series = data.series[i];
    if (!series.isVisible) continue;
    if (sepLines) html += '<br>';
    var cls = series.isHighlighted ? ' class="highlight"' : '';
    html += "<span" + cls + "> <b><span style='color: " + series.color + ";'>" + series.labelHTML + "</span></b>:&#160;" + series.yHTML + "</span>";
  }
  return html;
};

/**
 * Generates html for the "dash" displayed on the legend when using "legend: always".
 * In particular, this works for dashed lines with any stroke pattern. It will
 * try to scale the pattern to fit in 1em width. Or if small enough repeat the
 * pattern for 1em width.
 *
 * @param strokePattern The pattern
 * @param color The color of the series.
 * @param oneEmWidth The width in pixels of 1em in the legend.
 * @private
 */
// TODO(danvk): cache the results of this
generateLegendDashHTML = function (strokePattern, color, oneEmWidth) {
  // Easy, common case: a solid line
  if (!strokePattern || strokePattern.length <= 1) {
    return "<div style=\"display: inline-block; position: relative; " + "bottom: .5ex; padding-left: 1em; height: 1px; " + "border-bottom: 2px solid " + color + ";\"></div>";
  }

  var i, j, paddingLeft, marginRight;
  var strokePixelLength = 0,
      segmentLoop = 0;
  var normalizedPattern = [];
  var loop;

  // Compute the length of the pixels including the first segment twice,
  // since we repeat it.
  for (i = 0; i <= strokePattern.length; i++) {
    strokePixelLength += strokePattern[i % strokePattern.length];
  }

  // See if we can loop the pattern by itself at least twice.
  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));
  if (loop > 1) {
    // This pattern fits at least two times, no scaling just convert to em;
    for (i = 0; i < strokePattern.length; i++) {
      normalizedPattern[i] = strokePattern[i] / oneEmWidth;
    }
    // Since we are repeating the pattern, we don't worry about repeating the
    // first segment in one draw.
    segmentLoop = normalizedPattern.length;
  } else {
    // If the pattern doesn't fit in the legend we scale it to fit.
    loop = 1;
    for (i = 0; i < strokePattern.length; i++) {
      normalizedPattern[i] = strokePattern[i] / strokePixelLength;
    }
    // For the scaled patterns we do redraw the first segment.
    segmentLoop = normalizedPattern.length + 1;
  }

  // Now make the pattern.
  var dash = "";
  for (j = 0; j < loop; j++) {
    for (i = 0; i < segmentLoop; i += 2) {
      // The padding is the drawn segment.
      paddingLeft = normalizedPattern[i % normalizedPattern.length];
      if (i < strokePattern.length) {
        // The margin is the space segment.
        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];
      } else {
        // The repeated first segment has no right margin.
        marginRight = 0;
      }
      dash += "<div style=\"display: inline-block; position: relative; " + "bottom: .5ex; margin-right: " + marginRight + "em; padding-left: " + paddingLeft + "em; height: 1px; border-bottom: 2px solid " + color + ";\"></div>";
    }
  }
  return dash;
};

exports["default"] = Legend;
module.exports = exports["default"];

},{"../dygraph-utils":16}],24:[function(require,module,exports){
/**
 * @license
 * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)
 * MIT-licensed (http://opensource.org/licenses/MIT)
 */
/*global Dygraph:false,TouchEvent:false */

/**
 * @fileoverview This file contains the RangeSelector plugin used to provide
 * a timeline range selector widget for dygraphs.
 */

/*global Dygraph:false */
"use strict";

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _dygraphUtils = require('../dygraph-utils');

var utils = _interopRequireWildcard(_dygraphUtils);

var _dygraphInteractionModel = require('../dygraph-interaction-model');

var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

var _iframeTarp = require('../iframe-tarp');

var _iframeTarp2 = _interopRequireDefault(_iframeTarp);

var rangeSelector = function rangeSelector() {
  this.hasTouchInterface_ = typeof TouchEvent != 'undefined';
  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);
  this.interfaceCreated_ = false;
};

rangeSelector.prototype.toString = function () {
  return "RangeSelector Plugin";
};

rangeSelector.prototype.activate = function (dygraph) {
  this.dygraph_ = dygraph;
  if (this.getOption_('showRangeSelector')) {
    this.createInterface_();
  }
  return {
    layout: this.reserveSpace_,
    predraw: this.renderStaticLayer_,
    didDrawChart: this.renderInteractiveLayer_
  };
};

rangeSelector.prototype.destroy = function () {
  this.bgcanvas_ = null;
  this.fgcanvas_ = null;
  this.leftZoomHandle_ = null;
  this.rightZoomHandle_ = null;
};

//------------------------------------------------------------------
// Private methods
//------------------------------------------------------------------

rangeSelector.prototype.getOption_ = function (name, opt_series) {
  return this.dygraph_.getOption(name, opt_series);
};

rangeSelector.prototype.setDefaultOption_ = function (name, value) {
  this.dygraph_.attrs_[name] = value;
};

/**
 * @private
 * Creates the range selector elements and adds them to the graph.
 */
rangeSelector.prototype.createInterface_ = function () {
  this.createCanvases_();
  this.createZoomHandles_();
  this.initInteraction_();

  // Range selector and animatedZooms have a bad interaction. See issue 359.
  if (this.getOption_('animatedZooms')) {
    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');
    this.dygraph_.updateOptions({ animatedZooms: false }, true);
  }

  this.interfaceCreated_ = true;
  this.addToGraph_();
};

/**
 * @private
 * Adds the range selector to the graph.
 */
rangeSelector.prototype.addToGraph_ = function () {
  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;
  graphDiv.appendChild(this.bgcanvas_);
  graphDiv.appendChild(this.fgcanvas_);
  graphDiv.appendChild(this.leftZoomHandle_);
  graphDiv.appendChild(this.rightZoomHandle_);
};

/**
 * @private
 * Removes the range selector from the graph.
 */
rangeSelector.prototype.removeFromGraph_ = function () {
  var graphDiv = this.graphDiv_;
  graphDiv.removeChild(this.bgcanvas_);
  graphDiv.removeChild(this.fgcanvas_);
  graphDiv.removeChild(this.leftZoomHandle_);
  graphDiv.removeChild(this.rightZoomHandle_);
  this.graphDiv_ = null;
};

/**
 * @private
 * Called by Layout to allow range selector to reserve its space.
 */
rangeSelector.prototype.reserveSpace_ = function (e) {
  if (this.getOption_('showRangeSelector')) {
    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);
  }
};

/**
 * @private
 * Renders the static portion of the range selector at the predraw stage.
 */
rangeSelector.prototype.renderStaticLayer_ = function () {
  if (!this.updateVisibility_()) {
    return;
  }
  this.resize_();
  this.drawStaticLayer_();
};

/**
 * @private
 * Renders the interactive portion of the range selector after the chart has been drawn.
 */
rangeSelector.prototype.renderInteractiveLayer_ = function () {
  if (!this.updateVisibility_() || this.isChangingRange_) {
    return;
  }
  this.placeZoomHandles_();
  this.drawInteractiveLayer_();
};

/**
 * @private
 * Check to see if the range selector is enabled/disabled and update visibility accordingly.
 */
rangeSelector.prototype.updateVisibility_ = function () {
  var enabled = this.getOption_('showRangeSelector');
  if (enabled) {
    if (!this.interfaceCreated_) {
      this.createInterface_();
    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {
      this.addToGraph_();
    }
  } else if (this.graphDiv_) {
    this.removeFromGraph_();
    var dygraph = this.dygraph_;
    setTimeout(function () {
      dygraph.width_ = 0;dygraph.resize();
    }, 1);
  }
  return enabled;
};

/**
 * @private
 * Resizes the range selector.
 */
rangeSelector.prototype.resize_ = function () {
  function setElementRect(canvas, context, rect) {
    var canvasScale = utils.getContextPixelRatio(context);

    canvas.style.top = rect.y + 'px';
    canvas.style.left = rect.x + 'px';
    canvas.width = rect.w * canvasScale;
    canvas.height = rect.h * canvasScale;
    canvas.style.width = rect.w + 'px';
    canvas.style.height = rect.h + 'px';

    if (canvasScale != 1) {
      context.scale(canvasScale, canvasScale);
    }
  }

  var plotArea = this.dygraph_.layout_.getPlotArea();

  var xAxisLabelHeight = 0;
  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {
    xAxisLabelHeight = this.getOption_('xAxisHeight') || this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize');
  }
  this.canvasRect_ = {
    x: plotArea.x,
    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,
    w: plotArea.w,
    h: this.getOption_('rangeSelectorHeight')
  };

  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_);
  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_);
};

/**
 * @private
 * Creates the background and foreground canvases.
 */
rangeSelector.prototype.createCanvases_ = function () {
  this.bgcanvas_ = utils.createCanvas();
  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';
  this.bgcanvas_.style.position = 'absolute';
  this.bgcanvas_.style.zIndex = 9;
  this.bgcanvas_ctx_ = utils.getContext(this.bgcanvas_);

  this.fgcanvas_ = utils.createCanvas();
  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';
  this.fgcanvas_.style.position = 'absolute';
  this.fgcanvas_.style.zIndex = 9;
  this.fgcanvas_.style.cursor = 'default';
  this.fgcanvas_ctx_ = utils.getContext(this.fgcanvas_);
};

/**
 * @private
 * Creates the zoom handle elements.
 */
rangeSelector.prototype.createZoomHandles_ = function () {
  var img = new Image();
  img.className = 'dygraph-rangesel-zoomhandle';
  img.style.position = 'absolute';
  img.style.zIndex = 10;
  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.
  img.style.cursor = 'col-resize';
  // TODO: change image to more options
  img.width = 9;
  img.height = 16;
  img.src = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' + 'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' + 'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' + '6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' + 'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';

  if (this.isMobileDevice_) {
    img.width *= 2;
    img.height *= 2;
  }

  this.leftZoomHandle_ = img;
  this.rightZoomHandle_ = img.cloneNode(false);
};

/**
 * @private
 * Sets up the interaction for the range selector.
 */
rangeSelector.prototype.initInteraction_ = function () {
  var self = this;
  var topElem = document;
  var clientXLast = 0;
  var handle = null;
  var isZooming = false;
  var isPanning = false;
  var dynamic = !this.isMobileDevice_;

  // We cover iframes during mouse interactions. See comments in
  // dygraph-utils.js for more info on why this is a good idea.
  var tarp = new _iframeTarp2['default']();

  // functions, defined below.  Defining them this way (rather than with
  // "function foo() {...}" makes JSHint happy.
  var toXDataWindow, onZoomStart, onZoom, onZoomEnd, doZoom, isMouseInPanZone, onPanStart, onPan, onPanEnd, doPan, onCanvasHover;

  // Touch event functions
  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;

  toXDataWindow = function (zoomHandleStatus) {
    var xDataLimits = self.dygraph_.xAxisExtremes();
    var fact = (xDataLimits[1] - xDataLimits[0]) / self.canvasRect_.w;
    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x) * fact;
    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x) * fact;
    return [xDataMin, xDataMax];
  };

  onZoomStart = function (e) {
    utils.cancelEvent(e);
    isZooming = true;
    clientXLast = e.clientX;
    handle = e.target ? e.target : e.srcElement;
    if (e.type === 'mousedown' || e.type === 'dragstart') {
      // These events are removed manually.
      utils.addEvent(topElem, 'mousemove', onZoom);
      utils.addEvent(topElem, 'mouseup', onZoomEnd);
    }
    self.fgcanvas_.style.cursor = 'col-resize';
    tarp.cover();
    return true;
  };

  onZoom = function (e) {
    if (!isZooming) {
      return false;
    }
    utils.cancelEvent(e);

    var delX = e.clientX - clientXLast;
    if (Math.abs(delX) < 4) {
      return true;
    }
    clientXLast = e.clientX;

    // Move handle.
    var zoomHandleStatus = self.getZoomHandleStatus_();
    var newPos;
    if (handle == self.leftZoomHandle_) {
      newPos = zoomHandleStatus.leftHandlePos + delX;
      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);
      newPos = Math.max(newPos, self.canvasRect_.x);
    } else {
      newPos = zoomHandleStatus.rightHandlePos + delX;
      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);
      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);
    }
    var halfHandleWidth = handle.width / 2;
    handle.style.left = newPos - halfHandleWidth + 'px';
    self.drawInteractiveLayer_();

    // Zoom on the fly.
    if (dynamic) {
      doZoom();
    }
    return true;
  };

  onZoomEnd = function (e) {
    if (!isZooming) {
      return false;
    }
    isZooming = false;
    tarp.uncover();
    utils.removeEvent(topElem, 'mousemove', onZoom);
    utils.removeEvent(topElem, 'mouseup', onZoomEnd);
    self.fgcanvas_.style.cursor = 'default';

    // If on a slower device, zoom now.
    if (!dynamic) {
      doZoom();
    }
    return true;
  };

  doZoom = function () {
    try {
      var zoomHandleStatus = self.getZoomHandleStatus_();
      self.isChangingRange_ = true;
      if (!zoomHandleStatus.isZoomed) {
        self.dygraph_.resetZoom();
      } else {
        var xDataWindow = toXDataWindow(zoomHandleStatus);
        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);
      }
    } finally {
      self.isChangingRange_ = false;
    }
  };

  isMouseInPanZone = function (e) {
    var rect = self.leftZoomHandle_.getBoundingClientRect();
    var leftHandleClientX = rect.left + rect.width / 2;
    rect = self.rightZoomHandle_.getBoundingClientRect();
    var rightHandleClientX = rect.left + rect.width / 2;
    return e.clientX > leftHandleClientX && e.clientX < rightHandleClientX;
  };

  onPanStart = function (e) {
    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {
      utils.cancelEvent(e);
      isPanning = true;
      clientXLast = e.clientX;
      if (e.type === 'mousedown') {
        // These events are removed manually.
        utils.addEvent(topElem, 'mousemove', onPan);
        utils.addEvent(topElem, 'mouseup', onPanEnd);
      }
      return true;
    }
    return false;
  };

  onPan = function (e) {
    if (!isPanning) {
      return false;
    }
    utils.cancelEvent(e);

    var delX = e.clientX - clientXLast;
    if (Math.abs(delX) < 4) {
      return true;
    }
    clientXLast = e.clientX;

    // Move range view
    var zoomHandleStatus = self.getZoomHandleStatus_();
    var leftHandlePos = zoomHandleStatus.leftHandlePos;
    var rightHandlePos = zoomHandleStatus.rightHandlePos;
    var rangeSize = rightHandlePos - leftHandlePos;
    if (leftHandlePos + delX <= self.canvasRect_.x) {
      leftHandlePos = self.canvasRect_.x;
      rightHandlePos = leftHandlePos + rangeSize;
    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {
      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;
      leftHandlePos = rightHandlePos - rangeSize;
    } else {
      leftHandlePos += delX;
      rightHandlePos += delX;
    }
    var halfHandleWidth = self.leftZoomHandle_.width / 2;
    self.leftZoomHandle_.style.left = leftHandlePos - halfHandleWidth + 'px';
    self.rightZoomHandle_.style.left = rightHandlePos - halfHandleWidth + 'px';
    self.drawInteractiveLayer_();

    // Do pan on the fly.
    if (dynamic) {
      doPan();
    }
    return true;
  };

  onPanEnd = function (e) {
    if (!isPanning) {
      return false;
    }
    isPanning = false;
    utils.removeEvent(topElem, 'mousemove', onPan);
    utils.removeEvent(topElem, 'mouseup', onPanEnd);
    // If on a slower device, do pan now.
    if (!dynamic) {
      doPan();
    }
    return true;
  };

  doPan = function () {
    try {
      self.isChangingRange_ = true;
      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());
      self.dygraph_.drawGraph_(false);
    } finally {
      self.isChangingRange_ = false;
    }
  };

  onCanvasHover = function (e) {
    if (isZooming || isPanning) {
      return;
    }
    var cursor = isMouseInPanZone(e) ? 'move' : 'default';
    if (cursor != self.fgcanvas_.style.cursor) {
      self.fgcanvas_.style.cursor = cursor;
    }
  };

  onZoomHandleTouchEvent = function (e) {
    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
      if (onZoomStart(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
      if (onZoom(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else {
      onZoomEnd(e);
    }
  };

  onCanvasTouchEvent = function (e) {
    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
      if (onPanStart(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
      if (onPan(e.targetTouches[0])) {
        utils.cancelEvent(e);
      }
    } else {
      onPanEnd(e);
    }
  };

  addTouchEvents = function (elem, fn) {
    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];
    for (var i = 0; i < types.length; i++) {
      self.dygraph_.addAndTrackEvent(elem, types[i], fn);
    }
  };

  this.setDefaultOption_('interactionModel', _dygraphInteractionModel2['default'].dragIsPanInteractionModel);
  this.setDefaultOption_('panEdgeFraction', 0.0001);

  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';
  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);
  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);

  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);
  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);

  // Touch events
  if (this.hasTouchInterface_) {
    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);
    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);
    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);
  }
};

/**
 * @private
 * Draws the static layer in the background canvas.
 */
rangeSelector.prototype.drawStaticLayer_ = function () {
  var ctx = this.bgcanvas_ctx_;
  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
  try {
    this.drawMiniPlot_();
  } catch (ex) {
    console.warn(ex);
  }

  var margin = 0.5;
  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');
  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');
  ctx.beginPath();
  ctx.moveTo(margin, margin);
  ctx.lineTo(margin, this.canvasRect_.h - margin);
  ctx.lineTo(this.canvasRect_.w - margin, this.canvasRect_.h - margin);
  ctx.lineTo(this.canvasRect_.w - margin, margin);
  ctx.stroke();
};

/**
 * @private
 * Draws the mini plot in the background canvas.
 */
rangeSelector.prototype.drawMiniPlot_ = function () {
  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');
  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');
  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');
  if (!fillStyle && !strokeStyle) {
    return;
  }

  var stepPlot = this.getOption_('stepPlot');

  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();
  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;

  // Draw the mini plot.
  var ctx = this.bgcanvas_ctx_;
  var margin = 0.5;

  var xExtremes = this.dygraph_.xAxisExtremes();
  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);
  var xFact = (this.canvasRect_.w - margin) / xRange;
  var yFact = (this.canvasRect_.h - margin) / yRange;
  var canvasWidth = this.canvasRect_.w - margin;
  var canvasHeight = this.canvasRect_.h - margin;

  var prevX = null,
      prevY = null;

  ctx.beginPath();
  ctx.moveTo(margin, canvasHeight);
  for (var i = 0; i < combinedSeriesData.data.length; i++) {
    var dataPoint = combinedSeriesData.data[i];
    var x = dataPoint[0] !== null ? (dataPoint[0] - xExtremes[0]) * xFact : NaN;
    var y = dataPoint[1] !== null ? canvasHeight - (dataPoint[1] - combinedSeriesData.yMin) * yFact : NaN;

    // Skip points that don't change the x-value. Overly fine-grained points
    // can cause major slowdowns with the ctx.fill() call below.
    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {
      continue;
    }

    if (isFinite(x) && isFinite(y)) {
      if (prevX === null) {
        ctx.lineTo(x, canvasHeight);
      } else if (stepPlot) {
        ctx.lineTo(x, prevY);
      }
      ctx.lineTo(x, y);
      prevX = x;
      prevY = y;
    } else {
      if (prevX !== null) {
        if (stepPlot) {
          ctx.lineTo(x, prevY);
          ctx.lineTo(x, canvasHeight);
        } else {
          ctx.lineTo(prevX, canvasHeight);
        }
      }
      prevX = prevY = null;
    }
  }
  ctx.lineTo(canvasWidth, canvasHeight);
  ctx.closePath();

  if (fillStyle) {
    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);
    if (fillGradientStyle) {
      lingrad.addColorStop(0, fillGradientStyle);
    }
    lingrad.addColorStop(1, fillStyle);
    this.bgcanvas_ctx_.fillStyle = lingrad;
    ctx.fill();
  }

  if (strokeStyle) {
    this.bgcanvas_ctx_.strokeStyle = strokeStyle;
    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');
    ctx.stroke();
  }
};

/**
 * @private
 * Computes and returns the combined series data along with min/max for the mini plot.
 * The combined series consists of averaged values for all series.
 * When series have error bars, the error bars are ignored.
 * @return {Object} An object containing combined series array, ymin, ymax.
 */
rangeSelector.prototype.computeCombinedSeriesAndLimits_ = function () {
  var g = this.dygraph_;
  var logscale = this.getOption_('logscale');
  var i;

  // Select series to combine. By default, all series are combined.
  var numColumns = g.numColumns();
  var labels = g.getLabels();
  var includeSeries = new Array(numColumns);
  var anySet = false;
  for (i = 1; i < numColumns; i++) {
    var include = this.getOption_('showInRangeSelector', labels[i]);
    includeSeries[i] = include;
    if (include !== null) anySet = true; // it's set explicitly for this series
  }
  if (!anySet) {
    for (i = 0; i < includeSeries.length; i++) includeSeries[i] = true;
  }

  // Create a combined series (average of selected series values).
  // TODO(danvk): short-circuit if there's only one series.
  var rolledSeries = [];
  var dataHandler = g.dataHandler_;
  var options = g.attributes_;
  for (i = 1; i < g.numColumns(); i++) {
    if (!includeSeries[i]) continue;
    var series = dataHandler.extractSeries(g.rawData_, i, options);
    if (g.rollPeriod() > 1) {
      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);
    }

    rolledSeries.push(series);
  }

  var combinedSeries = [];
  for (i = 0; i < rolledSeries[0].length; i++) {
    var sum = 0;
    var count = 0;
    for (var j = 0; j < rolledSeries.length; j++) {
      var y = rolledSeries[j][i][1];
      if (y === null || isNaN(y)) continue;
      count++;
      sum += y;
    }
    combinedSeries.push([rolledSeries[0][i][0], sum / count]);
  }

  // Compute the y range.
  var yMin = Number.MAX_VALUE;
  var yMax = -Number.MAX_VALUE;
  for (i = 0; i < combinedSeries.length; i++) {
    var yVal = combinedSeries[i][1];
    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {
      yMin = Math.min(yMin, yVal);
      yMax = Math.max(yMax, yVal);
    }
  }

  // Convert Y data to log scale if needed.
  // Also, expand the Y range to compress the mini plot a little.
  var extraPercent = 0.25;
  if (logscale) {
    yMax = utils.log10(yMax);
    yMax += yMax * extraPercent;
    yMin = utils.log10(yMin);
    for (i = 0; i < combinedSeries.length; i++) {
      combinedSeries[i][1] = utils.log10(combinedSeries[i][1]);
    }
  } else {
    var yExtra;
    var yRange = yMax - yMin;
    if (yRange <= Number.MIN_VALUE) {
      yExtra = yMax * extraPercent;
    } else {
      yExtra = yRange * extraPercent;
    }
    yMax += yExtra;
    yMin -= yExtra;
  }

  return { data: combinedSeries, yMin: yMin, yMax: yMax };
};

/**
 * @private
 * Places the zoom handles in the proper position based on the current X data window.
 */
rangeSelector.prototype.placeZoomHandles_ = function () {
  var xExtremes = this.dygraph_.xAxisExtremes();
  var xWindowLimits = this.dygraph_.xAxisRange();
  var xRange = xExtremes[1] - xExtremes[0];
  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0]) / xRange);
  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1]) / xRange);
  var leftCoord = this.canvasRect_.x + this.canvasRect_.w * leftPercent;
  var rightCoord = this.canvasRect_.x + this.canvasRect_.w * (1 - rightPercent);
  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height) / 2);
  var halfHandleWidth = this.leftZoomHandle_.width / 2;
  this.leftZoomHandle_.style.left = leftCoord - halfHandleWidth + 'px';
  this.leftZoomHandle_.style.top = handleTop + 'px';
  this.rightZoomHandle_.style.left = rightCoord - halfHandleWidth + 'px';
  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;

  this.leftZoomHandle_.style.visibility = 'visible';
  this.rightZoomHandle_.style.visibility = 'visible';
};

/**
 * @private
 * Draws the interactive layer in the foreground canvas.
 */
rangeSelector.prototype.drawInteractiveLayer_ = function () {
  var ctx = this.fgcanvas_ctx_;
  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
  var margin = 1;
  var width = this.canvasRect_.w - margin;
  var height = this.canvasRect_.h - margin;
  var zoomHandleStatus = this.getZoomHandleStatus_();

  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');
  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');
  if (!zoomHandleStatus.isZoomed) {
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, height);
    ctx.lineTo(width, height);
    ctx.lineTo(width, margin);
    ctx.stroke();
  } else {
    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);
    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);

    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';
    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);
    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);

    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(leftHandleCanvasPos, margin);
    ctx.lineTo(leftHandleCanvasPos, height);
    ctx.lineTo(rightHandleCanvasPos, height);
    ctx.lineTo(rightHandleCanvasPos, margin);
    ctx.lineTo(width, margin);
    ctx.stroke();
  }
};

/**
 * @private
 * Returns the current zoom handle position information.
 * @return {Object} The zoom handle status.
 */
rangeSelector.prototype.getZoomHandleStatus_ = function () {
  var halfHandleWidth = this.leftZoomHandle_.width / 2;
  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;
  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;
  return {
    leftHandlePos: leftHandlePos,
    rightHandlePos: rightHandlePos,
    isZoomed: leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x + this.canvasRect_.w
  };
};

exports['default'] = rangeSelector;
module.exports = exports['default'];

},{"../dygraph-interaction-model":11,"../dygraph-utils":16,"../iframe-tarp":18}]},{},[17])(17)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1jdXN0b20uanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLWVycm9yLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvYmFycy1mcmFjdGlvbnMuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9iYXJzLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvZGF0YWhhbmRsZXIvZGF0YWhhbmRsZXIuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9kYXRhaGFuZGxlci9kZWZhdWx0LWZyYWN0aW9ucy5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2RhdGFoYW5kbGVyL2RlZmF1bHQuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9keWdyYXBoLWNhbnZhcy5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2R5Z3JhcGgtZGVmYXVsdC1hdHRycy5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2R5Z3JhcGgtZ3Zpei5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2R5Z3JhcGgtaW50ZXJhY3Rpb24tbW9kZWwuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9keWdyYXBoLWxheW91dC5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2R5Z3JhcGgtb3B0aW9ucy1yZWZlcmVuY2UuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9keWdyYXBoLW9wdGlvbnMuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9keWdyYXBoLXRpY2tlcnMuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9keWdyYXBoLXV0aWxzLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvZHlncmFwaC5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL2lmcmFtZS10YXJwLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvcGx1Z2lucy9hbm5vdGF0aW9ucy5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL3BsdWdpbnMvYXhlcy5qcyIsIi9Vc2Vycy9kYW52ay9naXRodWIvZHlncmFwaHMvc3JjL3BsdWdpbnMvY2hhcnQtbGFiZWxzLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvcGx1Z2lucy9ncmlkLmpzIiwiL1VzZXJzL2RhbnZrL2dpdGh1Yi9keWdyYXBocy9zcmMvcGx1Z2lucy9sZWdlbmQuanMiLCIvVXNlcnMvZGFudmsvZ2l0aHViL2R5Z3JhcGhzL3NyYy9wbHVnaW5zL3JhbmdlLXNlbGVjdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0FDWUEsWUFBWSxDQUFDOzs7Ozs7OztvQkFFVyxRQUFROzs7Ozs7OztBQU1oQyxJQUFJLGlCQUFpQixHQUFHLFNBQXBCLGlCQUFpQixHQUFjLEVBQ2xDLENBQUM7O0FBRUYsaUJBQWlCLENBQUMsU0FBUyxHQUFHLHVCQUFpQixDQUFDOzs7QUFHaEQsaUJBQWlCLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxVQUFTLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFOztBQUV4RSxNQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEIsTUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQztBQUNoQixNQUFJLFFBQVEsR0FBRyxPQUFPLENB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RUFBRyxJQUFJLEVBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUMsRUFBQyxDQUFDO0FBQ3hILGNBQWMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQVksRUFBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLFdBQVcsRUFBRyxJQUFJLEVBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEdBQUcsTUFBTSxFQUFDLENBQUM7QUFDckgsY0FBYyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBVyxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFHLElBQUksRUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksR0FBRyxJQUFJLEdBQUksUUFBUSxFQUFDLENBQUM7QUFDL0gsY0FBYyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFHLElBQUksRUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksR0FBRyxLQUFLLEdBQUcsUUFBUSxFQUFDLENBQUM7QUFDL0gsY0FBYyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBVSxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFHLElBQUksRUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksR0FBRyxLQUFLLEdBQUcsUUFBUSxFQUFDLENBQUM7QUFDL0gsY0FBYyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBWSxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFHLElBQUksRUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksR0FBRyxLQUFLLEdBQUssUUFBUSxFQUFDLENBQUM7QUFDakksY0FBYyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBVyxFQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFHLElBQUksRUFBRyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksR0FBRyxNQUFNLEdBQUksUUFBUSxFQUFD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Q0FBQztBQUFFLFdBQUcsR0FBRyxDQUFDLENBQUMsQUFBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEFBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNoRCxXQUFLLENBQUM7QUFBRSxXQUFHLEdBQUcsQ0FBQyxDQUFDLEFBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxBQUFDLElBQUksR0FBRyxLQUFLLENBQUMsQUFBQyxNQUFNO0FBQUEsQUFDaEQsV0FBSyxDQUFDO0FBQUUsV0FBRyxHQUFHLENBQUMsQ0FBQyxBQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQUFBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ2hELFdBQUssQ0FBQztBQUFFLFdBQUcsR0FBRyxLQUFLLENBQUMsQUFBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEFBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxBQUNoRCxXQUFLLENBQUMsQ0FBQztBQUNQLFdBQUssQ0FBQztBQUFFLFdBQUcsR0FBRyxLQUFLLENBQUMsQUFBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEFBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxBQUFDLE1BQU07QUFBQSxLQUNqRDtHQUNGO0FBQ0QsS0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNsQyxPQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLE1BQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDcEMsU0FBTyxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Q0FDdEQ7O0FBQUEsQ0FBQzs7Ozs7Ozs7OztBQVNLLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRTtB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LENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FDeEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUMxRSxLQUFNLEdBQUksYUFBYSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUUsQ0FDMUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxRQUFRLENBQUMsQ0FDeEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUMxRTtBQUdELEdBQUksU0FBUyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUUsQ0FDakMsR0FBSSxJQUFJLElBQUksTUFBTSxDQUFFLENBQ2xCLEdBQUcsQ0FBQyxTQUFTLEdBQUcsd0JBQXdCLENBQUMsQUFDekMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxJQUFJLENBQUMsQ0FBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FDcEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNyRSxDQUNGLEtBQU0sR0FBSSxTQUFTLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBRSxDQUN0QyxHQUFJLElBQUksSUFBSSxNQUFNLENBQUUsQ0FDbEIsR0FBRyxDQUFDLFNBQVMsR0FBRyx3QkFBd0IsQ0FBQyxBQUN6QyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENB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Q0FBQyxXQUFXLENBQUMsQ0FBRSxDQUN2QyxJQUFLLENBQUMsR0FBRyxDQUFDLENBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDbEMsSUFBSSxHQUFHLENBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQ3BCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxBQUNoQyxHQUFJLGNBQWMsSUFDZCxjQUFjLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBRSxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUUsQ0FDckQsSUFBSSxHQUFHLENBQUcsRUFBRSxDQUFDLEFBQ2IsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQ3RDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQ2xCLEdBQUcsQ0FBQyxTQUFTLEdBQUcseUJBQXlCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEFBQzlELEdBQUcsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLEFBQ2QsSUFBSyxJQUFJLENBQUMsQ0FBRyxDQUFDLENBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDbkQsR0FBSSxDQUFDLENBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQUFDeEIsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBRSxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUN0RCxBQUNELFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDdkIs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O0FBQ0QsS0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDN0IsS0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDL0IsS0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDaEMsS0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsQUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBSSxJQUFJLENBQUM7O0FBRTdELE1BQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUMsV0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO0FBQ3RDLFdBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3JDLFdBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ3RDLFdBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEFBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUksSUFBSSxDQUFDO0FBQ3JELFdBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLEFBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUksSUFBSSxDQUFDO0FBQ3RELFdBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQzs7OztBQUlyQyxNQUFJLEdBQUcsR0FBRyxTQUFTLElBQUksSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFBLEFBQUMsR0FBRyxRQUFRLENBQUM7QUFDeEQsV0FB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O0dBQ25ILENBQUM7Q0FDSCxDQUFDOztxQkFFYSxhQUFhIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBEYXRhSGFuZGxlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGN1c3RvbSBiYXJzIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlcnMuQmFyc0hhbmRsZXJcbiAqL1xudmFyIEN1c3RvbUJhcnNIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5DdXN0b21CYXJzSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQmFyc0hhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5DdXN0b21CYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgcG9pbnQ7XG4gIHZhciBsb2dTY2FsZSA9IG9wdGlvbnMuZ2V0KCdsb2dzY2FsZScpO1xuICBmb3IgKCB2YXIgaiA9IDA7IGogPCByYXdEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgeCA9IHJhd0RhdGFbal1bMF07XG4gICAgcG9pbnQgPSByYXdEYXRhW2pdW2ldO1xuICAgIGlmIChsb2dTY2FsZSAmJiBwb2ludCAhPT0gbnVsbCkge1xuICAgICAgLy8gT24gdGhlIGxvZyBzY2FsZSwgcG9pbnRzIGxlc3MgdGhhbiB6ZXJvIGRvIG5vdCBleGlzdC5cbiAgICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBnYXAgaW4gdGhlIGNoYXJ0LlxuICAgICAgaWYgKHBvaW50WzBdIDw9IDAgfHwgcG9pbnRbMV0gPD0gMCB8fCBwb2ludFsyXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIHkgPSBwb2ludFsxXTtcbiAgICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgcG9pbnRbMF0sIHBvaW50WzJdIF0gXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgeSwgeSBdIF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpZXMucHVzaChbIHgsIG51bGwsIFsgbnVsbCwgbnVsbCBdIF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWVzO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5DdXN0b21CYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgeSwgbG93LCBoaWdoLCBtaWQsY291bnQsIGksIGV4dHJlbWVzO1xuXG4gIGxvdyA9IDA7XG4gIG1pZCA9IDA7XG4gIGhpZ2ggPSAwO1xuICBjb3VudCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB5ID0gb3JpZ2luYWxEYXRhW2ldWzFdO1xuICAgIGV4dHJlbWVzID0gb3JpZ2luYWxEYXRhW2ldWzJdO1xuICAgIHJvbGxpbmdEYXRhW2ldID0gb3JpZ2luYWxEYXRhW2ldO1xuXG4gICAgaWYgKHkgIT09IG51bGwgJiYgIWlzTmFOKHkpKSB7XG4gICAgICBsb3cgKz0gZXh0cmVtZXNbMF07XG4gICAgICBtaWQgKz0geTtcbiAgICAgIGhpZ2ggKz0gZXh0cmVtZXNbMV07XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBpZiAoaSAtIHJvbGxQZXJpb2QgPj0gMCkge1xuICAgICAgdmFyIHByZXYgPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdO1xuICAgICAgaWYgKHByZXZbMV0gIT09IG51bGwgJiYgIWlzTmFOKHByZXZbMV0pKSB7XG4gICAgICAgIGxvdyAtPSBwcmV2WzJdWzBdO1xuICAgICAgICBtaWQgLT0gcHJldlsxXTtcbiAgICAgICAgaGlnaCAtPSBwcmV2WzJdWzFdO1xuICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gW1xuICAgICAgICAgIG9yaWdpbmFsRGF0YVtpXVswXSxcbiAgICAgICAgICAxLjAgKiBtaWQgLyBjb3VudCwgXG4gICAgICAgICAgWyAxLjAgKiBsb3cgLyBjb3VudCxcbiAgICAgICAgICAgIDEuMCAqIGhpZ2ggLyBjb3VudCBdIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIG51bGwsIFsgbnVsbCwgbnVsbCBdIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvbGxpbmdEYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tQmFyc0hhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBlcnJvciBiYXJzIG9wdGlvbi5cbiAqIEBhdXRob3IgRGF2aWQgRWJlcmxlaW4gKGRhdmlkLmViZXJsZWluQGNoLnNhdXRlci1iYy5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2JhcnMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFyc0hhbmRsZXJcbiAqL1xudmFyIEVycm9yQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkVycm9yQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IEJhcnNIYW5kbGVyKCk7XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgdmFyaWFuY2UsIHBvaW50O1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzBdIC0gc2lnbWEgKiBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIHkgPSBwb2ludFswXTtcbiAgICAgIGlmICh5ICE9PSBudWxsICYmICFpc05hTih5KSkge1xuICAgICAgICB2YXJpYW5jZSA9IHNpZ21hICogcG9pbnRbMV07XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIGVycm9yIHZhbHVlIGluIGV4dHJhcyBmb3IgZnVydGhlclxuICAgICAgICAvLyBmaWx0ZXJpbmdcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHkgLSB2YXJpYW5jZSwgeSArIHZhcmlhbmNlLCBwb2ludFsxXSBdIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWVzLnB1c2goWyB4LCB5LCBbIHksIHksIHkgXSBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzLnB1c2goWyB4LCBudWxsLCBbIG51bGwsIG51bGwsIG51bGwgXSBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmllcztcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuRXJyb3JCYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuXG4gIHZhciBpLCBqLCB5LCB2LCBzdW0sIG51bV9vaywgc3RkZGV2LCB2YXJpYW5jZSwgdmFsdWU7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSByb2xsaW5nIGF2ZXJhZ2UgZm9yIHRoZSBmaXJzdCByb2xsUGVyaW9kIC0gMSBwb2ludHNcbiAgLy8gd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIHRvIHJvbGwgb3ZlciB0aGUgZnVsbCBudW1iZXIgb2YgcG9pbnRzXG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gPSAwO1xuICAgIHZhcmlhbmNlID0gMDtcbiAgICBudW1fb2sgPSAwO1xuICAgIGZvciAoaiA9IE1hdGgubWF4KDAsIGkgLSByb2xsUGVyaW9kICsgMSk7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICB5ID0gb3JpZ2luYWxEYXRhW2pdWzFdO1xuICAgICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbnVtX29rKys7XG4gICAgICBzdW0gKz0geTtcbiAgICAgIHZhcmlhbmNlICs9IE1hdGgucG93KG9yaWdpbmFsRGF0YVtqXVsyXVsyXSwgMik7XG4gICAgfVxuICAgIGlmIChudW1fb2spIHtcbiAgICAgIHN0ZGRldiA9IE1hdGguc3FydCh2YXJpYW5jZSkgLyBudW1fb2s7XG4gICAgICB2YWx1ZSA9IHN1bSAvIG51bV9vaztcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIHZhbHVlLFxuICAgICAgICAgIFt2YWx1ZSAtIHNpZ21hICogc3RkZGV2LCB2YWx1ZSArIHNpZ21hICogc3RkZGV2XSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGV4cGxpY2l0bHkgcHJlc2VydmVzIE5hTnMgdG8gYWlkIHdpdGggXCJpbmRlcGVuZGVudFxuICAgICAgLy8gc2VyaWVzXCIuXG4gICAgICAvLyBTZWUgdGVzdFJvbGxpbmdBdmVyYWdlUHJlc2VydmVzTmFOcy5cbiAgICAgIHYgPSAocm9sbFBlcmlvZCA9PSAxKSA/IG9yaWdpbmFsRGF0YVtpXVsxXSA6IG51bGw7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgb3JpZ2luYWxEYXRhW2ldWzBdLCB2LCBbIHYsIHYgXSBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVycm9yQmFyc0hhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBjb21iaW5hdGlvbiBcbiAqIG9mIGVycm9yIGJhcnMgYW5kIGZyYWN0aW9ucyBvcHRpb25zLlxuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEJhcnNIYW5kbGVyIGZyb20gJy4vYmFycyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEeWdyYXBoLkRhdGFIYW5kbGVycy5CYXJzSGFuZGxlclxuICovXG52YXIgRnJhY3Rpb25zQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkZyYWN0aW9uc0JhcnNIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBCYXJzSGFuZGxlcigpO1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkZyYWN0aW9uc0JhcnNIYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgaSwgb3B0aW9ucykge1xuICAvLyBUT0RPKGRhbnZrKTogcHJlLWFsbG9jYXRlIHNlcmllcyBoZXJlLlxuICB2YXIgc2VyaWVzID0gW107XG4gIHZhciB4LCB5LCBwb2ludCwgbnVtLCBkZW4sIHZhbHVlLCBzdGRkZXYsIHZhcmlhbmNlO1xuICB2YXIgbXVsdCA9IDEwMC4wO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHggPSByYXdEYXRhW2pdWzBdO1xuICAgIHBvaW50ID0gcmF3RGF0YVtqXVtpXTtcbiAgICBpZiAobG9nU2NhbGUgJiYgcG9pbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIE9uIHRoZSBsb2cgc2NhbGUsIHBvaW50cyBsZXNzIHRoYW4gemVybyBkbyBub3QgZXhpc3QuXG4gICAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgZ2FwIGluIHRoZSBjaGFydC5cbiAgICAgIGlmIChwb2ludFswXSA8PSAwIHx8IHBvaW50WzFdIDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFeHRyYWN0IHRvIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0LlxuICAgIGlmIChwb2ludCAhPT0gbnVsbCkge1xuICAgICAgbnVtID0gcG9pbnRbMF07XG4gICAgICBkZW4gPSBwb2ludFsxXTtcbiAgICAgIGlmIChudW0gIT09IG51bGwgJiYgIWlzTmFOKG51bSkpIHtcbiAgICAgICAgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgICAgIHN0ZGRldiA9IGRlbiA/IHNpZ21hICogTWF0aC5zcXJ0KHZhbHVlICogKDEgLSB2YWx1ZSkgLyBkZW4pIDogMS4wO1xuICAgICAgICB2YXJpYW5jZSA9IG11bHQgKiBzdGRkZXY7XG4gICAgICAgIHkgPSBtdWx0ICogdmFsdWU7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHZhbHVlcyBpbiBleHRyYXMgZm9yIGZ1cnRoZXIgZmlsdGVyaW5nXG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgeSwgWyB5IC0gdmFyaWFuY2UsIHkgKyB2YXJpYW5jZSwgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgbnVtLCBbIG51bSwgbnVtLCBudW0sIGRlbiBdIF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpZXMucHVzaChbIHgsIG51bGwsIFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdIF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWVzO1xufTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5GcmFjdGlvbnNCYXJzSGFuZGxlci5wcm90b3R5cGUucm9sbGluZ0F2ZXJhZ2UgPVxuICAgIGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xuICByb2xsUGVyaW9kID0gTWF0aC5taW4ocm9sbFBlcmlvZCwgb3JpZ2luYWxEYXRhLmxlbmd0aCk7XG4gIHZhciByb2xsaW5nRGF0YSA9IFtdO1xuICB2YXIgc2lnbWEgPSBvcHRpb25zLmdldChcInNpZ21hXCIpO1xuICB2YXIgd2lsc29uSW50ZXJ2YWwgPSBvcHRpb25zLmdldChcIndpbHNvbkludGVydmFsXCIpO1xuXG4gIHZhciBsb3csIGhpZ2gsIGksIHN0ZGRldjtcbiAgdmFyIG51bSA9IDA7XG4gIHZhciBkZW4gPSAwOyAvLyBudW1lcmF0b3IvZGVub21pbmF0b3JcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIG51bSArPSBvcmlnaW5hbERhdGFbaV1bMl1bMl07XG4gICAgZGVuICs9IG9yaWdpbmFsRGF0YVtpXVsyXVszXTtcbiAgICBpZiAoaSAtIHJvbGxQZXJpb2QgPj0gMCkge1xuICAgICAgbnVtIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bMl07XG4gICAgICBkZW4gLT0gb3JpZ2luYWxEYXRhW2kgLSByb2xsUGVyaW9kXVsyXVszXTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IG9yaWdpbmFsRGF0YVtpXVswXTtcbiAgICB2YXIgdmFsdWUgPSBkZW4gPyBudW0gLyBkZW4gOiAwLjA7XG4gICAgaWYgKHdpbHNvbkludGVydmFsKSB7XG4gICAgICAvLyBGb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgY29uZmlkZW5jZSBpbnRlcnZhbCwgc2VlOlxuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaW5vbWlhbF9jb25maWRlbmNlX2ludGVydmFsXG4gICAgICBpZiAoZGVuKSB7XG4gICAgICAgIHZhciBwID0gdmFsdWUgPCAwID8gMCA6IHZhbHVlLCBuID0gZGVuO1xuICAgICAgICB2YXIgcG0gPSBzaWdtYSAqIE1hdGguc3FydChwICogKDEgLSBwKSAvIG4gKyBzaWdtYSAqIHNpZ21hIC8gKDQgKiBuICogbikpO1xuICAgICAgICB2YXIgZGVub20gPSAxICsgc2lnbWEgKiBzaWdtYSAvIGRlbjtcbiAgICAgICAgbG93ID0gKHAgKyBzaWdtYSAqIHNpZ21hIC8gKDIgKiBkZW4pIC0gcG0pIC8gZGVub207XG4gICAgICAgIGhpZ2ggPSAocCArIHNpZ21hICogc2lnbWEgLyAoMiAqIGRlbikgKyBwbSkgLyBkZW5vbTtcbiAgICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIGRhdGUsIHAgKiBtdWx0LFxuICAgICAgICAgICAgWyBsb3cgKiBtdWx0LCBoaWdoICogbXVsdCBdIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb2xsaW5nRGF0YVtpXSA9IFsgZGF0ZSwgMCwgWyAwLCAwIF0gXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RkZGV2ID0gZGVuID8gc2lnbWEgKiBNYXRoLnNxcnQodmFsdWUgKiAoMSAtIHZhbHVlKSAvIGRlbikgOiAxLjA7XG4gICAgICByb2xsaW5nRGF0YVtpXSA9IFsgZGF0ZSwgbXVsdCAqIHZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICBbIG11bHQgKiAodmFsdWUgLSBzdGRkZXYpLCBtdWx0ICogKHZhbHVlICsgc3RkZGV2KSBdIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvbGxpbmdEYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRnJhY3Rpb25zQmFyc0hhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgYmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFwiYmFyXCIgXG4gKiBkYXRhIGZvcm1hdHMuIFRoaXMgaW1wbGVtZW50YXRpb24gbXVzdCBiZSBleHRlbmRlZCBhbmQgdGhlXG4gKiBleHRyYWN0U2VyaWVzIGFuZCByb2xsaW5nQXZlcmFnZSBtdXN0IGJlIGltcGxlbWVudGVkLlxuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG4vKmdsb2JhbCBEeWdyYXBoTGF5b3V0OmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IER5Z3JhcGhEYXRhSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyJztcbmltcG9ydCBEeWdyYXBoTGF5b3V0IGZyb20gJy4uL2R5Z3JhcGgtbGF5b3V0JztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEeWdyYXBoLkRhdGFIYW5kbGVyfVxuICovXG52YXIgQmFyc0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgRHlncmFwaERhdGFIYW5kbGVyLmNhbGwodGhpcyk7XG59O1xuQmFyc0hhbmRsZXIucHJvdG90eXBlID0gbmV3IER5Z3JhcGhEYXRhSGFuZGxlcigpO1xuXG4vLyBUT0RPKGRhbnZrKTogZmlndXJlIG91dCB3aHkgdGhlIGpzZG9jIGhhcyB0byBiZSBjb3B5L3Bhc3RlZCBmcm9tIHN1cGVyY2xhc3MuXG4vLyAgIChJIGdldCBjbG9zdXJlIGNvbXBpbGVyIGVycm9ycyBpZiB0aGlzIGlzbid0IGhlcmUuKVxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqIEBwYXJhbSB7IUFycmF5LjxBcnJheT59IHJhd0RhdGEgVGhlIHJhdyBkYXRhIHBhc3NlZCBpbnRvIGR5Z3JhcGhzIHdoZXJlIFxuICogICAgIHJhd0RhdGFbaV0gPSBbeCx5U2VyaWVzMSwuLi4seVNlcmllc05dLlxuICogQHBhcmFtIHshbnVtYmVyfSBzZXJpZXNJbmRleCBJbmRleCBvZiB0aGUgc2VyaWVzIHRvIGV4dHJhY3QuIEFsbCBvdGhlclxuICogICAgIHNlcmllcyBzaG91bGQgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhPcHRpb25zfSBvcHRpb25zIER5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdFxuICogICAgIHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLiBcbiAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLmV4dHJhY3RTZXJpZXMgPSBmdW5jdGlvbihyYXdEYXRhLCBzZXJpZXNJbmRleCwgb3B0aW9ucykge1xuICAvLyBOb3QgaW1wbGVtZW50ZWQgaGVyZSBtdXN0IGJlIGV4dGVuZGVkXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZCBcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshbnVtYmVyfSByb2xsUGVyaW9kIFRoZSBudW1iZXIgb2YgcG9pbnRzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSB0aGUgZGF0YVxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgVGhlIGR5Z3JhcGggb3B0aW9ucy5cbiAqIFRPRE8oZGFudmspOiBiZSBtb3JlIHNwZWNpZmljIHRoYW4gXCJBcnJheVwiIGhlcmUuXG4gKiBAcmV0dXJuIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSB0aGUgcm9sbGVkIHNlcmllcy5cbiAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLnJvbGxpbmdBdmVyYWdlID1cbiAgICBmdW5jdGlvbihzZXJpZXMsIHJvbGxQZXJpb2QsIG9wdGlvbnMpIHtcbiAgLy8gTm90IGltcGxlbWVudGVkIGhlcmUsIG11c3QgYmUgZXh0ZW5kZWQuXG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkJhcnNIYW5kbGVyLnByb3RvdHlwZS5vblBvaW50c0NyZWF0ZWRfID0gZnVuY3Rpb24oc2VyaWVzLCBwb2ludHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaXRlbSA9IHNlcmllc1tpXTtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgcG9pbnQueV90b3AgPSBOYU47XG4gICAgcG9pbnQueV9ib3R0b20gPSBOYU47XG4gICAgcG9pbnQueXZhbF9taW51cyA9IER5Z3JhcGhEYXRhSGFuZGxlci5wYXJzZUZsb2F0KGl0ZW1bMl1bMF0pO1xuICAgIHBvaW50Lnl2YWxfcGx1cyA9IER5Z3JhcGhEYXRhSGFuZGxlci5wYXJzZUZsb2F0KGl0ZW1bMl1bMV0pO1xuICB9XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkJhcnNIYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdywgb3B0aW9ucykge1xuICB2YXIgbWluWSA9IG51bGwsIG1heFkgPSBudWxsLCB5O1xuXG4gIHZhciBmaXJzdElkeCA9IDA7XG4gIHZhciBsYXN0SWR4ID0gc2VyaWVzLmxlbmd0aCAtIDE7XG5cbiAgZm9yICggdmFyIGogPSBmaXJzdElkeDsgaiA8PSBsYXN0SWR4OyBqKyspIHtcbiAgICB5ID0gc2VyaWVzW2pdWzFdO1xuICAgIGlmICh5ID09PSBudWxsIHx8IGlzTmFOKHkpKSBjb250aW51ZTtcblxuICAgIHZhciBsb3cgPSBzZXJpZXNbal1bMl1bMF07XG4gICAgdmFyIGhpZ2ggPSBzZXJpZXNbal1bMl1bMV07XG5cbiAgICBpZiAobG93ID4geSkgbG93ID0geTsgLy8gdGhpcyBjYW4gaGFwcGVuIHdpdGggY3VzdG9tIGJhcnMsXG4gICAgaWYgKGhpZ2ggPCB5KSBoaWdoID0geTsgLy8gZS5nLiBpbiB0ZXN0cy9jdXN0b20tYmFycy5odG1sXG5cbiAgICBpZiAobWF4WSA9PT0gbnVsbCB8fCBoaWdoID4gbWF4WSkgbWF4WSA9IGhpZ2g7XG4gICAgaWYgKG1pblkgPT09IG51bGwgfHwgbG93IDwgbWluWSkgbWluWSA9IGxvdztcbiAgfVxuXG4gIHJldHVybiBbIG1pblksIG1heFkgXTtcbn07XG5cbi8qKiBAaW5oZXJpdERvYyAqL1xuQmFyc0hhbmRsZXIucHJvdG90eXBlLm9uTGluZUV2YWx1YXRlZCA9IGZ1bmN0aW9uKHBvaW50cywgYXhpcywgbG9nc2NhbGUpIHtcbiAgdmFyIHBvaW50O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xuICAgIC8vIENvcHkgb3ZlciB0aGUgZXJyb3IgdGVybXNcbiAgICBwb2ludCA9IHBvaW50c1tqXTtcbiAgICBwb2ludC55X3RvcCA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHBvaW50Lnl2YWxfbWludXMsIGxvZ3NjYWxlKTtcbiAgICBwb2ludC55X2JvdHRvbSA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHBvaW50Lnl2YWxfcGx1cywgbG9nc2NhbGUpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCYXJzSGFuZGxlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEzIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgdGhlIG1hbmFnbWVudCBvZiBkYXRhIGhhbmRsZXJzXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICogXG4gKiBUaGUgaWRlYSBpcyB0byBkZWZpbmUgYSBjb21tb24sIGdlbmVyaWMgZGF0YSBmb3JtYXQgdGhhdCB3b3JrcyBmb3IgYWxsIGRhdGFcbiAqIHN0cnVjdHVyZXMgc3VwcG9ydGVkIGJ5IGR5Z3JhcGhzLiBUbyBtYWtlIHRoaXMgcG9zc2libGUsIHRoZSBEYXRhSGFuZGxlclxuICogaW50ZXJmYWNlIGlzIGludHJvZHVjZWQuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUsIHRoYXQgZHlncmFwaCBpdHNlbGYgY2FuIHdvcmtcbiAqIHdpdGggdGhlIHNhbWUgbG9naWMgZm9yIGV2ZXJ5IGRhdGEgdHlwZSBpbmRlcGVuZGVudCBvZiB0aGUgYWN0dWFsIGZvcm1hdCBhbmRcbiAqIHRoZSBEYXRhSGFuZGxlciB0YWtlcyBjYXJlIG9mIHRoZSBkYXRhIGZvcm1hdCBzcGVjaWZpYyBqb2JzLiBcbiAqIERhdGFIYW5kbGVycyBhcmUgaW1wbGVtZW50ZWQgZm9yIGFsbCBkYXRhIHR5cGVzIHN1cHBvcnRlZCBieSBEeWdyYXBocyBhbmRcbiAqIHJldHVybiBEeWdyYXBocyBjb21wbGlhbnQgZm9ybWF0cy5cbiAqIEJ5IGRlZmF1bHQgdGhlIGNvcnJlY3QgRGF0YUhhbmRsZXIgaXMgY2hvc2VuIGJhc2VkIG9uIHRoZSBvcHRpb25zIHNldC5cbiAqIE9wdGlvbmFsbHkgdGhlIHVzZXIgbWF5IHVzZSBoaXMgb3duIERhdGFIYW5kbGVyIChzaW1pbGFyIHRvIHRoZSBwbHVnaW5cbiAqIHN5c3RlbSkuXG4gKiBcbiAqIFxuICogVGhlIHVuaWZpZWQgZGF0YSBmb3JtYXQgcmV0dXJlbmQgYnkgZWFjaCBoYW5kbGVyIGlzIGRlZmluZWQgYXMgc286IFxuICogc2VyaWVzW25dW3BvaW50XSA9IFt4LHksKGV4dHJhcyldIFxuICogXG4gKiBUaGlzIGZvcm1hdCBjb250YWlucyB0aGUgY29tbW9uIGJhc2lzIHRoYXQgaXMgbmVlZGVkIHRvIGRyYXcgYSBzaW1wbGUgbGluZVxuICogc2VyaWVzIGV4dGVuZGVkIGJ5IG9wdGlvbmFsIGV4dHJhcyBmb3IgbW9yZSBjb21wbGV4IGdyYXBoaW5nIHR5cGVzLiBJdFxuICogY29udGFpbnMgYSBwcmltaXRpdmUgeCB2YWx1ZSBhcyBmaXJzdCBhcnJheSBlbnRyeSwgYSBwcmltaXRpdmUgeSB2YWx1ZSBhc1xuICogc2Vjb25kIGFycmF5IGVudHJ5IGFuZCBhbiBvcHRpb25hbCBleHRyYXMgb2JqZWN0IGZvciBhZGRpdGlvbmFsIGRhdGEgbmVlZGVkLlxuICogXG4gKiB4IG11c3QgYWx3YXlzIGJlIGEgbnVtYmVyLlxuICogeSBtdXN0IGFsd2F5cyBiZSBhIG51bWJlciwgTmFOIG9mIHR5cGUgbnVtYmVyIG9yIG51bGwuXG4gKiBleHRyYXMgaXMgb3B0aW9uYWwgYW5kIG11c3QgYmUgaW50ZXJwcmV0ZWQgYnkgdGhlIERhdGFIYW5kbGVyLiBJdCBtYXkgYmUgb2ZcbiAqIGFueSB0eXBlLiBcbiAqIFxuICogSW4gcHJhY3RpY2UgdGhpcyBtaWdodCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKiBkZWZhdWx0OiBbeCwgeVZhbF1cbiAqIGVycm9yQmFyIC8gY3VzdG9tQmFyOiBbeCwgeVZhbCwgW3lUb3BWYXJpYW5jZSwgeUJvdHRvbVZhcmlhbmNlXSBdXG4gKiBcbiAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuLypnbG9iYWwgRHlncmFwaExheW91dDpmYWxzZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBcbiAqIFRoZSBkYXRhIGhhbmRsZXIgaXMgcmVzcG9uc2libGUgZm9yIGFsbCBkYXRhIHNwZWNpZmljIG9wZXJhdGlvbnMuIEFsbCBvZiB0aGVcbiAqIHNlcmllcyBkYXRhIGl0IHJlY2VpdmVzIGFuZCByZXR1cm5zIGlzIGFsd2F5cyBpbiB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAqIEluaXRpYWxseSB0aGUgdW5pZmllZCBkYXRhIGlzIGNyZWF0ZWQgYnkgdGhlIGV4dHJhY3RTZXJpZXMgbWV0aG9kXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhEYXRhSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbnZhciBoYW5kbGVyID0gRHlncmFwaERhdGFIYW5kbGVyO1xuXG4vKipcbiAqIFgtdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLlggPSAwO1xuXG4vKipcbiAqIFktdmFsdWUgYXJyYXkgaW5kZXggY29uc3RhbnQgZm9yIHVuaWZpZWQgZGF0YSBzYW1wbGVzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5oYW5kbGVyLlkgPSAxO1xuXG4vKipcbiAqIEV4dHJhcy12YWx1ZSBhcnJheSBpbmRleCBjb25zdGFudCBmb3IgdW5pZmllZCBkYXRhIHNhbXBsZXMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmhhbmRsZXIuRVhUUkFTID0gMjtcblxuLyoqXG4gKiBFeHRyYWN0cyBvbmUgc2VyaWVzIGZyb20gdGhlIHJhdyBkYXRhIChhIDJEIGFycmF5KSBpbnRvIGFuIGFycmF5IG9mIHRoZVxuICogdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAqIFRoaXMgaXMgd2hlcmUgdW5kZXNpcmFibGUgcG9pbnRzIChpLmUuIG5lZ2F0aXZlIHZhbHVlcyBvbiBsb2cgc2NhbGVzIGFuZFxuICogbWlzc2luZyB2YWx1ZXMgdGhyb3VnaCB3aGljaCB3ZSB3aXNoIHRvIGNvbm5lY3QgbGluZXMpIGFyZSBkcm9wcGVkLlxuICogVE9ETyhkYW52ayk6IHRoZSBcIm1pc3NpbmcgdmFsdWVzXCIgYml0IGFib3ZlIGRvZXNuJ3Qgc2VlbSByaWdodC5cbiAqIFxuICogQHBhcmFtIHshQXJyYXkuPEFycmF5Pn0gcmF3RGF0YSBUaGUgcmF3IGRhdGEgcGFzc2VkIGludG8gZHlncmFwaHMgd2hlcmUgXG4gKiAgICAgcmF3RGF0YVtpXSA9IFt4LHlTZXJpZXMxLC4uLix5U2VyaWVzTl0uXG4gKiBAcGFyYW0geyFudW1iZXJ9IHNlcmllc0luZGV4IEluZGV4IG9mIHRoZSBzZXJpZXMgdG8gZXh0cmFjdC4gQWxsIG90aGVyXG4gKiAgICAgc2VyaWVzIHNob3VsZCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgRHlncmFwaCBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIGRhdGEgZm9ybWF0XG4gKiAgICAgd2hlcmUgc2VyaWVzW2ldID0gW3gseSx7ZXh0cmFzfV0uIFxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5leHRyYWN0U2VyaWVzID0gZnVuY3Rpb24ocmF3RGF0YSwgc2VyaWVzSW5kZXgsIG9wdGlvbnMpIHtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXJpZXMgdG8gYSBQb2ludCBhcnJheS4gIFRoZSByZXN1bHRpbmcgcG9pbnQgYXJyYXkgbXVzdCBiZVxuICogcmV0dXJuZWQgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBpZHggcHJvcGVydHkuXG4gKiBcbiAqIEBwYXJhbSB7IUFycmF5LjxbIW51bWJlciw/bnVtYmVyLD9dPn0gc2VyaWVzIFRoZSBzZXJpZXMgaW4gdGhlIHVuaWZpZWQgXG4gKiAgICAgICAgICBkYXRhIGZvcm1hdCB3aGVyZSBzZXJpZXNbaV0gPSBbeCx5LHtleHRyYXN9XS5cbiAqIEBwYXJhbSB7IXN0cmluZ30gc2V0TmFtZSBOYW1lIG9mIHRoZSBzZXJpZXMuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGJvdW5kYXJ5SWRTdGFydCBJbmRleCBvZmZzZXQgb2YgdGhlIGZpcnN0IHBvaW50LCBlcXVhbCB0byB0aGVcbiAqICAgICAgICAgIG51bWJlciBvZiBza2lwcGVkIHBvaW50cyBsZWZ0IG9mIHRoZSBkYXRlIHdpbmRvdyBtaW5pbXVtIChpZiBhbnkpLlxuICogQHJldHVybiB7IUFycmF5LjxEeWdyYXBoLlBvaW50VHlwZT59IExpc3Qgb2YgcG9pbnRzIGZvciB0aGlzIHNlcmllcy5cbiAqL1xuaGFuZGxlci5wcm90b3R5cGUuc2VyaWVzVG9Qb2ludHMgPSBmdW5jdGlvbihzZXJpZXMsIHNldE5hbWUsIGJvdW5kYXJ5SWRTdGFydCkge1xuICAvLyBUT0RPKGJocyk6IHRoZXNlIGxvb3BzIGFyZSBhIGhvdC1zcG90IGZvciBoaWdoLXBvaW50LWNvdW50IGNoYXJ0cy4gSW5cbiAgLy8gZmFjdCxcbiAgLy8gb24gY2hyb21lK2xpbnV4LCB0aGV5IGFyZSA2IHRpbWVzIG1vcmUgZXhwZW5zaXZlIHRoYW4gaXRlcmF0aW5nIHRocm91Z2hcbiAgLy8gdGhlXG4gIC8vIHBvaW50cyBhbmQgZHJhd2luZyB0aGUgbGluZXMuIFRoZSBicnVudCBvZiB0aGUgY29zdCBjb21lcyBmcm9tIGFsbG9jYXRpbmdcbiAgLy8gdGhlIHxwb2ludHwgc3RydWN0dXJlcy5cbiAgdmFyIHBvaW50cyA9IFtdO1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaXRlbSA9IHNlcmllc1tpXTtcbiAgICB2YXIgeXJhdyA9IGl0ZW1bMV07XG4gICAgdmFyIHl2YWwgPSB5cmF3ID09PSBudWxsID8gbnVsbCA6IGhhbmRsZXIucGFyc2VGbG9hdCh5cmF3KTtcbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICB4IDogTmFOLFxuICAgICAgeSA6IE5hTixcbiAgICAgIHh2YWwgOiBoYW5kbGVyLnBhcnNlRmxvYXQoaXRlbVswXSksXG4gICAgICB5dmFsIDogeXZhbCxcbiAgICAgIG5hbWUgOiBzZXROYW1lLCAvLyBUT0RPKGRhbnZrKTogaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5P1xuICAgICAgaWR4IDogaSArIGJvdW5kYXJ5SWRTdGFydFxuICAgIH07XG4gICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICB9XG4gIHRoaXMub25Qb2ludHNDcmVhdGVkXyhzZXJpZXMsIHBvaW50cyk7XG4gIHJldHVybiBwb2ludHM7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIGNhbGxlZCBmb3IgZWFjaCBzZXJpZXMgYWZ0ZXIgdGhlIHNlcmllcyBwb2ludHMgaGF2ZSBiZWVuIGdlbmVyYXRlZFxuICogd2hpY2ggd2lsbCBsYXRlciBiZSB1c2VkIGJ5IHRoZSBwbG90dGVycyB0byBkcmF3IHRoZSBncmFwaC5cbiAqIEhlcmUgZGF0YSBtYXkgYmUgYWRkZWQgdG8gdGhlIHNlcmllc1BvaW50cyB3aGljaCBpcyBuZWVkZWQgYnkgdGhlIHBsb3R0ZXJzLlxuICogVGhlIGluZGV4ZXMgb2Ygc2VyaWVzIGFuZCBwb2ludHMgYXJlIGluIHN5bmMgbWVhbmluZyB0aGUgb3JpZ2luYWwgZGF0YVxuICogc2FtcGxlIGZvciBzZXJpZXNbaV0gaXMgcG9pbnRzW2ldLlxuICogXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFRoZSBjb3JyZXNwb25kaW5nIHBvaW50cyBwYXNzZWQgXG4gKiAgICAgdG8gdGhlIHBsb3R0ZXIuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLm9uUG9pbnRzQ3JlYXRlZF8gPSBmdW5jdGlvbihzZXJpZXMsIHBvaW50cykge1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByb2xsaW5nIGF2ZXJhZ2Ugb2YgYSBkYXRhIHNldC5cbiAqIFxuICogQHBhcmFtIHshQXJyYXkuPFshbnVtYmVyLD9udW1iZXIsP10+fSBzZXJpZXMgVGhlIHNlcmllcyBpbiB0aGUgdW5pZmllZCBcbiAqICAgICAgICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshbnVtYmVyfSByb2xsUGVyaW9kIFRoZSBudW1iZXIgb2YgcG9pbnRzIG92ZXIgd2hpY2ggdG8gYXZlcmFnZSB0aGUgZGF0YVxuICogQHBhcmFtIHshRHlncmFwaE9wdGlvbnN9IG9wdGlvbnMgVGhlIGR5Z3JhcGggb3B0aW9ucy5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHRoZSByb2xsZWQgc2VyaWVzLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKHNlcmllcywgcm9sbFBlcmlvZCwgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGEgc2VyaWVzIChpbmNsdWRpbmcgY29uZmlkZW5jZSBpbnRlcnZhbHMpLlxuICogXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LCB5LCB7ZXh0cmFzfV0uXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gZGF0ZVdpbmRvdyBUaGUgeC12YWx1ZSByYW5nZSB0byBkaXNwbGF5IHdpdGggXG4gKiAgICAgdGhlIGZvcm1hdDogW21pbiwgbWF4XS5cbiAqIEBwYXJhbSB7IUR5Z3JhcGhPcHRpb25zfSBvcHRpb25zIFRoZSBkeWdyYXBoIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxvdyBhbmQgaGlnaCBleHRyZW1lcyBvZiB0aGUgc2VyaWVzIGluIHRoZVxuICogICAgIGdpdmVuIHdpbmRvdyB3aXRoIHRoZSBmb3JtYXQ6IFtsb3csIGhpZ2hdLlxuICovXG5oYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdywgb3B0aW9ucykge1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayBjYWxsZWQgZm9yIGVhY2ggc2VyaWVzIGFmdGVyIHRoZSBsYXlvdXRpbmcgZGF0YSBoYXMgYmVlblxuICogY2FsY3VsYXRlZCBiZWZvcmUgdGhlIHNlcmllcyBpcyBkcmF3bi4gSGVyZSBub3JtYWxpemVkIHBvc2l0aW9uaW5nIGRhdGFcbiAqIHNob3VsZCBiZSBjYWxjdWxhdGVkIGZvciB0aGUgZXh0cmFzIG9mIGVhY2ggcG9pbnQuXG4gKiBcbiAqIEBwYXJhbSB7IUFycmF5LjxEeWdyYXBoLlBvaW50VHlwZT59IHBvaW50cyBUaGUgcG9pbnRzIHBhc3NlZCB0byBcbiAqICAgICAgICAgIHRoZSBwbG90dGVyLlxuICogQHBhcmFtIHshT2JqZWN0fSBheGlzIFRoZSBheGlzIG9uIHdoaWNoIHRoZSBzZXJpZXMgd2lsbCBiZSBwbG90dGVkLlxuICogQHBhcmFtIHshYm9vbGVhbn0gbG9nc2NhbGUgV2VhdGhlciBvciBub3QgdG8gdXNlIGEgbG9nc2NhbGUuXG4gKi9cbmhhbmRsZXIucHJvdG90eXBlLm9uTGluZUV2YWx1YXRlZCA9IGZ1bmN0aW9uKHBvaW50cywgYXhpcywgbG9nc2NhbGUpIHtcbn07XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0aGF0IGNvbXB1dGVzIHRoZSB5IHZhbHVlIG9mIGEgbGluZSBkZWZpbmVkIGJ5IHRoZSBwb2ludHMgcDFcbiAqIGFuZCBwMiBhbmQgYSBnaXZlbiB4IHZhbHVlLlxuICogXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gcDEgbGVmdCBwb2ludCAoW3gseV0pLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IHAyIHJpZ2h0IHBvaW50IChbeCx5XSkuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHhWYWx1ZSBUaGUgeCB2YWx1ZSB0byBjb21wdXRlIHRoZSB5LWludGVyc2VjdGlvbiBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGNvcnJlc3BvbmRpbmcgeSB2YWx1ZSB0byB4IG9uIHRoZSBsaW5lIGRlZmluZWQgYnkgcDEgYW5kIHAyLlxuICogQHByaXZhdGVcbiAqL1xuaGFuZGxlci5wcm90b3R5cGUuY29tcHV0ZVlJbnRlcnBvbGF0aW9uXyA9IGZ1bmN0aW9uKHAxLCBwMiwgeFZhbHVlKSB7XG4gIHZhciBkZWx0YVkgPSBwMlsxXSAtIHAxWzFdO1xuICB2YXIgZGVsdGFYID0gcDJbMF0gLSBwMVswXTtcbiAgdmFyIGdyYWRpZW50ID0gZGVsdGFZIC8gZGVsdGFYO1xuICB2YXIgZ3Jvd3RoID0gKHhWYWx1ZSAtIHAxWzBdKSAqIGdyYWRpZW50O1xuICByZXR1cm4gcDFbMV0gKyBncm93dGg7XG59O1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGdpdmVuIHNlcmllc1xuICogdGhhdCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBkYXRlV2luZG93LlxuICogXG4gKiBAcGFyYW0geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IHNlcmllcyBUaGUgc2VyaWVzIGluIHRoZSB1bmlmaWVkIFxuICogICAgIGRhdGEgZm9ybWF0IHdoZXJlIHNlcmllc1tpXSA9IFt4LHkse2V4dHJhc31dLlxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGRhdGVXaW5kb3cgVGhlIHgtdmFsdWUgcmFuZ2UgdG8gZGlzcGxheSB3aXRoIFxuICogICAgIHRoZSBmb3JtYXQ6IFttaW4sbWF4XS5cbiAqIEByZXR1cm4geyFBcnJheS48WyFudW1iZXIsP251bWJlciw/XT59IFRoZSBzYW1wbGVzIG9mIHRoZSBzZXJpZXMgdGhhdCBcbiAqICAgICBhcmUgaW4gdGhlIGdpdmVuIGRhdGUgd2luZG93LlxuICogQHByaXZhdGVcbiAqL1xuaGFuZGxlci5wcm90b3R5cGUuZ2V0SW5kZXhlc0luV2luZG93XyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdykge1xuICB2YXIgZmlyc3RJZHggPSAwLCBsYXN0SWR4ID0gc2VyaWVzLmxlbmd0aCAtIDE7XG4gIGlmIChkYXRlV2luZG93KSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxvdyA9IGRhdGVXaW5kb3dbMF07XG4gICAgdmFyIGhpZ2ggPSBkYXRlV2luZG93WzFdO1xuXG4gICAgLy8gU3RhcnQgZnJvbSBlYWNoIHNpZGUgb2YgdGhlIGFycmF5IHRvIG1pbmltaXplIHRoZSBwZXJmb3JtYW5jZVxuICAgIC8vIG5lZWRlZC5cbiAgICB3aGlsZSAoaWR4IDwgc2VyaWVzLmxlbmd0aCAtIDEgJiYgc2VyaWVzW2lkeF1bMF0gPCBsb3cpIHtcbiAgICAgIGZpcnN0SWR4Kys7XG4gICAgICBpZHgrKztcbiAgICB9XG4gICAgaWR4ID0gc2VyaWVzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGlkeCA+IDAgJiYgc2VyaWVzW2lkeF1bMF0gPiBoaWdoKSB7XG4gICAgICBsYXN0SWR4LS07XG4gICAgICBpZHgtLTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0SWR4IDw9IGxhc3RJZHgpIHtcbiAgICByZXR1cm4gWyBmaXJzdElkeCwgbGFzdElkeCBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbIDAsIHNlcmllcy5sZW5ndGggLSAxIF07XG4gIH1cbn07XG5cbi8qKlxuICogT3B0aW1pemVkIHJlcGxhY2VtZW50IGZvciBwYXJzZUZsb2F0LCB3aGljaCB3YXMgd2F5IHRvbyBzbG93IHdoZW4gYWxtb3N0XG4gKiBhbGwgdmFsdWVzIHdlcmUgdHlwZSBudW1iZXIsIHdpdGggZmV3IGVkZ2UgY2FzZXMsIG5vbmUgb2Ygd2hpY2ggd2VyZSBzdHJpbmdzLlxuICogQHBhcmFtIHs/bnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuaGFuZGxlci5wYXJzZUZsb2F0ID0gZnVuY3Rpb24odmFsKSB7XG4gIC8vIHBhcnNlRmxvYXQobnVsbCkgaXMgTmFOXG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgLy8gQXNzdW1lIGl0J3MgYSBudW1iZXIgb3IgTmFOLiBJZiBpdCdzIHNvbWV0aGluZyBlbHNlLCBJJ2xsIGJlIHNob2NrZWQuXG4gIHJldHVybiB2YWw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoRGF0YUhhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBmcmFjdGlvbnMgb3B0aW9uLlxuICogQGF1dGhvciBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IER5Z3JhcGhEYXRhSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyJztcbmltcG9ydCBEZWZhdWx0SGFuZGxlciBmcm9tICcuL2RlZmF1bHQnO1xuXG4vKipcbiAqIEBleHRlbmRzIERlZmF1bHRIYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERlZmF1bHRGcmFjdGlvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG4gIFxuRGVmYXVsdEZyYWN0aW9uSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgRGVmYXVsdEhhbmRsZXIoKTtcblxuRGVmYXVsdEZyYWN0aW9uSGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgeCwgeSwgcG9pbnQsIG51bSwgZGVuLCB2YWx1ZTtcbiAgdmFyIG11bHQgPSAxMDAuMDtcbiAgdmFyIGxvZ1NjYWxlID0gb3B0aW9ucy5nZXQoJ2xvZ3NjYWxlJyk7XG4gIGZvciAoIHZhciBqID0gMDsgaiA8IHJhd0RhdGEubGVuZ3RoOyBqKyspIHtcbiAgICB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICBwb2ludCA9IHJhd0RhdGFbal1baV07XG4gICAgaWYgKGxvZ1NjYWxlICYmIHBvaW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBPbiB0aGUgbG9nIHNjYWxlLCBwb2ludHMgbGVzcyB0aGFuIHplcm8gZG8gbm90IGV4aXN0LlxuICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIGdhcCBpbiB0aGUgY2hhcnQuXG4gICAgICBpZiAocG9pbnRbMF0gPD0gMCB8fCBwb2ludFsxXSA8PSAwKSB7XG4gICAgICAgIHBvaW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXh0cmFjdCB0byB0aGUgdW5pZmllZCBkYXRhIGZvcm1hdC5cbiAgICBpZiAocG9pbnQgIT09IG51bGwpIHtcbiAgICAgIG51bSA9IHBvaW50WzBdO1xuICAgICAgZGVuID0gcG9pbnRbMV07XG4gICAgICBpZiAobnVtICE9PSBudWxsICYmICFpc05hTihudW0pKSB7XG4gICAgICAgIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgICAgICB5ID0gbXVsdCAqIHZhbHVlO1xuICAgICAgICAvLyBwcmVzZXJ2ZSBvcmlnaW5hbCB2YWx1ZXMgaW4gZXh0cmFzIGZvciBmdXJ0aGVyIGZpbHRlcmluZ1xuICAgICAgICBzZXJpZXMucHVzaChbIHgsIHksIFsgbnVtLCBkZW4gXSBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmllcy5wdXNoKFsgeCwgbnVtLCBbIG51bSwgZGVuIF0gXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmllcy5wdXNoKFsgeCwgbnVsbCwgWyBudWxsLCBudWxsIF0gXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpZXM7XG59O1xuXG5EZWZhdWx0RnJhY3Rpb25IYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCxcbiAgICBvcHRpb25zKSB7XG4gIHJvbGxQZXJpb2QgPSBNYXRoLm1pbihyb2xsUGVyaW9kLCBvcmlnaW5hbERhdGEubGVuZ3RoKTtcbiAgdmFyIHJvbGxpbmdEYXRhID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBudW0gPSAwO1xuICB2YXIgZGVuID0gMDsgLy8gbnVtZXJhdG9yL2Rlbm9taW5hdG9yXG4gIHZhciBtdWx0ID0gMTAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBvcmlnaW5hbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBudW0gKz0gb3JpZ2luYWxEYXRhW2ldWzJdWzBdO1xuICAgIGRlbiArPSBvcmlnaW5hbERhdGFbaV1bMl1bMV07XG4gICAgaWYgKGkgLSByb2xsUGVyaW9kID49IDApIHtcbiAgICAgIG51bSAtPSBvcmlnaW5hbERhdGFbaSAtIHJvbGxQZXJpb2RdWzJdWzBdO1xuICAgICAgZGVuIC09IG9yaWdpbmFsRGF0YVtpIC0gcm9sbFBlcmlvZF1bMl1bMV07XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBvcmlnaW5hbERhdGFbaV1bMF07XG4gICAgdmFyIHZhbHVlID0gZGVuID8gbnVtIC8gZGVuIDogMC4wO1xuICAgIHJvbGxpbmdEYXRhW2ldID0gWyBkYXRlLCBtdWx0ICogdmFsdWUgXTtcbiAgfVxuXG4gIHJldHVybiByb2xsaW5nRGF0YTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRGcmFjdGlvbkhhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMyBEYXZpZCBFYmVybGVpbiAoZGF2aWQuZWJlcmxlaW5AY2guc2F1dGVyLWJjLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YUhhbmRsZXIgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBzaW1wbGUgbGluZSBjaGFydHMuXG4gKiBAYXV0aG9yIERhdmlkIEViZXJsZWluIChkYXZpZC5lYmVybGVpbkBjaC5zYXV0ZXItYmMuY29tKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRHlncmFwaERhdGFIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXInO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRHlncmFwaC5EYXRhSGFuZGxlclxuICovXG52YXIgRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbn07XG5cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZSA9IG5ldyBEeWdyYXBoRGF0YUhhbmRsZXIoKTtcblxuLyoqIEBpbmhlcml0RG9jICovXG5EZWZhdWx0SGFuZGxlci5wcm90b3R5cGUuZXh0cmFjdFNlcmllcyA9IGZ1bmN0aW9uKHJhd0RhdGEsIGksIG9wdGlvbnMpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHByZS1hbGxvY2F0ZSBzZXJpZXMgaGVyZS5cbiAgdmFyIHNlcmllcyA9IFtdO1xuICB2YXIgbG9nU2NhbGUgPSBvcHRpb25zLmdldCgnbG9nc2NhbGUnKTtcbiAgZm9yICggdmFyIGogPSAwOyBqIDwgcmF3RGF0YS5sZW5ndGg7IGorKykge1xuICAgIHZhciB4ID0gcmF3RGF0YVtqXVswXTtcbiAgICB2YXIgcG9pbnQgPSByYXdEYXRhW2pdW2ldO1xuICAgIGlmIChsb2dTY2FsZSkge1xuICAgICAgLy8gT24gdGhlIGxvZyBzY2FsZSwgcG9pbnRzIGxlc3MgdGhhbiB6ZXJvIGRvIG5vdCBleGlzdC5cbiAgICAgIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBnYXAgaW4gdGhlIGNoYXJ0LlxuICAgICAgaWYgKHBvaW50IDw9IDApIHtcbiAgICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXJpZXMucHVzaChbIHgsIHBvaW50IF0pO1xuICB9XG4gIHJldHVybiBzZXJpZXM7XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZS5yb2xsaW5nQXZlcmFnZSA9IGZ1bmN0aW9uKG9yaWdpbmFsRGF0YSwgcm9sbFBlcmlvZCxcbiAgICBvcHRpb25zKSB7XG4gIHJvbGxQZXJpb2QgPSBNYXRoLm1pbihyb2xsUGVyaW9kLCBvcmlnaW5hbERhdGEubGVuZ3RoKTtcbiAgdmFyIHJvbGxpbmdEYXRhID0gW107XG5cbiAgdmFyIGksIGosIHksIHN1bSwgbnVtX29rO1xuICAvLyBDYWxjdWxhdGUgdGhlIHJvbGxpbmcgYXZlcmFnZSBmb3IgdGhlIGZpcnN0IHJvbGxQZXJpb2QgLSAxIHBvaW50c1xuICAvLyB3aGVyZVxuICAvLyB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgdG8gcm9sbCBvdmVyIHRoZSBmdWxsIG51bWJlciBvZiBwb2ludHNcbiAgaWYgKHJvbGxQZXJpb2QgPT0gMSkge1xuICAgIHJldHVybiBvcmlnaW5hbERhdGE7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHN1bSA9IDA7XG4gICAgbnVtX29rID0gMDtcbiAgICBmb3IgKGogPSBNYXRoLm1heCgwLCBpIC0gcm9sbFBlcmlvZCArIDEpOyBqIDwgaSArIDE7IGorKykge1xuICAgICAgeSA9IG9yaWdpbmFsRGF0YVtqXVsxXTtcbiAgICAgIGlmICh5ID09PSBudWxsIHx8IGlzTmFOKHkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIG51bV9vaysrO1xuICAgICAgc3VtICs9IG9yaWdpbmFsRGF0YVtqXVsxXTtcbiAgICB9XG4gICAgaWYgKG51bV9vaykge1xuICAgICAgcm9sbGluZ0RhdGFbaV0gPSBbIG9yaWdpbmFsRGF0YVtpXVswXSwgc3VtIC8gbnVtX29rIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvbGxpbmdEYXRhW2ldID0gWyBvcmlnaW5hbERhdGFbaV1bMF0sIG51bGwgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9sbGluZ0RhdGE7XG59O1xuXG4vKiogQGluaGVyaXREb2MgKi9cbkRlZmF1bHRIYW5kbGVyLnByb3RvdHlwZS5nZXRFeHRyZW1lWVZhbHVlcyA9IGZ1bmN0aW9uKHNlcmllcywgZGF0ZVdpbmRvdyxcbiAgICBvcHRpb25zKSB7XG4gIHZhciBtaW5ZID0gbnVsbCwgbWF4WSA9IG51bGwsIHk7XG4gIHZhciBmaXJzdElkeCA9IDAsIGxhc3RJZHggPSBzZXJpZXMubGVuZ3RoIC0gMTtcblxuICBmb3IgKCB2YXIgaiA9IGZpcnN0SWR4OyBqIDw9IGxhc3RJZHg7IGorKykge1xuICAgIHkgPSBzZXJpZXNbal1bMV07XG4gICAgaWYgKHkgPT09IG51bGwgfHwgaXNOYU4oeSkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobWF4WSA9PT0gbnVsbCB8fCB5ID4gbWF4WSkge1xuICAgICAgbWF4WSA9IHk7XG4gICAgfVxuICAgIGlmIChtaW5ZID09PSBudWxsIHx8IHkgPCBtaW5ZKSB7XG4gICAgICBtaW5ZID0geTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsgbWluWSwgbWF4WSBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVmYXVsdEhhbmRsZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwNiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGVcbiAqIG5lZWRzIG9mIGR5Z3JhcGhzLlxuICpcbiAqIEluIHBhcnRpY3VsYXIsIHN1cHBvcnQgZm9yOlxuICogLSBncmlkIG92ZXJsYXlzXG4gKiAtIGVycm9yIGJhcnNcbiAqIC0gZHlncmFwaHMgYXR0cmlidXRlIHN5c3RlbVxuICovXG5cbi8qKlxuICogVGhlIER5Z3JhcGhDYW52YXNSZW5kZXJlciBjbGFzcyBkb2VzIHRoZSBhY3R1YWwgcmVuZGVyaW5nIG9mIHRoZSBjaGFydCBvbnRvXG4gKiBhIGNhbnZhcy4gSXQncyBiYXNlZCBvbiBQbG90S2l0LkNhbnZhc1JlbmRlcmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGNhbnZhcyB0byBhdHRhY2ggdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50Q29udGV4dCBUaGUgMmQgY29udGV4dCBvZiB0aGUgY2FudmFzIChpbmplY3RlZCBzbyBpdFxuICogY2FuIGJlIG1vY2tlZCBmb3IgdGVzdGluZy4pXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFRoZSBEeWdyYXBoTGF5b3V0IG9iamVjdCBmb3IgdGhpcyBncmFwaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGggZnJvbSAnLi9keWdyYXBoJztcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgXCJuZXcgcG9pbnRzXCIgdG8gY2hhcnQuIFRoaXMgaXMgZ2VuZXJhbGx5IHRoZVxuICogY2FzZSB3aGVuIHRoZSB1bmRlcmx5aW5nIGRhdGEgYmVpbmcgY2hhcnRlZCBoYXMgY2hhbmdlZC4gSXQgaXMgX25vdF8gY2FsbGVkXG4gKiBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGUgdXNlciBoYXMgem9vbWVkIG9yIGlzIHBhbm5pbmcgdGhlIHZpZXcuXG4gKlxuICogVGhlIGNoYXJ0IGNhbnZhcyBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgYnkgdGhlIER5Z3JhcGggb2JqZWN0LiBUaGVcbiAqIHJlbmRlcmVyIHNpbXBseSBnZXRzIGEgZHJhd2luZyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZHlncmFwaCBUaGUgY2hhcnQgdG8gd2hpY2ggdGhpcyByZW5kZXJlciBiZWxvbmdzLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudCBUaGUgJmx0O2NhbnZhcyZndDsgRE9NIGVsZW1lbnQgb24gd2hpY2ggdG8gZHJhdy5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBlbGVtZW50Q29udGV4dCBUaGUgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtIHtEeWdyYXBoTGF5b3V0fSBsYXlvdXQgVGhlIGNoYXJ0J3MgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVE9ETyhkYW52ayk6IHJlbW92ZSB0aGUgZWxlbWVudENvbnRleHQgcHJvcGVydHkuXG4gKi9cbnZhciBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbihkeWdyYXBoLCBlbGVtZW50LCBlbGVtZW50Q29udGV4dCwgbGF5b3V0KSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuXG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmVsZW1lbnRDb250ZXh0ID0gZWxlbWVudENvbnRleHQ7XG5cbiAgdGhpcy5oZWlnaHQgPSBkeWdyYXBoLmhlaWdodF87XG4gIHRoaXMud2lkdGggPSBkeWdyYXBoLndpZHRoXztcblxuICAvLyAtLS0gY2hlY2sgd2hldGhlciBldmVyeXRoaW5nIGlzIG9rIGJlZm9yZSB3ZSByZXR1cm5cbiAgaWYgKCF1dGlscy5pc0NhbnZhc1N1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgdGhyb3cgXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgfVxuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIHRoaXMuYXJlYSA9IGxheW91dC5nZXRQbG90QXJlYSgpO1xuXG4gIC8vIFNldCB1cCBhIGNsaXBwaW5nIGFyZWEgZm9yIHRoZSBjYW52YXMgKGFuZCB0aGUgaW50ZXJhY3Rpb24gY2FudmFzKS5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgb3ZlcmRyYXcuXG4gIC8vIG9uIEFuZHJvaWQgMyBhbmQgNCwgc2V0dGluZyBhIGNsaXBwaW5nIGFyZWEgb24gYSBjYW52YXMgcHJldmVudHMgaXQgZnJvbVxuICAvLyBkaXNwbGF5aW5nIGFueXRoaW5nLlxuICBpZiAoIXV0aWxzLmlzQW5kcm9pZCgpKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuZHlncmFwaF8uY2FudmFzX2N0eF87XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHRoaXMuYXJlYS54LCB0aGlzLmFyZWEueSwgdGhpcy5hcmVhLncsIHRoaXMuYXJlYS5oKTtcbiAgICBjdHguY2xpcCgpO1xuXG4gICAgY3R4ID0gdGhpcy5keWdyYXBoXy5oaWRkZW5fY3R4XztcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3QodGhpcy5hcmVhLngsIHRoaXMuYXJlYS55LCB0aGlzLmFyZWEudywgdGhpcy5hcmVhLmgpO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCBhbGwgY2hhcnQgY29udGVudCBhbmQgRE9NIGVsZW1lbnRzLlxuICogVGhpcyBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYmVmb3JlIHJlbmRlcigpIG9uIGV2ZXJ5IGZyYW1lLCBpbmNsdWRpbmdcbiAqIGR1cmluZyB6b29tcyBhbmQgcGFucy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbGVtZW50Q29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBldmVyeXRoaW5nIG9uIHRoZSBjaGFydCwgaW5jbHVkaW5nXG4gKiBsaW5lcywgZXJyb3IgYmFycywgZmlsbHMgYW5kIGF4ZXMuXG4gKiBJdCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY2xlYXIoKSBvbiBldmVyeSBmcmFtZSwgaW5jbHVkaW5nIGR1cmluZyBwYW5zXG4gKiBhbmQgem9vbXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAvLyBhdHRhY2hlcyBwb2ludC5jYW52YXN7eCx5fVxuICB0aGlzLl91cGRhdGVQb2ludHMoKTtcblxuICAvLyBhY3R1YWxseSBkcmF3cyB0aGUgY2hhcnQuXG4gIHRoaXMuX3JlbmRlckxpbmVDaGFydCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZGljYXRlIHRvIGJlIHVzZWQgd2l0aCBhbiBpdGVyYXRvciwgd2hpY2ggd2lsbFxuICogaXRlcmF0ZSBvdmVyIHBvaW50cyBhcHByb3ByaWF0ZWx5LCBkZXBlbmRpbmcgb24gd2hldGhlclxuICogY29ubmVjdFNlcGFyYXRlZFBvaW50cyBpcyB0cnVlLiBXaGVuIGl0J3MgZmFsc2UsIHRoZSBwcmVkaWNhdGUgd2lsbFxuICogc2tpcCBvdmVyIHBvaW50cyB3aXRoIG1pc3NpbmcgeVZhbHMuXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUgPSBmdW5jdGlvbihjb25uZWN0U2VwYXJhdGVkUG9pbnRzKSB7XG4gIHJldHVybiBjb25uZWN0U2VwYXJhdGVkUG9pbnRzID9cbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgOlxuICAgICAgbnVsbDtcbn07XG5cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fcHJlZGljYXRlVGhhdFNraXBzRW1wdHlQb2ludHMgPVxuICAgIGZ1bmN0aW9uKGFycmF5LCBpZHgpIHtcbiAgcmV0dXJuIGFycmF5W2lkeF0ueXZhbCAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogRHJhd3MgYSBsaW5lIHdpdGggdGhlIHN0eWxlcyBwYXNzZWQgaW4gYW5kIGNhbGxzIGFsbCB0aGUgZHJhd1BvaW50Q2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZSA9IGZ1bmN0aW9uKGUsXG4gICAgY29sb3IsIHN0cm9rZVdpZHRoLCBzdHJva2VQYXR0ZXJuLCBkcmF3UG9pbnRzLFxuICAgIGRyYXdQb2ludENhbGxiYWNrLCBwb2ludFNpemUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIC8vIFRPRE8oa29uaWdzYmVyZyk6IENvbXB1dGUgYXR0cmlidXRlcyBvdXRzaWRlIHRoaXMgbWV0aG9kIGNhbGwuXG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIGUuc2V0TmFtZSk7XG5cbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShzdHJva2VQYXR0ZXJuKSkge1xuICAgIHN0cm9rZVBhdHRlcm4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGRyYXdHYXBQb2ludHMgPSBnLmdldEJvb2xlYW5PcHRpb24oJ2RyYXdHYXBFZGdlUG9pbnRzJywgZS5zZXROYW1lKTtcblxuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgaXRlciA9IHV0aWxzLmNyZWF0ZUl0ZXJhdG9yKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCxcbiAgICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZ2V0SXRlcmF0b3JQcmVkaWNhdGUoXG4gICAgICAgICAgZy5nZXRCb29sZWFuT3B0aW9uKFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiLCBzZXROYW1lKSkpO1xuXG4gIHZhciBzdHJva2luZyA9IHN0cm9rZVBhdHRlcm4gJiYgKHN0cm9rZVBhdHRlcm4ubGVuZ3RoID49IDIpO1xuXG4gIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICBjdHguc2F2ZSgpO1xuICBpZiAoc3Ryb2tpbmcpIHtcbiAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goc3Ryb2tlUGF0dGVybik7XG4gIH1cblxuICB2YXIgcG9pbnRzT25MaW5lID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzKFxuICAgICAgZSwgaXRlciwgc3Ryb2tlV2lkdGgsIHBvaW50U2l6ZSwgZHJhd1BvaW50cywgZHJhd0dhcFBvaW50cywgc3RlcFBsb3QsIGNvbG9yKTtcbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lKFxuICAgICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSk7XG5cbiAgaWYgKHN0cm9raW5nKSB7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZG9lcyB0aGUgYWN0dWFsIGRyYXdpbmcgb2YgbGluZXMgb24gdGhlIGNhbnZhcywgZm9yIGp1c3Qgb25lIHNlcmllcy5cbiAqIFJldHVybnMgYSBsaXN0IG9mIFtjYW52YXN4LCBjYW52YXN5XSBwYWlycyBmb3IgcG9pbnRzIGZvciB3aGljaCBhXG4gKiBkcmF3UG9pbnRDYWxsYmFjayBzaG91bGQgYmUgZmlyZWQuICBUaGVzZSBpbmNsdWRlIGlzb2xhdGVkIHBvaW50cywgb3IgYWxsXG4gKiBwb2ludHMgaWYgZHJhd1BvaW50cz10cnVlLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U2VyaWVzID0gZnVuY3Rpb24oZSxcbiAgICBpdGVyLCBzdHJva2VXaWR0aCwgcG9pbnRTaXplLCBkcmF3UG9pbnRzLCBkcmF3R2FwUG9pbnRzLCBzdGVwUGxvdCwgY29sb3IpIHtcblxuICB2YXIgcHJldkNhbnZhc1ggPSBudWxsO1xuICB2YXIgcHJldkNhbnZhc1kgPSBudWxsO1xuICB2YXIgbmV4dENhbnZhc1kgPSBudWxsO1xuICB2YXIgaXNJc29sYXRlZDsgLy8gdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGlzb2xhdGVkIChubyBsaW5lIHNlZ21lbnRzKVxuICB2YXIgcG9pbnQ7IC8vIHRoZSBwb2ludCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHdoaWxlIGxvb3BcbiAgdmFyIHBvaW50c09uTGluZSA9IFtdOyAvLyBBcnJheSBvZiBbY2FudmFzeCwgY2FudmFzeV0gcGFpcnMuXG4gIHZhciBmaXJzdCA9IHRydWU7IC8vIHRoZSBmaXJzdCBjeWNsZSB0aHJvdWdoIHRoZSB3aGlsZSBsb29wXG5cbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblxuICAvLyBOT1RFOiB3ZSBicmVhayB0aGUgaXRlcmF0b3IncyBlbmNhcHN1bGF0aW9uIGhlcmUgZm9yIGFib3V0IGEgMjUlIHNwZWVkdXAuXG4gIHZhciBhcnIgPSBpdGVyLmFycmF5XztcbiAgdmFyIGxpbWl0ID0gaXRlci5lbmRfO1xuICB2YXIgcHJlZGljYXRlID0gaXRlci5wcmVkaWNhdGVfO1xuXG4gIGZvciAodmFyIGkgPSBpdGVyLnN0YXJ0XzsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICBwb2ludCA9IGFycltpXTtcbiAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICB3aGlsZSAoaSA8IGxpbWl0ICYmICFwcmVkaWNhdGUoYXJyLCBpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PSBsaW1pdCkgYnJlYWs7XG4gICAgICBwb2ludCA9IGFycltpXTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogVGhlICdjYW52YXN5ICE9IGNhbnZhc3knIHRlc3QgaGVyZSBjYXRjaGVzIE5hTiB2YWx1ZXMgYnV0IHRoZSB0ZXN0XG4gICAgLy8gZG9lc24ndCBjYXRjaCBJbmZpbml0eSB2YWx1ZXMuIENvdWxkIGNoYW5nZSB0aGlzIHRvXG4gICAgLy8gIWlzRmluaXRlKHBvaW50LmNhbnZhc3kpLCBidXQgSSBhc3N1bWUgaXQgYXZvaWRzIGlzTmFOIGZvciBwZXJmb3JtYW5jZT9cbiAgICBpZiAocG9pbnQuY2FudmFzeSA9PT0gbnVsbCB8fCBwb2ludC5jYW52YXN5ICE9IHBvaW50LmNhbnZhc3kpIHtcbiAgICAgIGlmIChzdGVwUGxvdCAmJiBwcmV2Q2FudmFzWCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBEcmF3IGEgaG9yaXpvbnRhbCBsaW5lIHRvIHRoZSBzdGFydCBvZiB0aGUgbWlzc2luZyBkYXRhXG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldkNhbnZhc1gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2Q2FudmFzWSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHByZXZDYW52YXNZID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNJc29sYXRlZCA9IGZhbHNlO1xuICAgICAgaWYgKGRyYXdHYXBQb2ludHMgfHwgcHJldkNhbnZhc1ggPT09IG51bGwpIHtcbiAgICAgICAgaXRlci5uZXh0SWR4XyA9IGk7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBuZXh0Q2FudmFzWSA9IGl0ZXIuaGFzTmV4dCA/IGl0ZXIucGVlay5jYW52YXN5IDogbnVsbDtcblxuICAgICAgICB2YXIgaXNOZXh0Q2FudmFzWU51bGxPck5hTiA9IG5leHRDYW52YXNZID09PSBudWxsIHx8XG4gICAgICAgICAgICBuZXh0Q2FudmFzWSAhPSBuZXh0Q2FudmFzWTtcbiAgICAgICAgaXNJc29sYXRlZCA9IChwcmV2Q2FudmFzWCA9PT0gbnVsbCAmJiBpc05leHRDYW52YXNZTnVsbE9yTmFOKTtcbiAgICAgICAgaWYgKGRyYXdHYXBQb2ludHMpIHtcbiAgICAgICAgICAvLyBBbHNvIGNvbnNpZGVyIGEgcG9pbnQgdG8gYmUgXCJpc29sYXRlZFwiIGlmIGl0J3MgYWRqYWNlbnQgdG8gYVxuICAgICAgICAgIC8vIG51bGwgcG9pbnQsIGV4Y2x1ZGluZyB0aGUgZ3JhcGggZWRnZXMuXG4gICAgICAgICAgaWYgKCghZmlyc3QgJiYgcHJldkNhbnZhc1ggPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgIChpdGVyLmhhc05leHQgJiYgaXNOZXh0Q2FudmFzWU51bGxPck5hTikpIHtcbiAgICAgICAgICAgIGlzSXNvbGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNhbnZhc1ggIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHByZXZDYW52YXNYLCBwcmV2Q2FudmFzWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZDYW52YXNZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50LmNhbnZhc3gsIHBvaW50LmNhbnZhc3kpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYXdQb2ludHMgfHwgaXNJc29sYXRlZCkge1xuICAgICAgICBwb2ludHNPbkxpbmUucHVzaChbcG9pbnQuY2FudmFzeCwgcG9pbnQuY2FudmFzeSwgcG9pbnQuaWR4XSk7XG4gICAgICB9XG4gICAgICBwcmV2Q2FudmFzWCA9IHBvaW50LmNhbnZhc3g7XG4gICAgICBwcmV2Q2FudmFzWSA9IHBvaW50LmNhbnZhc3k7XG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgY3R4LnN0cm9rZSgpO1xuICByZXR1cm4gcG9pbnRzT25MaW5lO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpcmVzIHRoZSBkcmF3UG9pbnRDYWxsYmFjayBmdW5jdGlvbnMsIHdoaWNoIGRyYXcgZG90cyBvbiB0aGUgcG9pbnRzIGJ5XG4gKiBkZWZhdWx0LiBUaGlzIGdldHMgdXNlZCB3aGVuIHRoZSBcImRyYXdQb2ludHNcIiBvcHRpb24gaXMgc2V0LCBvciB3aGVuIHRoZXJlXG4gKiBhcmUgaXNvbGF0ZWQgcG9pbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGRpY3Rpb25hcnkgcGFzc2VkIHRvIHRoZSBwbG90dGVyIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3UG9pbnRzT25MaW5lID0gZnVuY3Rpb24oXG4gICAgZSwgcG9pbnRzT25MaW5lLCBkcmF3UG9pbnRDYWxsYmFjaywgY29sb3IsIHBvaW50U2l6ZSkge1xuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcG9pbnRzT25MaW5lLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIgY2IgPSBwb2ludHNPbkxpbmVbaWR4XTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGRyYXdQb2ludENhbGxiYWNrLmNhbGwoZS5keWdyYXBoLFxuICAgICAgICBlLmR5Z3JhcGgsIGUuc2V0TmFtZSwgY3R4LCBjYlswXSwgY2JbMV0sIGNvbG9yLCBwb2ludFNpemUsIGNiWzJdKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGNhbnZhcyBjb29yZGluYXRlcyB0byB0aGUgcG9pbnRzIGFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIFVwZGF0ZSBQb2ludHNcbiAgLy8gVE9ETyhkYW52ayk6IGhlcmVcbiAgLy9cbiAgLy8gVE9ETyhiaHMpOiB0aGlzIGxvb3AgaXMgYSBob3Qtc3BvdCBmb3IgaGlnaC1wb2ludC1jb3VudCBjaGFydHMuIFRoZXNlXG4gIC8vIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgcHVzaGVkIGludG8gdGhlIGNhbnZhcyB2aWEgbGluZWFyIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG1hdHJpY2VzLlxuICAvLyBOT1RFKGRhbnZrKTogdGhpcyBpcyB0cmlja2llciB0aGFuIGl0IHNvdW5kcyBhdCBmaXJzdC4gVGhlIHRyYW5zZm9ybWF0aW9uXG4gIC8vIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIHRoZSAubW92ZVRvKCkgYW5kIC5saW5lVG8oKSBjYWxscywgYnV0IG11c3QgYmVcbiAgLy8gdW5kb25lIGJlZm9yZSB0aGUgLnN0cm9rZSgpIGNhbGwgdG8gZW5zdXJlIHRoYXQgdGhlIHN0cm9rZSB3aWR0aCBpc1xuICAvLyB1bmFmZmVjdGVkLiAgQW4gYWx0ZXJuYXRpdmUgaXMgdG8gcmVkdWNlIHRoZSBzdHJva2Ugd2lkdGggaW4gdGhlXG4gIC8vIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUgc3BhY2UsIGJ1dCB5b3UgY2FuJ3Qgc3BlY2lmeSBkaWZmZXJlbnQgdmFsdWVzIGZvclxuICAvLyBlYWNoIGRpbWVuc2lvbiAoYXMgeW91IGNhbiB3aXRoIC5zY2FsZSgpKS4gVGhlIHNwZWVkdXAgaGVyZSBpcyB+MTIlLlxuICB2YXIgc2V0cyA9IHRoaXMubGF5b3V0LnBvaW50cztcbiAgZm9yICh2YXIgaSA9IHNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIHBvaW50cyA9IHNldHNbaV07XG4gICAgZm9yICh2YXIgaiA9IHBvaW50cy5sZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBwb2ludCA9IHBvaW50c1tqXTtcbiAgICAgIHBvaW50LmNhbnZhc3ggPSB0aGlzLmFyZWEudyAqIHBvaW50LnggKyB0aGlzLmFyZWEueDtcbiAgICAgIHBvaW50LmNhbnZhc3kgPSB0aGlzLmFyZWEuaCAqIHBvaW50LnkgKyB0aGlzLmFyZWEueTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGNhbnZhcyBBY3R1YWxseSBkcmF3IHRoZSBsaW5lcyBjaGFydCwgaW5jbHVkaW5nIGVycm9yIGJhcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgaWYgRHlncmFwaExheW91dCdzIHBvaW50cyBhcnJheSBoYXMgYmVlblxuICogdXBkYXRlZCB3aXRoIGNhbnZhc3t4LHl9IGF0dHJpYnV0ZXMsIGkuZS4gYnlcbiAqIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fdXBkYXRlUG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgd2hlbiBzcGVjaWZpZWQsIG9ubHkgdGhhdCBzZXJpZXMgd2lsbFxuICogICAgIGJlIGRyYXduLiAoVGhpcyBpcyB1c2VkIGZvciBleHBlZGl0ZWQgcmVkcmF3aW5nIHdpdGggaGlnaGxpZ2h0U2VyaWVzT3B0cylcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBvcHRfY3R4IHdoZW4gc3BlY2lmaWVkLCB0aGUgZHJhd2luZ1xuICogICAgIGNvbnRleHQuICBIb3dldmVyLCBsaW5lcyBhcmUgdHlwaWNhbGx5IGRyYXduIG9uIHRoZSBvYmplY3Qnc1xuICogICAgIGVsZW1lbnRDb250ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyTGluZUNoYXJ0ID0gZnVuY3Rpb24ob3B0X3Nlcmllc05hbWUsIG9wdF9jdHgpIHtcbiAgdmFyIGN0eCA9IG9wdF9jdHggfHwgdGhpcy5lbGVtZW50Q29udGV4dDtcbiAgdmFyIGk7XG5cbiAgdmFyIHNldHMgPSB0aGlzLmxheW91dC5wb2ludHM7XG4gIHZhciBzZXROYW1lcyA9IHRoaXMubGF5b3V0LnNldE5hbWVzO1xuICB2YXIgc2V0TmFtZTtcblxuICB0aGlzLmNvbG9ycyA9IHRoaXMuZHlncmFwaF8uY29sb3JzTWFwXztcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggc2VyaWVzIGhhdmUgc3BlY2lhbGl6ZWQgcGxvdHRlcnMuXG4gIHZhciBwbG90dGVyX2F0dHIgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInBsb3R0ZXJcIik7XG4gIHZhciBwbG90dGVycyA9IHBsb3R0ZXJfYXR0cjtcbiAgaWYgKCF1dGlscy5pc0FycmF5TGlrZShwbG90dGVycykpIHtcbiAgICBwbG90dGVycyA9IFtwbG90dGVyc107XG4gIH1cblxuICB2YXIgc2V0UGxvdHRlcnMgPSB7fTsgIC8vIHNlcmllcyBuYW1lIC0+IHBsb3R0ZXIgZm4uXG4gIGZvciAoaSA9IDA7IGkgPCBzZXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHNldE5hbWUgPSBzZXROYW1lc1tpXTtcbiAgICB2YXIgc2V0UGxvdHRlciA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwicGxvdHRlclwiLCBzZXROYW1lKTtcbiAgICBpZiAoc2V0UGxvdHRlciA9PSBwbG90dGVyX2F0dHIpIGNvbnRpbnVlOyAgLy8gbm90IHNwZWNpYWxpemVkLlxuXG4gICAgc2V0UGxvdHRlcnNbc2V0TmFtZV0gPSBzZXRQbG90dGVyO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHBsb3R0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsb3R0ZXIgPSBwbG90dGVyc1tpXTtcbiAgICB2YXIgaXNfbGFzdCA9IChpID09IHBsb3R0ZXJzLmxlbmd0aCAtIDEpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzZXROYW1lID0gc2V0TmFtZXNbal07XG4gICAgICBpZiAob3B0X3Nlcmllc05hbWUgJiYgc2V0TmFtZSAhPSBvcHRfc2VyaWVzTmFtZSkgY29udGludWU7XG5cbiAgICAgIHZhciBwb2ludHMgPSBzZXRzW2pdO1xuXG4gICAgICAvLyBPbmx5IHRocm93IGluIHRoZSBzcGVjaWFsaXplZCBwbG90dGVycyBvbiB0aGUgbGFzdCBpdGVyYXRpb24uXG4gICAgICB2YXIgcCA9IHBsb3R0ZXI7XG4gICAgICBpZiAoc2V0TmFtZSBpbiBzZXRQbG90dGVycykge1xuICAgICAgICBpZiAoaXNfbGFzdCkge1xuICAgICAgICAgIHAgPSBzZXRQbG90dGVyc1tzZXROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEb24ndCB1c2UgdGhlIHN0YW5kYXJkIHBsb3R0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yc1tzZXROYW1lXTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwic3Ryb2tlV2lkdGhcIiwgc2V0TmFtZSk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHAoe1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgc2V0TmFtZTogc2V0TmFtZSxcbiAgICAgICAgZHJhd2luZ0NvbnRleHQ6IGN0eCxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGR5Z3JhcGg6IHRoaXMuZHlncmFwaF8sXG4gICAgICAgIGF4aXM6IHRoaXMuZHlncmFwaF8uYXhpc1Byb3BlcnRpZXNGb3JTZXJpZXMoc2V0TmFtZSksXG4gICAgICAgIHBsb3RBcmVhOiB0aGlzLmFyZWEsXG4gICAgICAgIHNlcmllc0luZGV4OiBqLFxuICAgICAgICBzZXJpZXNDb3VudDogc2V0cy5sZW5ndGgsXG4gICAgICAgIHNpbmdsZVNlcmllc05hbWU6IG9wdF9zZXJpZXNOYW1lLFxuICAgICAgICBhbGxTZXJpZXNQb2ludHM6IHNldHNcbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3RhbmRhcmQgcGxvdHRlcnMuIFRoZXNlIG1heSBiZSB1c2VkIGJ5IGNsaWVudHMgdmlhIER5Z3JhcGguUGxvdHRlcnMuXG4gKiBTZWUgY29tbWVudHMgdGhlcmUgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9QbG90dGVycyA9IHtcbiAgbGluZVBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2xpbmVQbG90dGVyKGUpO1xuICB9LFxuXG4gIGZpbGxQbG90dGVyOiBmdW5jdGlvbihlKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9maWxsUGxvdHRlcihlKTtcbiAgfSxcblxuICBlcnJvclBsb3R0ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlcihlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQbG90dGVyIHdoaWNoIGRyYXdzIHRoZSBjZW50cmFsIGxpbmVzIGZvciBhIHNlcmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXIgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgc2V0TmFtZSA9IGUuc2V0TmFtZTtcbiAgdmFyIHN0cm9rZVdpZHRoID0gZS5zdHJva2VXaWR0aDtcblxuICAvLyBUT0RPKGRhbnZrKTogQ2hlY2sgaWYgdGhlcmUncyBhbnkgcGVyZm9ybWFuY2UgaW1wYWN0IG9mIGp1c3QgY2FsbGluZ1xuICAvLyBnZXRPcHRpb24oKSBpbnNpZGUgb2YgX2RyYXdTdHlsZWRMaW5lLiBQYXNzaW5nIGluIHNvIG1hbnkgcGFyYW1ldGVycyBtYWtlc1xuICAvLyB0aGlzIGNvZGUgYSBiaXQgbmFzdHkuXG4gIHZhciBib3JkZXJXaWR0aCA9IGcuZ2V0TnVtZXJpY09wdGlvbihcInN0cm9rZUJvcmRlcldpZHRoXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50Q2FsbGJhY2sgPSBnLmdldE9wdGlvbihcImRyYXdQb2ludENhbGxiYWNrXCIsIHNldE5hbWUpIHx8XG4gICAgICB1dGlscy5DaXJjbGVzLkRFRkFVTFQ7XG4gIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oXCJzdHJva2VQYXR0ZXJuXCIsIHNldE5hbWUpO1xuICB2YXIgZHJhd1BvaW50cyA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcImRyYXdQb2ludHNcIiwgc2V0TmFtZSk7XG4gIHZhciBwb2ludFNpemUgPSBnLmdldE51bWVyaWNPcHRpb24oXCJwb2ludFNpemVcIiwgc2V0TmFtZSk7XG5cbiAgaWYgKGJvcmRlcldpZHRoICYmIHN0cm9rZVdpZHRoKSB7XG4gICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgICBnLmdldE9wdGlvbihcInN0cm9rZUJvcmRlckNvbG9yXCIsIHNldE5hbWUpLFxuICAgICAgICBzdHJva2VXaWR0aCArIDIgKiBib3JkZXJXaWR0aCxcbiAgICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgICAgZHJhd1BvaW50cyxcbiAgICAgICAgZHJhd1BvaW50Q2FsbGJhY2ssXG4gICAgICAgIHBvaW50U2l6ZVxuICAgICAgICApO1xuICB9XG5cbiAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9kcmF3U3R5bGVkTGluZShlLFxuICAgICAgZS5jb2xvcixcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlUGF0dGVybixcbiAgICAgIGRyYXdQb2ludHMsXG4gICAgICBkcmF3UG9pbnRDYWxsYmFjayxcbiAgICAgIHBvaW50U2l6ZVxuICApO1xufTtcblxuLyoqXG4gKiBEcmF3cyB0aGUgc2hhZGVkIGVycm9yIGJhcnMvY29uZmlkZW5jZSBpbnRlcnZhbHMgZm9yIGVhY2ggc2VyaWVzLlxuICogVGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgY2VudGVyIGxpbmVzIGFyZSBkcmF3biwgc2luY2UgdGhlIGNlbnRlciBsaW5lc1xuICogbmVlZCB0byBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIGVycm9yIGJhcnMgZm9yIGFsbCBzZXJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2Vycm9yUGxvdHRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG4gIHZhciBzZXROYW1lID0gZS5zZXROYW1lO1xuICB2YXIgZXJyb3JCYXJzID0gZy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpIHx8XG4gICAgICBnLmdldEJvb2xlYW5PcHRpb24oXCJjdXN0b21CYXJzXCIpO1xuICBpZiAoIWVycm9yQmFycykgcmV0dXJuO1xuXG4gIHZhciBmaWxsR3JhcGggPSBnLmdldEJvb2xlYW5PcHRpb24oXCJmaWxsR3JhcGhcIiwgc2V0TmFtZSk7XG4gIGlmIChmaWxsR3JhcGgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDYW4ndCB1c2UgZmlsbEdyYXBoIG9wdGlvbiB3aXRoIGVycm9yIGJhcnNcIik7XG4gIH1cblxuICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgdmFyIGNvbG9yID0gZS5jb2xvcjtcbiAgdmFyIGZpbGxBbHBoYSA9IGcuZ2V0TnVtZXJpY09wdGlvbignZmlsbEFscGhhJywgc2V0TmFtZSk7XG4gIHZhciBzdGVwUGxvdCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0ZXBQbG90XCIsIHNldE5hbWUpO1xuICB2YXIgcG9pbnRzID0gZS5wb2ludHM7XG5cbiAgdmFyIGl0ZXIgPSB1dGlscy5jcmVhdGVJdGVyYXRvcihwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsXG4gICAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2dldEl0ZXJhdG9yUHJlZGljYXRlKFxuICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICB2YXIgbmV3WXM7XG5cbiAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dFxuICB2YXIgcHJldlggPSBOYU47XG4gIHZhciBwcmV2WSA9IE5hTjtcbiAgdmFyIHByZXZZcyA9IFstMSwgLTFdO1xuICAvLyBzaG91bGQgYmUgc2FtZSBjb2xvciBhcyB0aGUgbGluZXMgYnV0IG9ubHkgMTUlIG9wYXF1ZS5cbiAgdmFyIHJnYiA9IHV0aWxzLnRvUkdCXyhjb2xvcik7XG4gIHZhciBlcnJfY29sb3IgPVxuICAgICAgJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGZpbGxBbHBoYSArICcpJztcbiAgY3R4LmZpbGxTdHlsZSA9IGVycl9jb2xvcjtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHZhciBpc051bGxVbmRlZmluZWRPck5hTiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggPT09IG51bGwgfHxcbiAgICAgICAgICAgIHggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaXNOYU4oeCkpO1xuICB9O1xuXG4gIHdoaWxlIChpdGVyLmhhc05leHQpIHtcbiAgICB2YXIgcG9pbnQgPSBpdGVyLm5leHQoKTtcbiAgICBpZiAoKCFzdGVwUGxvdCAmJiBpc051bGxVbmRlZmluZWRPck5hTihwb2ludC55KSkgfHxcbiAgICAgICAgKHN0ZXBQbG90ICYmICFpc05hTihwcmV2WSkgJiYgaXNOdWxsVW5kZWZpbmVkT3JOYU4ocHJldlkpKSkge1xuICAgICAgcHJldlggPSBOYU47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBuZXdZcyA9IFsgcG9pbnQueV9ib3R0b20sIHBvaW50LnlfdG9wIF07XG4gICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICBwcmV2WSA9IHBvaW50Lnk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IGRpc2FsbG93cyBudWxscyBpbnNpZGUgdGhlIHBvaW50IGFycmF5cyxcbiAgICAvLyBidXQgaW4gY2FzZSBpdCBoYXBwZW5zIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgc2Vuc2libGUuXG4gICAgaWYgKGlzTmFOKG5ld1lzWzBdKSkgbmV3WXNbMF0gPSBwb2ludC55O1xuICAgIGlmIChpc05hTihuZXdZc1sxXSkpIG5ld1lzWzFdID0gcG9pbnQueTtcblxuICAgIG5ld1lzWzBdID0gZS5wbG90QXJlYS5oICogbmV3WXNbMF0gKyBlLnBsb3RBcmVhLnk7XG4gICAgbmV3WXNbMV0gPSBlLnBsb3RBcmVhLmggKiBuZXdZc1sxXSArIGUucGxvdEFyZWEueTtcbiAgICBpZiAoIWlzTmFOKHByZXZYKSkge1xuICAgICAgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocHJldlgsIHByZXZZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBwcmV2WXNbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwcmV2WCwgcHJldllzWzBdKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMV0pO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVUbyhwcmV2WCwgcHJldllzWzFdKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcHJldllzID0gbmV3WXM7XG4gICAgcHJldlggPSBwb2ludC5jYW52YXN4O1xuICB9XG4gIGN0eC5maWxsKCk7XG59O1xuXG5cbi8qKlxuICogUHJveHkgZm9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB3aGljaCBkcm9wcyBtb3ZlVG8vbGluZVRvIGNhbGxzIHdoaWNoIGFyZVxuICogc3VwZXJmbHVvdXMuIEl0IGFjY3VtdWxhdGVzIGFsbCBtb3ZlbWVudHMgd2hpY2ggaGF2ZW4ndCBjaGFuZ2VkIHRoZSB4LXZhbHVlXG4gKiBhbmQgb25seSBhcHBsaWVzIHRoZSB0d28gd2l0aCB0aGUgbW9zdCBleHRyZW1lIHktdmFsdWVzLlxuICogXG4gKiBDYWxscyB0byBsaW5lVG8vbW92ZVRvIG11c3QgaGF2ZSBub24tZGVjcmVhc2luZyB4LXZhbHVlcy5cbiAqL1xuRHlncmFwaENhbnZhc1JlbmRlcmVyLl9mYXN0Q2FudmFzUHJveHkgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHZhciBwZW5kaW5nQWN0aW9ucyA9IFtdOyAgLy8gYXJyYXkgb2YgW3R5cGUsIHgsIHldIHR1cGxlc1xuICB2YXIgbGFzdFJvdW5kZWRYID0gbnVsbDtcbiAgdmFyIGxhc3RGbHVzaGVkWCA9IG51bGw7XG5cbiAgdmFyIExJTkVfVE8gPSAxLFxuICAgICAgTU9WRV9UTyA9IDI7XG5cbiAgdmFyIGFjdGlvbkNvdW50ID0gMDsgIC8vIG51bWJlciBvZiBtb3ZlVG9zIGFuZCBsaW5lVG9zIHBhc3NlZCB0byBjb250ZXh0LlxuXG4gIC8vIERyb3Agc3VwZXJmbHVvdXMgbW90aW9uc1xuICAvLyBBc3N1bWVzIGFsbCBwZW5kaW5nQWN0aW9ucyBoYXZlIHRoZSBzYW1lIChyb3VuZGVkKSB4LXZhbHVlLlxuICB2YXIgY29tcHJlc3NBY3Rpb25zID0gZnVuY3Rpb24ob3B0X2xvc3NsZXNzT25seSkge1xuICAgIGlmIChwZW5kaW5nQWN0aW9ucy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuXG4gICAgLy8gTG9zc2xlc3MgY29tcHJlc3Npb246IGRyb3AgaW5jb25zZXF1ZW50aWFsIG1vdmVUb3MuXG4gICAgZm9yICh2YXIgaSA9IHBlbmRpbmdBY3Rpb25zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTU9WRV9UTykge1xuICAgICAgICB2YXIgcHJldkFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW2kgLSAxXTtcbiAgICAgICAgaWYgKHByZXZBY3Rpb25bMV0gPT0gYWN0aW9uWzFdICYmIHByZXZBY3Rpb25bMl0gPT0gYWN0aW9uWzJdKSB7XG4gICAgICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9zc2xlc3MgY29tcHJlc3Npb246IC4uLiBkcm9wIGNvbnNlY3V0aXZlIG1vdmVUb3MgLi4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZW5kaW5nQWN0aW9ucy5sZW5ndGggLSAxOyAvKiBpbmNyZW1lbnRlZCBpbnRlcm5hbGx5ICovKSB7XG4gICAgICB2YXIgYWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaV07XG4gICAgICBpZiAoYWN0aW9uWzBdID09IE1PVkVfVE8gJiYgcGVuZGluZ0FjdGlvbnNbaSArIDFdWzBdID09IE1PVkVfVE8pIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvc3N5IGNvbXByZXNzaW9uOiAuLi4gZHJvcCBhbGwgYnV0IHRoZSBleHRyZW1lIHktdmFsdWVzIC4uLlxuICAgIGlmIChwZW5kaW5nQWN0aW9ucy5sZW5ndGggPiAyICYmICFvcHRfbG9zc2xlc3NPbmx5KSB7XG4gICAgICAvLyBrZWVwIGFuIGluaXRpYWwgbW92ZVRvLCBidXQgZHJvcCBhbGwgb3RoZXJzLlxuICAgICAgdmFyIHN0YXJ0SWR4ID0gMDtcbiAgICAgIGlmIChwZW5kaW5nQWN0aW9uc1swXVswXSA9PSBNT1ZFX1RPKSBzdGFydElkeCsrO1xuICAgICAgdmFyIG1pbklkeCA9IG51bGwsIG1heElkeCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJZHg7IGkgPCBwZW5kaW5nQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbaV07XG4gICAgICAgIGlmIChhY3Rpb25bMF0gIT0gTElORV9UTykgY29udGludWU7XG4gICAgICAgIGlmIChtaW5JZHggPT09IG51bGwgJiYgbWF4SWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgbWluSWR4ID0gaTtcbiAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB5ID0gYWN0aW9uWzJdO1xuICAgICAgICAgIGlmICh5IDwgcGVuZGluZ0FjdGlvbnNbbWluSWR4XVsyXSkge1xuICAgICAgICAgICAgbWluSWR4ID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHkgPiBwZW5kaW5nQWN0aW9uc1ttYXhJZHhdWzJdKSB7XG4gICAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1pbkFjdGlvbiA9IHBlbmRpbmdBY3Rpb25zW21pbklkeF0sXG4gICAgICAgICAgbWF4QWN0aW9uID0gcGVuZGluZ0FjdGlvbnNbbWF4SWR4XTtcbiAgICAgIHBlbmRpbmdBY3Rpb25zLnNwbGljZShzdGFydElkeCwgcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gc3RhcnRJZHgpO1xuICAgICAgaWYgKG1pbklkeCA8IG1heElkeCkge1xuICAgICAgICBwZW5kaW5nQWN0aW9ucy5wdXNoKG1pbkFjdGlvbik7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWF4QWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobWluSWR4ID4gbWF4SWR4KSB7XG4gICAgICAgIHBlbmRpbmdBY3Rpb25zLnB1c2gobWF4QWN0aW9uKTtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtaW5BY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0FjdGlvbnMucHVzaChtaW5BY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZmx1c2hBY3Rpb25zID0gZnVuY3Rpb24ob3B0X25vTG9zc3lDb21wcmVzc2lvbikge1xuICAgIGNvbXByZXNzQWN0aW9ucyhvcHRfbm9Mb3NzeUNvbXByZXNzaW9uKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGVuZGluZ0FjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBhY3Rpb24gPSBwZW5kaW5nQWN0aW9uc1tpXTtcbiAgICAgIGlmIChhY3Rpb25bMF0gPT0gTElORV9UTykge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhhY3Rpb25bMV0sIGFjdGlvblsyXSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvblswXSA9PSBNT1ZFX1RPKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGFjdGlvblsxXSwgYWN0aW9uWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmdBY3Rpb25zLmxlbmd0aCkge1xuICAgICAgbGFzdEZsdXNoZWRYID0gcGVuZGluZ0FjdGlvbnNbcGVuZGluZ0FjdGlvbnMubGVuZ3RoIC0gMV1bMV07XG4gICAgfVxuICAgIGFjdGlvbkNvdW50ICs9IHBlbmRpbmdBY3Rpb25zLmxlbmd0aDtcbiAgICBwZW5kaW5nQWN0aW9ucyA9IFtdO1xuICB9O1xuXG4gIHZhciBhZGRBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24sIHgsIHkpIHtcbiAgICB2YXIgcnggPSBNYXRoLnJvdW5kKHgpO1xuICAgIGlmIChsYXN0Um91bmRlZFggPT09IG51bGwgfHwgcnggIT0gbGFzdFJvdW5kZWRYKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbGFyZ2UgZ2FwcyBvbiB0aGUgeC1heGlzLCBpdCdzIGVzc2VudGlhbCB0byBrZWVwIHRoZVxuICAgICAgLy8gZmlyc3QgYW5kIGxhc3QgcG9pbnQgYXMgd2VsbC5cbiAgICAgIHZhciBoYXNHYXBPbkxlZnQgPSAobGFzdFJvdW5kZWRYIC0gbGFzdEZsdXNoZWRYID4gMSksXG4gICAgICAgICAgaGFzR2FwT25SaWdodCA9IChyeCAtIGxhc3RSb3VuZGVkWCA+IDEpLFxuICAgICAgICAgIGhhc0dhcCA9IGhhc0dhcE9uTGVmdCB8fCBoYXNHYXBPblJpZ2h0O1xuICAgICAgZmx1c2hBY3Rpb25zKGhhc0dhcCk7XG4gICAgICBsYXN0Um91bmRlZFggPSByeDtcbiAgICB9XG4gICAgcGVuZGluZ0FjdGlvbnMucHVzaChbYWN0aW9uLCB4LCB5XSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGFkZEFjdGlvbihNT1ZFX1RPLCB4LCB5KTtcbiAgICB9LFxuICAgIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgYWRkQWN0aW9uKExJTkVfVE8sIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvLyBmb3IgbWFqb3Igb3BlcmF0aW9ucyBsaWtlIHN0cm9rZS9maWxsLCB3ZSBza2lwIGNvbXByZXNzaW9uIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgdGhlcmUgYXJlIG5vIGFydGlmYWN0cyBhdCB0aGUgcmlnaHQgZWRnZS5cbiAgICBzdHJva2U6ICAgIGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuc3Ryb2tlKCk7IH0sXG4gICAgZmlsbDogICAgICBmdW5jdGlvbigpIHsgZmx1c2hBY3Rpb25zKHRydWUpOyBjb250ZXh0LmZpbGwoKTsgfSxcbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkgeyBmbHVzaEFjdGlvbnModHJ1ZSk7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH0sXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgZmx1c2hBY3Rpb25zKHRydWUpOyBjb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuXG4gICAgX2NvdW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIGFjdGlvbkNvdW50OyB9XG4gIH07XG59O1xuXG4vKipcbiAqIERyYXdzIHRoZSBzaGFkZWQgcmVnaW9ucyB3aGVuIFwiZmlsbEdyYXBoXCIgaXMgc2V0LiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuICogZXJyb3IgYmFycy5cbiAqXG4gKiBGb3Igc3RhY2tlZCBjaGFydHMsIGl0J3MgbW9yZSBjb252ZW5pZW50IHRvIGhhbmRsZSBhbGwgdGhlIHNlcmllc1xuICogc2ltdWx0YW5lb3VzbHkuIFNvIHRoaXMgcGxvdHRlciBwbG90cyBhbGwgdGhlIHBvaW50cyBvbiB0aGUgZmlyc3Qgc2VyaWVzXG4gKiBpdCdzIGFza2VkIHRvIGRyYXcsIHRoZW4gaWdub3JlcyBhbGwgdGhlIG90aGVyIHNlcmllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2ZpbGxQbG90dGVyID0gZnVuY3Rpb24oZSkge1xuICAvLyBTa2lwIGlmIHdlJ3JlIGRyYXdpbmcgYSBzaW5nbGUgc2VyaWVzIGZvciBpbnRlcmFjdGl2ZSBoaWdobGlnaHQgb3ZlcmxheS5cbiAgaWYgKGUuc2luZ2xlU2VyaWVzTmFtZSkgcmV0dXJuO1xuXG4gIC8vIFdlJ2xsIGhhbmRsZSBhbGwgdGhlIHNlcmllcyBhdCBvbmNlLCBub3Qgb25lLWJ5LW9uZS5cbiAgaWYgKGUuc2VyaWVzSW5kZXggIT09IDApIHJldHVybjtcblxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIHNldE5hbWVzID0gZy5nZXRMYWJlbHMoKS5zbGljZSgxKTsgIC8vIHJlbW92ZSB4LWF4aXNcblxuICAvLyBnZXRMYWJlbHMoKSBpbmNsdWRlcyBuYW1lcyBmb3IgaW52aXNpYmxlIHNlcmllcywgd2hpY2ggYXJlIG5vdCBpbmNsdWRlZCBpblxuICAvLyBhbGxTZXJpZXNQb2ludHMuIFdlIHJlbW92ZSB0aG9zZSB0byBtYWtlIHRoZSB0d28gbWF0Y2guXG4gIC8vIFRPRE8oZGFudmspOiBwcm92aWRlIGEgc2ltcGxlciB3YXkgdG8gZ2V0IHRoaXMgaW5mb3JtYXRpb24uXG4gIGZvciAodmFyIGkgPSBzZXROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFnLnZpc2liaWxpdHkoKVtpXSkgc2V0TmFtZXMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgdmFyIGFueVNlcmllc0ZpbGxlZCA9IChmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZy5nZXRCb29sZWFuT3B0aW9uKFwiZmlsbEdyYXBoXCIsIHNldE5hbWVzW2ldKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSkoKTtcblxuICBpZiAoIWFueVNlcmllc0ZpbGxlZCkgcmV0dXJuO1xuXG4gIHZhciBhcmVhID0gZS5wbG90QXJlYTtcbiAgdmFyIHNldHMgPSBlLmFsbFNlcmllc1BvaW50cztcbiAgdmFyIHNldENvdW50ID0gc2V0cy5sZW5ndGg7XG5cbiAgdmFyIHN0YWNrZWRHcmFwaCA9IGcuZ2V0Qm9vbGVhbk9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGNvbG9ycyA9IGcuZ2V0Q29sb3JzKCk7XG5cbiAgLy8gRm9yIHN0YWNrZWQgZ3JhcGhzLCB0cmFjayB0aGUgYmFzZWxpbmUgZm9yIGZpbGxpbmcuXG4gIC8vXG4gIC8vIFRoZSBmaWxsZWQgYXJlYXMgYmVsb3cgZ3JhcGggbGluZXMgYXJlIHRyYXBlem9pZHMgd2l0aCB0d29cbiAgLy8gdmVydGljYWwgZWRnZXMuIFRoZSB0b3AgZWRnZSBpcyB0aGUgbGluZSBzZWdtZW50IGJlaW5nIGRyYXduLCBhbmRcbiAgLy8gdGhlIGJhc2VsaW5lIGlzIHRoZSBib3R0b20gZWRnZS4gRWFjaCBiYXNlbGluZSBjb3JyZXNwb25kcyB0byB0aGVcbiAgLy8gdG9wIGxpbmUgc2VnbWVudCBmcm9tIHRoZSBwcmV2aW91cyBzdGFja2VkIGxpbmUuIEluIHRoZSBjYXNlIG9mXG4gIC8vIHN0ZXAgcGxvdHMsIHRoZSB0cmFwZXpvaWRzIGFyZSByZWN0YW5nbGVzLlxuICB2YXIgYmFzZWxpbmUgPSB7fTtcbiAgdmFyIGN1cnJCYXNlbGluZTtcbiAgdmFyIHByZXZTdGVwUGxvdDsgIC8vIGZvciBkaWZmZXJlbnQgbGluZSBkcmF3aW5nIG1vZGVzIChsaW5lL3N0ZXApIHBlciBzZXJpZXNcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhY2UgYSBsaW5lIGJhY2sgYWxvbmcgdGhlIGJhc2VsaW5lLlxuICB2YXIgdHJhY2VCYWNrUGF0aCA9IGZ1bmN0aW9uKGN0eCwgYmFzZWxpbmVYLCBiYXNlbGluZVksIHBhdGhCYWNrKSB7XG4gICAgY3R4LmxpbmVUbyhiYXNlbGluZVgsIGJhc2VsaW5lWSk7XG4gICAgaWYgKHN0YWNrZWRHcmFwaCkge1xuICAgICAgZm9yICh2YXIgaSA9IHBhdGhCYWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBwdCA9IHBhdGhCYWNrW2ldO1xuICAgICAgICBjdHgubGluZVRvKHB0WzBdLCBwdFsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHByb2Nlc3Mgc2V0cyBpbiByZXZlcnNlIG9yZGVyIChuZWVkZWQgZm9yIHN0YWNrZWQgZ3JhcGhzKVxuICBmb3IgKHZhciBzZXRJZHggPSBzZXRDb3VudCAtIDE7IHNldElkeCA+PSAwOyBzZXRJZHgtLSkge1xuICAgIHZhciBjdHggPSBlLmRyYXdpbmdDb250ZXh0O1xuICAgIHZhciBzZXROYW1lID0gc2V0TmFtZXNbc2V0SWR4XTtcbiAgICBpZiAoIWcuZ2V0Qm9vbGVhbk9wdGlvbignZmlsbEdyYXBoJywgc2V0TmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIGZpbGxBbHBoYSA9IGcuZ2V0TnVtZXJpY09wdGlvbignZmlsbEFscGhhJywgc2V0TmFtZSk7XG4gICAgdmFyIHN0ZXBQbG90ID0gZy5nZXRCb29sZWFuT3B0aW9uKCdzdGVwUGxvdCcsIHNldE5hbWUpO1xuICAgIHZhciBjb2xvciA9IGNvbG9yc1tzZXRJZHhdO1xuICAgIHZhciBheGlzID0gZy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICB2YXIgYXhpc1kgPSAxLjAgKyBheGlzLm1pbnl2YWwgKiBheGlzLnlzY2FsZTtcbiAgICBpZiAoYXhpc1kgPCAwLjApIGF4aXNZID0gMC4wO1xuICAgIGVsc2UgaWYgKGF4aXNZID4gMS4wKSBheGlzWSA9IDEuMDtcbiAgICBheGlzWSA9IGFyZWEuaCAqIGF4aXNZICsgYXJlYS55O1xuXG4gICAgdmFyIHBvaW50cyA9IHNldHNbc2V0SWR4XTtcbiAgICB2YXIgaXRlciA9IHV0aWxzLmNyZWF0ZUl0ZXJhdG9yKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgRHlncmFwaENhbnZhc1JlbmRlcmVyLl9nZXRJdGVyYXRvclByZWRpY2F0ZShcbiAgICAgICAgICAgIGcuZ2V0Qm9vbGVhbk9wdGlvbihcImNvbm5lY3RTZXBhcmF0ZWRQb2ludHNcIiwgc2V0TmFtZSkpKTtcblxuICAgIC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHRcbiAgICB2YXIgcHJldlggPSBOYU47XG4gICAgdmFyIHByZXZZcyA9IFstMSwgLTFdO1xuICAgIHZhciBuZXdZcztcbiAgICAvLyBzaG91bGQgYmUgc2FtZSBjb2xvciBhcyB0aGUgbGluZXMgYnV0IG9ubHkgMTUlIG9wYXF1ZS5cbiAgICB2YXIgcmdiID0gdXRpbHMudG9SR0JfKGNvbG9yKTtcbiAgICB2YXIgZXJyX2NvbG9yID1cbiAgICAgICAgJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGZpbGxBbHBoYSArICcpJztcbiAgICBjdHguZmlsbFN0eWxlID0gZXJyX2NvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgbGFzdF94LCBpc19maXJzdCA9IHRydWU7XG5cbiAgICAvLyBJZiB0aGUgcG9pbnQgZGVuc2l0eSBpcyBoaWdoIGVub3VnaCwgZHJvcHBpbmcgc2VnbWVudHMgb24gdGhlaXIgd2F5IHRvXG4gICAgLy8gdGhlIGNhbnZhcyBqdXN0aWZpZXMgdGhlIG92ZXJoZWFkIG9mIGRvaW5nIHNvLlxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMiAqIGcud2lkdGhfIHx8IER5Z3JhcGguRk9SQ0VfRkFTVF9QUk9YWSkge1xuICAgICAgY3R4ID0gRHlncmFwaENhbnZhc1JlbmRlcmVyLl9mYXN0Q2FudmFzUHJveHkoY3R4KTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZmlsbGVkIGNoYXJ0cywgd2UgZHJhdyBwb2ludHMgZnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGVuIGJhY2sgYWxvbmdcbiAgICAvLyB0aGUgeC1heGlzIHRvIGNvbXBsZXRlIGEgc2hhcGUgZm9yIGZpbGxpbmcuXG4gICAgLy8gRm9yIHN0YWNrZWQgcGxvdHMsIHRoaXMgXCJiYWNrIHBhdGhcIiBpcyBhIG1vcmUgY29tcGxleCBzaGFwZS4gVGhpcyBhcnJheVxuICAgIC8vIHN0b3JlcyB0aGUgW3gsIHldIHZhbHVlcyBuZWVkZWQgdG8gdHJhY2UgdGhhdCBzaGFwZS5cbiAgICB2YXIgcGF0aEJhY2sgPSBbXTtcblxuICAgIC8vIFRPRE8oZGFudmspOiB0aGVyZSBhcmUgYSBsb3Qgb2Ygb3B0aW9ucyBhdCBwbGF5IGluIHRoaXMgbG9vcC5cbiAgICAvLyAgICAgVGhlIGxvZ2ljIHdvdWxkIGJlIG11Y2ggY2xlYXJlciBpZiBzb21lIChlLmcuIHN0YWNrR3JhcGggYW5kXG4gICAgLy8gICAgIHN0ZXBQbG90KSB3ZXJlIHNwbGl0IG9mZiBpbnRvIHNlcGFyYXRlIHN1Yi1wbG90dGVycy5cbiAgICB2YXIgcG9pbnQ7XG4gICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCkge1xuICAgICAgcG9pbnQgPSBpdGVyLm5leHQoKTtcbiAgICAgIGlmICghdXRpbHMuaXNPSyhwb2ludC55KSAmJiAhc3RlcFBsb3QpIHtcbiAgICAgICAgdHJhY2VCYWNrUGF0aChjdHgsIHByZXZYLCBwcmV2WXNbMV0sIHBhdGhCYWNrKTtcbiAgICAgICAgcGF0aEJhY2sgPSBbXTtcbiAgICAgICAgcHJldlggPSBOYU47XG4gICAgICAgIGlmIChwb2ludC55X3N0YWNrZWQgIT09IG51bGwgJiYgIWlzTmFOKHBvaW50Lnlfc3RhY2tlZCkpIHtcbiAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IGFyZWEuaCAqIHBvaW50Lnlfc3RhY2tlZCArIGFyZWEueTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkR3JhcGgpIHtcbiAgICAgICAgaWYgKCFpc19maXJzdCAmJiBsYXN0X3ggPT0gcG9pbnQueHZhbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzX2ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgbGFzdF94ID0gcG9pbnQueHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJCYXNlbGluZSA9IGJhc2VsaW5lW3BvaW50LmNhbnZhc3hdO1xuICAgICAgICB2YXIgbGFzdFk7XG4gICAgICAgIGlmIChjdXJyQmFzZWxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RZID0gYXhpc1k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYocHJldlN0ZXBQbG90KSB7XG4gICAgICAgICAgICBsYXN0WSA9IGN1cnJCYXNlbGluZVswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFkgPSBjdXJyQmFzZWxpbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1lzID0gWyBwb2ludC5jYW52YXN5LCBsYXN0WSBdO1xuXG4gICAgICAgIGlmIChzdGVwUGxvdCkge1xuICAgICAgICAgIC8vIFN0ZXAgcGxvdHMgbXVzdCBrZWVwIHRyYWNrIG9mIHRoZSB0b3AgYW5kIGJvdHRvbSBvZlxuICAgICAgICAgIC8vIHRoZSBiYXNlbGluZSBhdCBlYWNoIHBvaW50LlxuICAgICAgICAgIGlmIChwcmV2WXNbMF0gPT09IC0xKSB7XG4gICAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IFsgcG9pbnQuY2FudmFzeSwgYXhpc1kgXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZWxpbmVbcG9pbnQuY2FudmFzeF0gPSBbIHBvaW50LmNhbnZhc3ksIHByZXZZc1swXSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlbGluZVtwb2ludC5jYW52YXN4XSA9IHBvaW50LmNhbnZhc3k7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFOKHBvaW50LmNhbnZhc3kpICYmIHN0ZXBQbG90KSB7XG4gICAgICAgICAgbmV3WXMgPSBbIGFyZWEueSArIGFyZWEuaCwgYXhpc1kgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdZcyA9IFsgcG9pbnQuY2FudmFzeSwgYXhpc1kgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc05hTihwcmV2WCkpIHtcbiAgICAgICAgLy8gTW92ZSB0byB0b3AgZmlsbCBwb2ludFxuICAgICAgICBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIHByZXZZc1swXSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC5jYW52YXN4LCBuZXdZc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvcmQgdGhlIGJhc2VsaW5lIGZvciB0aGUgcmV2ZXJzZSBwYXRoLlxuICAgICAgICBpZiAoc3RhY2tlZEdyYXBoKSB7XG4gICAgICAgICAgcGF0aEJhY2sucHVzaChbcHJldlgsIHByZXZZc1sxXV0pO1xuICAgICAgICAgIGlmIChwcmV2U3RlcFBsb3QgJiYgY3VyckJhc2VsaW5lKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRvIHRoZSBib3R0b20gb2YgdGhlIGJhc2VsaW5lXG4gICAgICAgICAgICBwYXRoQmFjay5wdXNoKFtwb2ludC5jYW52YXN4LCBjdXJyQmFzZWxpbmVbMV1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aEJhY2sucHVzaChbcG9pbnQuY2FudmFzeCwgbmV3WXNbMV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQuY2FudmFzeCwgbmV3WXNbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LmNhbnZhc3gsIG5ld1lzWzBdKTtcbiAgICAgIH1cbiAgICAgIHByZXZZcyA9IG5ld1lzO1xuICAgICAgcHJldlggPSBwb2ludC5jYW52YXN4O1xuICAgIH1cbiAgICBwcmV2U3RlcFBsb3QgPSBzdGVwUGxvdDtcbiAgICBpZiAobmV3WXMgJiYgcG9pbnQpIHtcbiAgICAgIHRyYWNlQmFja1BhdGgoY3R4LCBwb2ludC5jYW52YXN4LCBuZXdZc1sxXSwgcGF0aEJhY2spO1xuICAgICAgcGF0aEJhY2sgPSBbXTtcbiAgICB9XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRHlncmFwaENhbnZhc1JlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIER5Z3JhcGhUaWNrZXJzIGZyb20gJy4vZHlncmFwaC10aWNrZXJzJztcbmltcG9ydCBEeWdyYXBoSW50ZXJhY3Rpb24gZnJvbSAnLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBEeWdyYXBoQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9keWdyYXBoLWNhbnZhcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vLyBEZWZhdWx0IGF0dHJpYnV0ZSB2YWx1ZXMuXG52YXIgREVGQVVMVF9BVFRSUyA9IHtcbiAgaGlnaGxpZ2h0Q2lyY2xlU2l6ZTogMyxcbiAgaGlnaGxpZ2h0U2VyaWVzT3B0czogbnVsbCxcbiAgaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZEFscGhhOiAwLjUsXG4gIGhpZ2hsaWdodFNlcmllc0JhY2tncm91bmRDb2xvcjogJ3JnYigyNTUsIDI1NSwgMjU1KScsXG5cbiAgbGFiZWxzRGl2V2lkdGg6IDI1MCxcbiAgbGFiZWxzRGl2U3R5bGVzOiB7XG4gICAgLy8gVE9ETyhkYW52ayk6IG1vdmUgZGVmYXVsdHMgZnJvbSBjcmVhdGVTdGF0dXNNZXNzYWdlXyBoZXJlLlxuICB9LFxuICBsYWJlbHNTZXBhcmF0ZUxpbmVzOiBmYWxzZSxcbiAgbGFiZWxzU2hvd1plcm9WYWx1ZXM6IHRydWUsXG4gIGxhYmVsc0tNQjogZmFsc2UsXG4gIGxhYmVsc0tNRzI6IGZhbHNlLFxuICBzaG93TGFiZWxzT25IaWdobGlnaHQ6IHRydWUsXG5cbiAgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAyLFxuICBtYXhOdW1iZXJXaWR0aDogNixcbiAgc2lnRmlnczogbnVsbCxcblxuICBzdHJva2VXaWR0aDogMS4wLFxuICBzdHJva2VCb3JkZXJXaWR0aDogMCxcbiAgc3Ryb2tlQm9yZGVyQ29sb3I6IFwid2hpdGVcIixcblxuICBheGlzVGlja1NpemU6IDMsXG4gIGF4aXNMYWJlbEZvbnRTaXplOiAxNCxcbiAgcmlnaHRHYXA6IDUsXG5cbiAgc2hvd1JvbGxlcjogZmFsc2UsXG4gIHhWYWx1ZVBhcnNlcjogdW5kZWZpbmVkLFxuXG4gIGRlbGltaXRlcjogJywnLFxuXG4gIHNpZ21hOiAyLjAsXG4gIGVycm9yQmFyczogZmFsc2UsXG4gIGZyYWN0aW9uczogZmFsc2UsXG4gIHdpbHNvbkludGVydmFsOiB0cnVlLCAgLy8gb25seSByZWxldmFudCBpZiBmcmFjdGlvbnMgaXMgdHJ1ZVxuICBjdXN0b21CYXJzOiBmYWxzZSxcbiAgZmlsbEdyYXBoOiBmYWxzZSxcbiAgZmlsbEFscGhhOiAwLjE1LFxuICBjb25uZWN0U2VwYXJhdGVkUG9pbnRzOiBmYWxzZSxcblxuICBzdGFja2VkR3JhcGg6IGZhbHNlLFxuICBzdGFja2VkR3JhcGhOYU5GaWxsOiAnYWxsJyxcbiAgaGlkZU92ZXJsYXlPbk1vdXNlT3V0OiB0cnVlLFxuXG4gIGxlZ2VuZDogJ29ubW91c2VvdmVyJyxcbiAgc3RlcFBsb3Q6IGZhbHNlLFxuICBhdm9pZE1pblplcm86IGZhbHNlLFxuICB4UmFuZ2VQYWQ6IDAsXG4gIHlSYW5nZVBhZDogbnVsbCxcbiAgZHJhd0F4ZXNBdFplcm86IGZhbHNlLFxuXG4gIC8vIFNpemVzIG9mIHRoZSB2YXJpb3VzIGNoYXJ0IGxhYmVscy5cbiAgdGl0bGVIZWlnaHQ6IDI4LFxuICB4TGFiZWxIZWlnaHQ6IDE4LFxuICB5TGFiZWxXaWR0aDogMTgsXG5cbiAgYXhpc0xpbmVDb2xvcjogXCJibGFja1wiLFxuICBheGlzTGluZVdpZHRoOiAwLjMsXG4gIGdyaWRMaW5lV2lkdGg6IDAuMyxcbiAgYXhpc0xhYmVsQ29sb3I6IFwiYmxhY2tcIixcbiAgYXhpc0xhYmVsV2lkdGg6IDUwLFxuICBncmlkTGluZUNvbG9yOiBcInJnYigxMjgsMTI4LDEyOClcIixcblxuICBpbnRlcmFjdGlvbk1vZGVsOiBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsLFxuICBhbmltYXRlZFpvb21zOiBmYWxzZSwgIC8vIChmb3Igbm93KVxuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIG9wdGlvbnNcbiAgc2hvd1JhbmdlU2VsZWN0b3I6IGZhbHNlLFxuICByYW5nZVNlbGVjdG9ySGVpZ2h0OiA0MCxcbiAgcmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcjogXCIjODA4RkFCXCIsXG4gIHJhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3I6IFwid2hpdGVcIixcbiAgcmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3I6IFwiI0E3QjFDNFwiLFxuICByYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yOiBcImdyYXlcIixcbiAgcmFuZ2VTZWxlY3RvckJhY2tncm91bmRMaW5lV2lkdGg6IDEsXG4gIHJhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoOjEuNSxcbiAgcmFuZ2VTZWxlY3RvckZvcmVncm91bmRTdHJva2VDb2xvcjogXCJibGFja1wiLFxuICByYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aDogMSxcbiAgcmFuZ2VTZWxlY3RvckFscGhhOiAwLjYsXG4gIHNob3dJblJhbmdlU2VsZWN0b3I6IG51bGwsXG5cbiAgLy8gVGhlIG9yZGVyaW5nIGhlcmUgZW5zdXJlcyB0aGF0IGNlbnRyYWwgbGluZXMgYWx3YXlzIGFwcGVhciBhYm92ZSBhbnlcbiAgLy8gZmlsbCBiYXJzL2Vycm9yIGJhcnMuXG4gIHBsb3R0ZXI6IFtcbiAgICBEeWdyYXBoQ2FudmFzUmVuZGVyZXIuX2ZpbGxQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fZXJyb3JQbG90dGVyLFxuICAgIER5Z3JhcGhDYW52YXNSZW5kZXJlci5fbGluZVBsb3R0ZXJcbiAgXSxcblxuICBwbHVnaW5zOiBbIF0sXG5cbiAgLy8gcGVyLWF4aXMgb3B0aW9uc1xuICBheGVzOiB7XG4gICAgeDoge1xuICAgICAgcGl4ZWxzUGVyTGFiZWw6IDcwLFxuICAgICAgYXhpc0xhYmVsV2lkdGg6IDYwLFxuICAgICAgYXhpc0xhYmVsRm9ybWF0dGVyOiB1dGlscy5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyLFxuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5kYXRlVGlja2VyXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdHcmlkOiB0cnVlLFxuICAgICAgZHJhd0F4aXM6IHRydWUsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiB0cnVlLFxuICAgICAgdGlja2VyOiBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3NcbiAgICB9LFxuICAgIHkyOiB7XG4gICAgICBheGlzTGFiZWxXaWR0aDogNTAsXG4gICAgICBwaXhlbHNQZXJMYWJlbDogMzAsXG4gICAgICB2YWx1ZUZvcm1hdHRlcjogdXRpbHMubnVtYmVyVmFsdWVGb3JtYXR0ZXIsXG4gICAgICBheGlzTGFiZWxGb3JtYXR0ZXI6IHV0aWxzLm51bWJlckF4aXNMYWJlbEZvcm1hdHRlcixcbiAgICAgIGRyYXdBeGlzOiB0cnVlLCAgLy8gb25seSBhcHBsaWVzIHdoZW4gdGhlcmUgYXJlIHR3byBheGVzIG9mIGRhdGEuXG4gICAgICBkcmF3R3JpZDogZmFsc2UsXG4gICAgICBpbmRlcGVuZGVudFRpY2tzOiBmYWxzZSxcbiAgICAgIHRpY2tlcjogRHlncmFwaFRpY2tlcnMubnVtZXJpY1RpY2tzXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBERUZBVUxUX0FUVFJTO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSB3cmFwcGVyIGFyb3VuZCB0aGUgRHlncmFwaCBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogaW50ZXJmYWNlIGZvciBhIEdWaXogKGFrYSBHb29nbGUgVmlzdWFsaXphdGlvbiBBUEkpIHZpc3VhbGl6YXRpb24uXG4gKiBJdCBpcyBkZXNpZ25lZCB0byBiZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIEdvb2dsZSdzIEFubm90YXRlZFRpbWVsaW5lLFxuICogc28gdGhlIGRvY3VtZW50YXRpb24gYXRcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vYXBpcy9jaGFydC9pbnRlcmFjdGl2ZS9kb2NzL2dhbGxlcnkvYW5ub3RhdGVkdGltZWxpbmUuaHRtbFxuICogdHJhbnNsYXRlcyBvdmVyIGRpcmVjdGx5LlxuICpcbiAqIEZvciBhIGZ1bGwgZGVtbywgc2VlOlxuICogLSBodHRwOi8vZHlncmFwaHMuY29tL3Rlc3RzL2d2aXouaHRtbFxuICogLSBodHRwOi8vZHlncmFwaHMuY29tL3Rlc3RzL2Fubm90YXRpb24tZ3Zpei5odG1sXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBEeWdyYXBoIGZyb20gJy4vZHlncmFwaCc7XG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBEeWdyYXBoIHRoYXQgaW1wbGVtZW50cyB0aGUgZ3ZpeiBBUEkuXG4gKiBAcGFyYW0geyFIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIFRoZSBET00gb2JqZWN0IHRoZSB2aXN1YWxpemF0aW9uIHNob3VsZFxuICogICAgIGxpdmUgaW4uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdWaXpDaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtHVml6RGF0YVRhYmxlfSBkYXRhXG4gKiBAcGFyYW0ge09iamVjdC48Kj59IG9wdGlvbnNcbiAqL1xuR1ZpekNoYXJ0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAvLyBDbGVhciBvdXQgYW55IGV4aXN0aW5nIGR5Z3JhcGguXG4gIC8vIFRPRE8oZGFudmspOiB3b3VsZCBpdCBtYWtlIG1vcmUgc2Vuc2UgdG8gc2ltcGx5IHJlZHJhdyB1c2luZyB0aGUgY3VycmVudFxuICAvLyBkYXRlX2dyYXBoIG9iamVjdD9cbiAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gIGlmICh0eXBlb2YodGhpcy5kYXRlX2dyYXBoKSAhPSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZGF0ZV9ncmFwaC5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLmRhdGVfZ3JhcGggPSBuZXcgRHlncmFwaCh0aGlzLmNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEdvb2dsZSBjaGFydHMgY29tcGF0aWJsZSBzZXRTZWxlY3Rpb25cbiAqIE9ubHkgcm93IHNlbGVjdGlvbiBpcyBzdXBwb3J0ZWQsIGFsbCBwb2ludHMgaW4gdGhlIHJvdyB3aWxsIGJlIGhpZ2hsaWdodGVkXG4gKiBAcGFyYW0ge0FycmF5Ljx7cm93Om51bWJlcn0+fSBzZWxlY3Rpb25fYXJyYXkgYXJyYXkgb2YgdGhlIHNlbGVjdGVkIGNlbGxzXG4gKiBAcHVibGljXG4gKi9cbkdWaXpDaGFydC5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsZWN0aW9uX2FycmF5KSB7XG4gIHZhciByb3cgPSBmYWxzZTtcbiAgaWYgKHNlbGVjdGlvbl9hcnJheS5sZW5ndGgpIHtcbiAgICByb3cgPSBzZWxlY3Rpb25fYXJyYXlbMF0ucm93O1xuICB9XG4gIHRoaXMuZGF0ZV9ncmFwaC5zZXRTZWxlY3Rpb24ocm93KTtcbn07XG5cbi8qKlxuICogR29vZ2xlIGNoYXJ0cyBjb21wYXRpYmxlIGdldFNlbGVjdGlvbiBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7QXJyYXkuPHtyb3c6bnVtYmVyLGNvbHVtbjpudW1iZXJ9Pn0gYXJyYXkgb2YgdGhlIHNlbGVjdGVkIGNlbGxzXG4gKiBAcHVibGljXG4gKi9cbkdWaXpDaGFydC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBbXTtcblxuICB2YXIgcm93ID0gdGhpcy5kYXRlX2dyYXBoLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChyb3cgPCAwKSByZXR1cm4gc2VsZWN0aW9uO1xuXG4gIHZhciBwb2ludHMgPSB0aGlzLmRhdGVfZ3JhcGgubGF5b3V0Xy5wb2ludHM7XG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHBvaW50cy5sZW5ndGg7ICsrc2V0SWR4KSB7XG4gICAgc2VsZWN0aW9uLnB1c2goe3Jvdzogcm93LCBjb2x1bW46IHNldElkeCArIDF9KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb247XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHVml6Q2hhcnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBSb2JlcnQgS29uaWdzYmVyZyAoa29uaWdzYmVyZ0Bnb29nbGUuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGUgZGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlbCBmb3IgRHlncmFwaHMuIFRoaXMgaXMga2VwdCBvdXRcbiAqIG9mIGR5Z3JhcGguanMgZm9yIGJldHRlciBuYXZpZ2FiaWxpdHkuXG4gKiBAYXV0aG9yIFJvYmVydCBLb25pZ3NiZXJnIChrb25pZ3NiZXJnQGdvb2dsZS5jb20pXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5cbi8qKlxuICogWW91IGNhbiBkcmFnIHRoaXMgbWFueSBwaXhlbHMgcGFzdCB0aGUgZWRnZSBvZiB0aGUgY2hhcnQgYW5kIHN0aWxsIGhhdmUgaXRcbiAqIGJlIGNvbnNpZGVyZWQgYSB6b29tLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byB6b29tIHRvIHRoZSBleGFjdCBlZGdlIG9mIHRoZVxuICogY2hhcnQsIGEgZmFpcmx5IGNvbW1vbiBvcGVyYXRpb24uXG4gKi9cbnZhciBEUkFHX0VER0VfTUFSR0lOID0gMTAwO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdG8gZmFjaWxpdGF0ZSBidWlsZCBjdXN0b20gaW50ZXJhY3Rpb24gbW9kZWxzLlxuICogQGNsYXNzXG4gKi9cbnZhciBEeWdyYXBoSW50ZXJhY3Rpb24gPSB7fTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYmVnaW5uaW5nICYgZW5kaW5nIG9mIGFuIGV2ZW50IHdlcmUgY2xvc2UgZW5vdWdoIHRoYXQgaXRcbiAqIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2xpY2suIElmIGl0IHNob3VsZCwgZGlzcGF0Y2ggYXBwcm9wcmlhdGUgZXZlbnRzLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBldmVudCB3YXMgdHJlYXRlZCBhcyBhIGNsaWNrLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGdcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tYXliZVRyZWF0TW91c2VPcEFzQ2xpY2sgPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBjb250ZXh0LmRyYWdFbmRYID0gdXRpbHMuZHJhZ0dldFhfKGV2ZW50LCBjb250ZXh0KTtcbiAgY29udGV4dC5kcmFnRW5kWSA9IHV0aWxzLmRyYWdHZXRZXyhldmVudCwgY29udGV4dCk7XG4gIHZhciByZWdpb25XaWR0aCA9IE1hdGguYWJzKGNvbnRleHQuZHJhZ0VuZFggLSBjb250ZXh0LmRyYWdTdGFydFgpO1xuICB2YXIgcmVnaW9uSGVpZ2h0ID0gTWF0aC5hYnMoY29udGV4dC5kcmFnRW5kWSAtIGNvbnRleHQuZHJhZ1N0YXJ0WSk7XG5cbiAgaWYgKHJlZ2lvbldpZHRoIDwgMiAmJiByZWdpb25IZWlnaHQgPCAyICYmXG4gICAgICBnLmxhc3R4XyAhPT0gdW5kZWZpbmVkICYmIGcubGFzdHhfICE9IC0xKSB7XG4gICAgRHlncmFwaEludGVyYWN0aW9uLnRyZWF0TW91c2VPcEFzQ2xpY2soZywgZXZlbnQsIGNvbnRleHQpO1xuICB9XG5cbiAgY29udGV4dC5yZWdpb25XaWR0aCA9IHJlZ2lvbldpZHRoO1xuICBjb250ZXh0LnJlZ2lvbkhlaWdodCA9IHJlZ2lvbkhlaWdodDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiBzaG91bGQgc3RhcnQgdGhlIGRlZmF1bHQgcGFubmluZyBiZWhhdmlvci5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2Vkb3duXCIgb3BlcmF0aW9ucy5cbiAqIEN1c3RvbSBpbnRlcmFjdGlvbiBtb2RlbCBidWlsZGVycyBjYW4gdXNlIGl0IHRvIHByb3ZpZGUgdGhlIGRlZmF1bHRcbiAqIHBhbm5pbmcgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGV2ZW50IG9iamVjdCB3aGljaCBsZWQgdG8gdGhlIHN0YXJ0UGFuIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgdmFyIGksIGF4aXM7XG4gIGNvbnRleHQuaXNQYW5uaW5nID0gdHJ1ZTtcbiAgdmFyIHhSYW5nZSA9IGcueEF4aXNSYW5nZSgpO1xuXG4gIGlmIChnLmdldE9wdGlvbkZvckF4aXMoXCJsb2dzY2FsZVwiLCBcInhcIikpIHtcbiAgICBjb250ZXh0LmluaXRpYWxMZWZ0bW9zdERhdGUgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMF0pO1xuICAgIGNvbnRleHQuZGF0ZVJhbmdlID0gdXRpbHMubG9nMTAoeFJhbmdlWzFdKSAtIHV0aWxzLmxvZzEwKHhSYW5nZVswXSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5pbml0aWFsTGVmdG1vc3REYXRlID0geFJhbmdlWzBdOyAgICBcbiAgICBjb250ZXh0LmRhdGVSYW5nZSA9IHhSYW5nZVsxXSAtIHhSYW5nZVswXTtcbiAgfVxuICBjb250ZXh0LnhVbml0c1BlclBpeGVsID0gY29udGV4dC5kYXRlUmFuZ2UgLyAoZy5wbG90dGVyXy5hcmVhLncgLSAxKTtcblxuICBpZiAoZy5nZXROdW1lcmljT3B0aW9uKFwicGFuRWRnZUZyYWN0aW9uXCIpKSB7XG4gICAgdmFyIG1heFhQaXhlbHNUb0RyYXcgPSBnLndpZHRoXyAqIGcuZ2V0TnVtZXJpY09wdGlvbihcInBhbkVkZ2VGcmFjdGlvblwiKTtcbiAgICB2YXIgeEV4dHJlbWVzID0gZy54QXhpc0V4dHJlbWVzKCk7IC8vIEkgUkVBTExZIFdBTlQgVE8gQ0FMTCBUSElTIHhUcmVtZXMhXG5cbiAgICB2YXIgYm91bmRlZExlZnRYID0gZy50b0RvbVhDb29yZCh4RXh0cmVtZXNbMF0pIC0gbWF4WFBpeGVsc1RvRHJhdztcbiAgICB2YXIgYm91bmRlZFJpZ2h0WCA9IGcudG9Eb21YQ29vcmQoeEV4dHJlbWVzWzFdKSArIG1heFhQaXhlbHNUb0RyYXc7XG5cbiAgICB2YXIgYm91bmRlZExlZnREYXRlID0gZy50b0RhdGFYQ29vcmQoYm91bmRlZExlZnRYKTtcbiAgICB2YXIgYm91bmRlZFJpZ2h0RGF0ZSA9IGcudG9EYXRhWENvb3JkKGJvdW5kZWRSaWdodFgpO1xuICAgIGNvbnRleHQuYm91bmRlZERhdGVzID0gW2JvdW5kZWRMZWZ0RGF0ZSwgYm91bmRlZFJpZ2h0RGF0ZV07XG5cbiAgICB2YXIgYm91bmRlZFZhbHVlcyA9IFtdO1xuICAgIHZhciBtYXhZUGl4ZWxzVG9EcmF3ID0gZy5oZWlnaHRfICogZy5nZXROdW1lcmljT3B0aW9uKFwicGFuRWRnZUZyYWN0aW9uXCIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIHlFeHRyZW1lcyA9IGF4aXMuZXh0cmVtZVJhbmdlO1xuXG4gICAgICB2YXIgYm91bmRlZFRvcFkgPSBnLnRvRG9tWUNvb3JkKHlFeHRyZW1lc1swXSwgaSkgKyBtYXhZUGl4ZWxzVG9EcmF3O1xuICAgICAgdmFyIGJvdW5kZWRCb3R0b21ZID0gZy50b0RvbVlDb29yZCh5RXh0cmVtZXNbMV0sIGkpIC0gbWF4WVBpeGVsc1RvRHJhdztcblxuICAgICAgdmFyIGJvdW5kZWRUb3BWYWx1ZSA9IGcudG9EYXRhWUNvb3JkKGJvdW5kZWRUb3BZLCBpKTtcbiAgICAgIHZhciBib3VuZGVkQm90dG9tVmFsdWUgPSBnLnRvRGF0YVlDb29yZChib3VuZGVkQm90dG9tWSwgaSk7XG5cbiAgICAgIGJvdW5kZWRWYWx1ZXNbaV0gPSBbYm91bmRlZFRvcFZhbHVlLCBib3VuZGVkQm90dG9tVmFsdWVdO1xuICAgIH1cbiAgICBjb250ZXh0LmJvdW5kZWRWYWx1ZXMgPSBib3VuZGVkVmFsdWVzO1xuICB9XG5cbiAgLy8gUmVjb3JkIHRoZSByYW5nZSBvZiBlYWNoIHktYXhpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGRyYWcuXG4gIC8vIElmIGFueSBheGlzIGhhcyBhIHZhbHVlUmFuZ2Ugb3IgdmFsdWVXaW5kb3csIHRoZW4gd2Ugd2FudCBhIDJEIHBhbi5cbiAgLy8gV2UgY2FuJ3Qgc3RvcmUgZGF0YSBkaXJlY3RseSBpbiBnLmF4ZXNfLCBiZWNhdXNlIGl0IGRvZXMgbm90IGJlbG9uZyB0byB1c1xuICAvLyBhbmQgY291bGQgY2hhbmdlIG91dCBmcm9tIHVuZGVyIHVzIGR1cmluZyBhIHBhbiAoc2F5IGlmIHRoZXJlJ3MgYSBkYXRhXG4gIC8vIHVwZGF0ZSkuXG4gIGNvbnRleHQuaXMyRFBhbiA9IGZhbHNlO1xuICBjb250ZXh0LmF4ZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGcuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICBheGlzID0gZy5heGVzX1tpXTtcbiAgICB2YXIgYXhpc19kYXRhID0ge307XG4gICAgdmFyIHlSYW5nZSA9IGcueUF4aXNSYW5nZShpKTtcbiAgICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBUaGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGluIHxjb250ZXh0fC5cbiAgICAvLyBJbiBsb2cgc2NhbGUsIGluaXRpYWxUb3BWYWx1ZSwgZHJhZ1ZhbHVlUmFuZ2UgYW5kIHVuaXRzUGVyUGl4ZWwgYXJlIGxvZyBzY2FsZS5cbiAgICB2YXIgbG9nc2NhbGUgPSBnLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCBpKTtcbiAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgIGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgPSB1dGlscy5sb2cxMCh5UmFuZ2VbMV0pO1xuICAgICAgYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlID0gdXRpbHMubG9nMTAoeVJhbmdlWzFdKSAtIHV0aWxzLmxvZzEwKHlSYW5nZVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNfZGF0YS5pbml0aWFsVG9wVmFsdWUgPSB5UmFuZ2VbMV07XG4gICAgICBheGlzX2RhdGEuZHJhZ1ZhbHVlUmFuZ2UgPSB5UmFuZ2VbMV0gLSB5UmFuZ2VbMF07XG4gICAgfVxuICAgIGF4aXNfZGF0YS51bml0c1BlclBpeGVsID0gYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlIC8gKGcucGxvdHRlcl8uYXJlYS5oIC0gMSk7XG4gICAgY29udGV4dC5heGVzLnB1c2goYXhpc19kYXRhKTtcblxuICAgIC8vIFdoaWxlIGNhbGN1bGF0aW5nIGF4ZXMsIHNldCAyZHBhbi5cbiAgICBpZiAoYXhpcy52YWx1ZVdpbmRvdyB8fCBheGlzLnZhbHVlUmFuZ2UpIGNvbnRleHQuaXMyRFBhbiA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IHBhbnMgdGhlIHZpZXcuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlbW92ZVwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBtb3ZlUGFuIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLm1vdmVQYW4gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBjb250ZXh0LmRyYWdFbmRYID0gdXRpbHMuZHJhZ0dldFhfKGV2ZW50LCBjb250ZXh0KTtcbiAgY29udGV4dC5kcmFnRW5kWSA9IHV0aWxzLmRyYWdHZXRZXyhldmVudCwgY29udGV4dCk7XG5cbiAgdmFyIG1pbkRhdGUgPSBjb250ZXh0LmluaXRpYWxMZWZ0bW9zdERhdGUgLVxuICAgIChjb250ZXh0LmRyYWdFbmRYIC0gY29udGV4dC5kcmFnU3RhcnRYKSAqIGNvbnRleHQueFVuaXRzUGVyUGl4ZWw7XG4gIGlmIChjb250ZXh0LmJvdW5kZWREYXRlcykge1xuICAgIG1pbkRhdGUgPSBNYXRoLm1heChtaW5EYXRlLCBjb250ZXh0LmJvdW5kZWREYXRlc1swXSk7XG4gIH1cbiAgdmFyIG1heERhdGUgPSBtaW5EYXRlICsgY29udGV4dC5kYXRlUmFuZ2U7XG4gIGlmIChjb250ZXh0LmJvdW5kZWREYXRlcykge1xuICAgIGlmIChtYXhEYXRlID4gY29udGV4dC5ib3VuZGVkRGF0ZXNbMV0pIHtcbiAgICAgIC8vIEFkanVzdCBtaW5EYXRlLCBhbmQgcmVjb21wdXRlIG1heERhdGUuXG4gICAgICBtaW5EYXRlID0gbWluRGF0ZSAtIChtYXhEYXRlIC0gY29udGV4dC5ib3VuZGVkRGF0ZXNbMV0pO1xuICAgICAgbWF4RGF0ZSA9IG1pbkRhdGUgKyBjb250ZXh0LmRhdGVSYW5nZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgXCJ4XCIpKSB7XG4gICAgZy5kYXRlV2luZG93XyA9IFsgTWF0aC5wb3codXRpbHMuTE9HX1NDQUxFLCBtaW5EYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyh1dGlscy5MT0dfU0NBTEUsIG1heERhdGUpIF07XG4gIH0gZWxzZSB7XG4gICAgZy5kYXRlV2luZG93XyA9IFttaW5EYXRlLCBtYXhEYXRlXTsgICAgXG4gIH1cblxuICAvLyB5LWF4aXMgc2NhbGluZyBpcyBhdXRvbWF0aWMgdW5sZXNzIHRoaXMgaXMgYSBmdWxsIDJEIHBhbi5cbiAgaWYgKGNvbnRleHQuaXMyRFBhbikge1xuXG4gICAgdmFyIHBpeGVsc0RyYWdnZWQgPSBjb250ZXh0LmRyYWdFbmRZIC0gY29udGV4dC5kcmFnU3RhcnRZO1xuXG4gICAgLy8gQWRqdXN0IGVhY2ggYXhpcyBhcHByb3ByaWF0ZWx5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZy5heGVzXy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF4aXMgPSBnLmF4ZXNfW2ldO1xuICAgICAgdmFyIGF4aXNfZGF0YSA9IGNvbnRleHQuYXhlc1tpXTtcbiAgICAgIHZhciB1bml0c0RyYWdnZWQgPSBwaXhlbHNEcmFnZ2VkICogYXhpc19kYXRhLnVuaXRzUGVyUGl4ZWw7XG5cbiAgICAgIHZhciBib3VuZGVkVmFsdWUgPSBjb250ZXh0LmJvdW5kZWRWYWx1ZXMgPyBjb250ZXh0LmJvdW5kZWRWYWx1ZXNbaV0gOiBudWxsO1xuXG4gICAgICAvLyBJbiBsb2cgc2NhbGUsIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBhcmUgdGhlIGxvZ3Mgb2YgdGhvc2UgdmFsdWVzLlxuICAgICAgdmFyIG1heFZhbHVlID0gYXhpc19kYXRhLmluaXRpYWxUb3BWYWx1ZSArIHVuaXRzRHJhZ2dlZDtcbiAgICAgIGlmIChib3VuZGVkVmFsdWUpIHtcbiAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1pbihtYXhWYWx1ZSwgYm91bmRlZFZhbHVlWzFdKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5WYWx1ZSA9IG1heFZhbHVlIC0gYXhpc19kYXRhLmRyYWdWYWx1ZVJhbmdlO1xuICAgICAgaWYgKGJvdW5kZWRWYWx1ZSkge1xuICAgICAgICBpZiAobWluVmFsdWUgPCBib3VuZGVkVmFsdWVbMF0pIHtcbiAgICAgICAgICAvLyBBZGp1c3QgbWF4VmFsdWUsIGFuZCByZWNvbXB1dGUgbWluVmFsdWUuXG4gICAgICAgICAgbWF4VmFsdWUgPSBtYXhWYWx1ZSAtIChtaW5WYWx1ZSAtIGJvdW5kZWRWYWx1ZVswXSk7XG4gICAgICAgICAgbWluVmFsdWUgPSBtYXhWYWx1ZSAtIGF4aXNfZGF0YS5kcmFnVmFsdWVSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGcuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGkpKSB7XG4gICAgICAgIGF4aXMudmFsdWVXaW5kb3cgPSBbIE1hdGgucG93KHV0aWxzLkxPR19TQ0FMRSwgbWluVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyh1dGlscy5MT0dfU0NBTEUsIG1heFZhbHVlKSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhpcy52YWx1ZVdpbmRvdyA9IFsgbWluVmFsdWUsIG1heFZhbHVlIF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZy5kcmF3R3JhcGhfKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVyYWN0aW9uIG1vZGVsIG9wZXJhdGlvbiB0aGF0XG4gKiByZXNwb25kcyB0byBhbiBldmVudCB0aGF0IGVuZHMgcGFubmluZy5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2V1cFwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiBwYW5uaW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBlbmRQYW4gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGljaztcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgc3RhcnRzIHpvb21pbmcuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlZG93blwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBzdGFydFpvb20gY2FsbC5cbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBUaGUgZHlncmFwaCBvbiB3aGljaCB0byBhY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZHJhZ2dpbmcgY29udGV4dCBvYmplY3QgKHdpdGhcbiAqICAgICBkcmFnU3RhcnRYL2RyYWdTdGFydFkvZXRjLiBwcm9wZXJ0aWVzKS4gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGVcbiAqICAgICBjb250ZXh0LlxuICovXG5EeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgY29udGV4dC5pc1pvb21pbmcgPSB0cnVlO1xuICBjb250ZXh0Lnpvb21Nb3ZlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgZGVmaW5lcyB6b29tIGJvdW5kYXJpZXMuXG4gKlxuICogSXQncyB1c2VkIGluIHRoZSBkZWZhdWx0IGNhbGxiYWNrIGZvciBcIm1vdXNlbW92ZVwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBtb3ZlWm9vbSBjYWxsLlxuICogQHBhcmFtIHtEeWdyYXBofSBnIFRoZSBkeWdyYXBoIG9uIHdoaWNoIHRvIGFjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBkcmFnZ2luZyBjb250ZXh0IG9iamVjdCAod2l0aFxuICogICAgIGRyYWdTdGFydFgvZHJhZ1N0YXJ0WS9ldGMuIHByb3BlcnRpZXMpLiBUaGlzIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZVxuICogICAgIGNvbnRleHQuXG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlWm9vbSA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuem9vbU1vdmVkID0gdHJ1ZTtcbiAgY29udGV4dC5kcmFnRW5kWCA9IHV0aWxzLmRyYWdHZXRYXyhldmVudCwgY29udGV4dCk7XG4gIGNvbnRleHQuZHJhZ0VuZFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHQpO1xuXG4gIHZhciB4RGVsdGEgPSBNYXRoLmFicyhjb250ZXh0LmRyYWdTdGFydFggLSBjb250ZXh0LmRyYWdFbmRYKTtcbiAgdmFyIHlEZWx0YSA9IE1hdGguYWJzKGNvbnRleHQuZHJhZ1N0YXJ0WSAtIGNvbnRleHQuZHJhZ0VuZFkpO1xuXG4gIC8vIGRyYWcgZGlyZWN0aW9uIHRocmVzaG9sZCBmb3IgeSBheGlzIGlzIHR3aWNlIGFzIGxhcmdlIGFzIHggYXhpc1xuICBjb250ZXh0LmRyYWdEaXJlY3Rpb24gPSAoeERlbHRhIDwgeURlbHRhIC8gMikgPyB1dGlscy5WRVJUSUNBTCA6IHV0aWxzLkhPUklaT05UQUw7XG5cbiAgZy5kcmF3Wm9vbVJlY3RfKFxuICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uLFxuICAgICAgY29udGV4dC5kcmFnU3RhcnRYLFxuICAgICAgY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNvbnRleHQuZHJhZ1N0YXJ0WSxcbiAgICAgIGNvbnRleHQuZHJhZ0VuZFksXG4gICAgICBjb250ZXh0LnByZXZEcmFnRGlyZWN0aW9uLFxuICAgICAgY29udGV4dC5wcmV2RW5kWCxcbiAgICAgIGNvbnRleHQucHJldkVuZFkpO1xuXG4gIGNvbnRleHQucHJldkVuZFggPSBjb250ZXh0LmRyYWdFbmRYO1xuICBjb250ZXh0LnByZXZFbmRZID0gY29udGV4dC5kcmFnRW5kWTtcbiAgY29udGV4dC5wcmV2RHJhZ0RpcmVjdGlvbiA9IGNvbnRleHQuZHJhZ0RpcmVjdGlvbjtcbn07XG5cbi8qKlxuICogVE9ETyhkYW52ayk6IG1vdmUgdGhpcyBsb2dpYyBpbnRvIGR5Z3JhcGguanNcbiAqIEBwYXJhbSB7RHlncmFwaH0gZ1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi50cmVhdE1vdXNlT3BBc0NsaWNrID0gZnVuY3Rpb24oZywgZXZlbnQsIGNvbnRleHQpIHtcbiAgdmFyIGNsaWNrQ2FsbGJhY2sgPSBnLmdldEZ1bmN0aW9uT3B0aW9uKCdjbGlja0NhbGxiYWNrJyk7XG4gIHZhciBwb2ludENsaWNrQ2FsbGJhY2sgPSBnLmdldEZ1bmN0aW9uT3B0aW9uKCdwb2ludENsaWNrQ2FsbGJhY2snKTtcblxuICB2YXIgc2VsZWN0ZWRQb2ludCA9IG51bGw7XG5cbiAgLy8gRmluZCBvdXQgaWYgdGhlIGNsaWNrIG9jY3VycyBvbiBhIHBvaW50LlxuICB2YXIgY2xvc2VzdElkeCA9IC0xO1xuICB2YXIgY2xvc2VzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAvLyBjaGVjayBpZiB0aGUgY2xpY2sgd2FzIG9uIGEgcGFydGljdWxhciBwb2ludC5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnLnNlbFBvaW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGcuc2VsUG9pbnRzX1tpXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnBvdyhwLmNhbnZhc3ggLSBjb250ZXh0LmRyYWdFbmRYLCAyKSArXG4gICAgICAgICAgICAgICAgICAgTWF0aC5wb3cocC5jYW52YXN5IC0gY29udGV4dC5kcmFnRW5kWSwgMik7XG4gICAgaWYgKCFpc05hTihkaXN0YW5jZSkgJiZcbiAgICAgICAgKGNsb3Nlc3RJZHggPT0gLTEgfHwgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpKSB7XG4gICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIGNsb3Nlc3RJZHggPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IGFueSBjbGljayB3aXRoaW4gdHdvIHBpeGVscyBvZiB0aGUgZG90LlxuICB2YXIgcmFkaXVzID0gZy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJykgKyAyO1xuICBpZiAoY2xvc2VzdERpc3RhbmNlIDw9IHJhZGl1cyAqIHJhZGl1cykge1xuICAgIHNlbGVjdGVkUG9pbnQgPSBnLnNlbFBvaW50c19bY2xvc2VzdElkeF07XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRQb2ludCkge1xuICAgIHZhciBlID0ge1xuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIHBvaW50OiBzZWxlY3RlZFBvaW50LFxuICAgICAgY2FudmFzeDogY29udGV4dC5kcmFnRW5kWCxcbiAgICAgIGNhbnZhc3k6IGNvbnRleHQuZHJhZ0VuZFlcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gZy5jYXNjYWRlRXZlbnRzXygncG9pbnRDbGljaycsIGUpO1xuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAvLyBOb3RlOiB0aGlzIGFsc28gcHJldmVudHMgY2xpY2sgLyBjbGlja0NhbGxiYWNrIGZyb20gZmlyaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9pbnRDbGlja0NhbGxiYWNrKSB7XG4gICAgICBwb2ludENsaWNrQ2FsbGJhY2suY2FsbChnLCBldmVudCwgc2VsZWN0ZWRQb2ludCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGUgPSB7XG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB4dmFsOiBnLmxhc3R4XywgIC8vIGNsb3Nlc3QgcG9pbnQgYnkgeCB2YWx1ZVxuICAgIHB0czogZy5zZWxQb2ludHNfLFxuICAgIGNhbnZhc3g6IGNvbnRleHQuZHJhZ0VuZFgsXG4gICAgY2FudmFzeTogY29udGV4dC5kcmFnRW5kWVxuICB9O1xuICBpZiAoIWcuY2FzY2FkZUV2ZW50c18oJ2NsaWNrJywgZSkpIHtcbiAgICBpZiAoY2xpY2tDYWxsYmFjaykge1xuICAgICAgLy8gVE9ETyhkYW52ayk6IHBhc3MgYWxvbmcgbW9yZSBpbmZvIGFib3V0IHRoZSBwb2ludHMsIGUuZy4gJ3gnXG4gICAgICBjbGlja0NhbGxiYWNrLmNhbGwoZywgZXZlbnQsIGcubGFzdHhfLCBnLnNlbFBvaW50c18pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJhY3Rpb24gbW9kZWwgb3BlcmF0aW9uIHRoYXRcbiAqIHJlc3BvbmRzIHRvIGFuIGV2ZW50IHRoYXQgcGVyZm9ybXMgYSB6b29tIGJhc2VkIG9uIHByZXZpb3VzbHkgZGVmaW5lZFxuICogYm91bmRzLi5cbiAqXG4gKiBJdCdzIHVzZWQgaW4gdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIFwibW91c2V1cFwiIG9wZXJhdGlvbnMuXG4gKiBDdXN0b20gaW50ZXJhY3Rpb24gbW9kZWwgYnVpbGRlcnMgY2FuIHVzZSBpdCB0byBwcm92aWRlIHRoZSBkZWZhdWx0XG4gKiB6b29taW5nIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBldmVudCBvYmplY3Qgd2hpY2ggbGVkIHRvIHRoZSBlbmRab29tIGNhbGwuXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IGcgVGhlIGR5Z3JhcGggb24gd2hpY2ggdG8gZW5kIHRoZSB6b29tLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRyYWdnaW5nIGNvbnRleHQgb2JqZWN0ICh3aXRoXG4gKiAgICAgZHJhZ1N0YXJ0WC9kcmFnU3RhcnRZL2V0Yy4gcHJvcGVydGllcykuIFRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlXG4gKiAgICAgY29udGV4dC5cbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb20gPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBnLmNsZWFyWm9vbVJlY3RfKCk7XG4gIGNvbnRleHQuaXNab29taW5nID0gZmFsc2U7XG4gIER5Z3JhcGhJbnRlcmFjdGlvbi5tYXliZVRyZWF0TW91c2VPcEFzQ2xpY2soZXZlbnQsIGcsIGNvbnRleHQpO1xuXG4gIC8vIFRoZSB6b29tIHJlY3RhbmdsZSBpcyB2aXNpYmx5IGNsaXBwZWQgdG8gdGhlIHBsb3QgYXJlYSwgc28gaXRzIGJlaGF2aW9yXG4gIC8vIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2R5Z3JhcGhzL2lzc3Vlcy9kZXRhaWw/aWQ9MjgwXG4gIHZhciBwbG90QXJlYSA9IGcuZ2V0QXJlYSgpO1xuICBpZiAoY29udGV4dC5yZWdpb25XaWR0aCA+PSAxMCAmJlxuICAgICAgY29udGV4dC5kcmFnRGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICB2YXIgbGVmdCA9IE1hdGgubWluKGNvbnRleHQuZHJhZ1N0YXJ0WCwgY29udGV4dC5kcmFnRW5kWCksXG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoY29udGV4dC5kcmFnU3RhcnRYLCBjb250ZXh0LmRyYWdFbmRYKTtcbiAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGxvdEFyZWEueCk7XG4gICAgcmlnaHQgPSBNYXRoLm1pbihyaWdodCwgcGxvdEFyZWEueCArIHBsb3RBcmVhLncpO1xuICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIGcuZG9ab29tWF8obGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY29udGV4dC5yZWdpb25IZWlnaHQgPj0gMTAgJiZcbiAgICAgICAgICAgICBjb250ZXh0LmRyYWdEaXJlY3Rpb24gPT0gdXRpbHMuVkVSVElDQUwpIHtcbiAgICB2YXIgdG9wID0gTWF0aC5taW4oY29udGV4dC5kcmFnU3RhcnRZLCBjb250ZXh0LmRyYWdFbmRZKSxcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoY29udGV4dC5kcmFnU3RhcnRZLCBjb250ZXh0LmRyYWdFbmRZKTtcbiAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHBsb3RBcmVhLnkpO1xuICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgcGxvdEFyZWEueSArIHBsb3RBcmVhLmgpO1xuICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIGcuZG9ab29tWV8odG9wLCBib3R0b20pO1xuICAgIH1cbiAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IHRydWU7XG4gIH1cbiAgY29udGV4dC5kcmFnU3RhcnRYID0gbnVsbDtcbiAgY29udGV4dC5kcmFnU3RhcnRZID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0VG91Y2ggPSBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gdG91Y2ggYnJvd3NlcnMgYXJlIGFsbCBuaWNlLlxuICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgZXZlciBwdXRzIHR3byBmaW5nZXJzIGRvd24sIGl0J3Mgbm90IGEgZG91YmxlIHRhcC5cbiAgICBjb250ZXh0LnN0YXJ0VGltZUZvckRvdWJsZVRhcE1zID0gbnVsbDtcbiAgfVxuXG4gIHZhciB0b3VjaGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ID0gZXZlbnQudG91Y2hlc1tpXTtcbiAgICAvLyB3ZSBkaXNwZW5zZSB3aXRoICdkcmFnR2V0WF8nIGJlY2F1c2UgYWxsIHRvdWNoQnJvd3NlcnMgc3VwcG9ydCBwYWdlWFxuICAgIHRvdWNoZXMucHVzaCh7XG4gICAgICBwYWdlWDogdC5wYWdlWCxcbiAgICAgIHBhZ2VZOiB0LnBhZ2VZLFxuICAgICAgZGF0YVg6IGcudG9EYXRhWENvb3JkKHQucGFnZVgpLFxuICAgICAgZGF0YVk6IGcudG9EYXRhWUNvb3JkKHQucGFnZVkpXG4gICAgICAvLyBpZGVudGlmaWVyOiB0LmlkZW50aWZpZXJcbiAgICB9KTtcbiAgfVxuICBjb250ZXh0LmluaXRpYWxUb3VjaGVzID0gdG91Y2hlcztcblxuICBpZiAodG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIC8vIFRoaXMgaXMganVzdCBhIHN3aXBlLlxuICAgIGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyID0gdG91Y2hlc1swXTtcbiAgICBjb250ZXh0LnRvdWNoRGlyZWN0aW9ucyA9IHsgeDogdHJ1ZSwgeTogdHJ1ZSB9O1xuICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAvLyBJdCdzIGJlY29tZSBhIHBpbmNoIVxuICAgIC8vIEluIGNhc2UgdGhlcmUgYXJlIDMrIHRvdWNoZXMsIHdlIGlnbm9yZSBhbGwgYnV0IHRoZSBcImZpcnN0XCIgdHdvLlxuXG4gICAgLy8gb25seSBzY3JlZW4gY29vcmRpbmF0ZXMgY2FuIGJlIGF2ZXJhZ2VkIChkYXRhIGNvb3JkcyBjb3VsZCBiZSBsb2cgc2NhbGUpLlxuICAgIGNvbnRleHQuaW5pdGlhbFBpbmNoQ2VudGVyID0ge1xuICAgICAgcGFnZVg6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VYICsgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICBwYWdlWTogMC41ICogKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKSxcblxuICAgICAgLy8gVE9ETyhkYW52ayk6IHJlbW92ZVxuICAgICAgZGF0YVg6IDAuNSAqICh0b3VjaGVzWzBdLmRhdGFYICsgdG91Y2hlc1sxXS5kYXRhWCksXG4gICAgICBkYXRhWTogMC41ICogKHRvdWNoZXNbMF0uZGF0YVkgKyB0b3VjaGVzWzFdLmRhdGFZKVxuICAgIH07XG5cbiAgICAvLyBNYWtlIHBpbmNoZXMgaW4gYSA0NS1kZWdyZWUgc3dhdGggYXJvdW5kIGVpdGhlciBheGlzIDEtZGltZW5zaW9uYWwgem9vbXMuXG4gICAgdmFyIGluaXRpYWxBbmdsZSA9IDE4MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4yKFxuICAgICAgICBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlci5wYWdlWSAtIHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgIHRvdWNoZXNbMF0ucGFnZVggLSBjb250ZXh0LmluaXRpYWxQaW5jaENlbnRlci5wYWdlWCk7XG5cbiAgICAvLyB1c2Ugc3ltbWV0cnkgdG8gZ2V0IGl0IGludG8gdGhlIGZpcnN0IHF1YWRyYW50LlxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguYWJzKGluaXRpYWxBbmdsZSk7XG4gICAgaWYgKGluaXRpYWxBbmdsZSA+IDkwKSBpbml0aWFsQW5nbGUgPSA5MCAtIGluaXRpYWxBbmdsZTtcblxuICAgIGNvbnRleHQudG91Y2hEaXJlY3Rpb25zID0ge1xuICAgICAgeDogKGluaXRpYWxBbmdsZSA8ICg5MCAtIDQ1LzIpKSxcbiAgICAgIHk6IChpbml0aWFsQW5nbGUgPiA0NS8yKVxuICAgIH07XG4gIH1cblxuICAvLyBzYXZlIHRoZSBmdWxsIHggJiB5IHJhbmdlcy5cbiAgY29udGV4dC5pbml0aWFsUmFuZ2UgPSB7XG4gICAgeDogZy54QXhpc1JhbmdlKCksXG4gICAgeTogZy55QXhpc1JhbmdlKClcbiAgfTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLm1vdmVUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gIC8vIElmIHRoZSB0YXAgbW92ZXMsIHRoZW4gaXQncyBkZWZpbml0ZWx5IG5vdCBwYXJ0IG9mIGEgZG91YmxlLXRhcC5cbiAgY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA9IG51bGw7XG5cbiAgdmFyIGksIHRvdWNoZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IGV2ZW50LnRvdWNoZXNbaV07XG4gICAgdG91Y2hlcy5wdXNoKHtcbiAgICAgIHBhZ2VYOiB0LnBhZ2VYLFxuICAgICAgcGFnZVk6IHQucGFnZVlcbiAgICB9KTtcbiAgfVxuICB2YXIgaW5pdGlhbFRvdWNoZXMgPSBjb250ZXh0LmluaXRpYWxUb3VjaGVzO1xuXG4gIHZhciBjX25vdztcblxuICAvLyBvbGQgYW5kIG5ldyBjZW50ZXJzLlxuICB2YXIgY19pbml0ID0gY29udGV4dC5pbml0aWFsUGluY2hDZW50ZXI7XG4gIGlmICh0b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgY19ub3cgPSB0b3VjaGVzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNfbm93ID0ge1xuICAgICAgcGFnZVg6IDAuNSAqICh0b3VjaGVzWzBdLnBhZ2VYICsgdG91Y2hlc1sxXS5wYWdlWCksXG4gICAgICBwYWdlWTogMC41ICogKHRvdWNoZXNbMF0ucGFnZVkgKyB0b3VjaGVzWzFdLnBhZ2VZKVxuICAgIH07XG4gIH1cblxuICAvLyB0aGlzIGlzIHRoZSBcInN3aXBlXCIgY29tcG9uZW50XG4gIC8vIHdlIHRvc3MgaXQgb3V0IGZvciBub3csIGJ1dCBjb3VsZCB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgdmFyIHN3aXBlID0ge1xuICAgIHBhZ2VYOiBjX25vdy5wYWdlWCAtIGNfaW5pdC5wYWdlWCxcbiAgICBwYWdlWTogY19ub3cucGFnZVkgLSBjX2luaXQucGFnZVlcbiAgfTtcbiAgdmFyIGRhdGFXaWR0aCA9IGNvbnRleHQuaW5pdGlhbFJhbmdlLnhbMV0gLSBjb250ZXh0LmluaXRpYWxSYW5nZS54WzBdO1xuICB2YXIgZGF0YUhlaWdodCA9IGNvbnRleHQuaW5pdGlhbFJhbmdlLnlbMF0gLSBjb250ZXh0LmluaXRpYWxSYW5nZS55WzFdO1xuICBzd2lwZS5kYXRhWCA9IChzd2lwZS5wYWdlWCAvIGcucGxvdHRlcl8uYXJlYS53KSAqIGRhdGFXaWR0aDtcbiAgc3dpcGUuZGF0YVkgPSAoc3dpcGUucGFnZVkgLyBnLnBsb3R0ZXJfLmFyZWEuaCkgKiBkYXRhSGVpZ2h0O1xuICB2YXIgeFNjYWxlLCB5U2NhbGU7XG5cbiAgLy8gVGhlIHJlc2lkdWFsIGJpdHMgYXJlIHVzdWFsbHkgc3BsaXQgaW50byBzY2FsZSAmIHJvdGF0ZSBiaXRzLCBidXQgd2Ugc3BsaXRcbiAgLy8gdGhlbSBpbnRvIHgtc2NhbGUgYW5kIHktc2NhbGUgYml0cy5cbiAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICB4U2NhbGUgPSAxLjA7XG4gICAgeVNjYWxlID0gMS4wO1xuICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICB2YXIgaW5pdEhhbGZXaWR0aCA9IChpbml0aWFsVG91Y2hlc1sxXS5wYWdlWCAtIGNfaW5pdC5wYWdlWCk7XG4gICAgeFNjYWxlID0gKHRvdWNoZXNbMV0ucGFnZVggLSBjX25vdy5wYWdlWCkgLyBpbml0SGFsZldpZHRoO1xuXG4gICAgdmFyIGluaXRIYWxmSGVpZ2h0ID0gKGluaXRpYWxUb3VjaGVzWzFdLnBhZ2VZIC0gY19pbml0LnBhZ2VZKTtcbiAgICB5U2NhbGUgPSAodG91Y2hlc1sxXS5wYWdlWSAtIGNfbm93LnBhZ2VZKSAvIGluaXRIYWxmSGVpZ2h0O1xuICB9XG5cbiAgLy8gQ2xpcCBzY2FsaW5nIHRvIFsxLzgsIDhdIHRvIHByZXZlbnQgdG9vIG11Y2ggYmxvd3VwLlxuICB4U2NhbGUgPSBNYXRoLm1pbig4LCBNYXRoLm1heCgwLjEyNSwgeFNjYWxlKSk7XG4gIHlTY2FsZSA9IE1hdGgubWluKDgsIE1hdGgubWF4KDAuMTI1LCB5U2NhbGUpKTtcblxuICB2YXIgZGlkWm9vbSA9IGZhbHNlO1xuICBpZiAoY29udGV4dC50b3VjaERpcmVjdGlvbnMueCkge1xuICAgIGcuZGF0ZVdpbmRvd18gPSBbXG4gICAgICBjX2luaXQuZGF0YVggLSBzd2lwZS5kYXRhWCArIChjb250ZXh0LmluaXRpYWxSYW5nZS54WzBdIC0gY19pbml0LmRhdGFYKSAvIHhTY2FsZSxcbiAgICAgIGNfaW5pdC5kYXRhWCAtIHN3aXBlLmRhdGFYICsgKGNvbnRleHQuaW5pdGlhbFJhbmdlLnhbMV0gLSBjX2luaXQuZGF0YVgpIC8geFNjYWxlXG4gICAgXTtcbiAgICBkaWRab29tID0gdHJ1ZTtcbiAgfVxuICBcbiAgaWYgKGNvbnRleHQudG91Y2hEaXJlY3Rpb25zLnkpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMSAgLypnLmF4ZXNfLmxlbmd0aCovOyBpKyspIHtcbiAgICAgIHZhciBheGlzID0gZy5heGVzX1tpXTtcbiAgICAgIHZhciBsb2dzY2FsZSA9IGcuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGkpO1xuICAgICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICAgIC8vIFRPRE8oZGFudmspOiBpbXBsZW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF4aXMudmFsdWVXaW5kb3cgPSBbXG4gICAgICAgICAgY19pbml0LmRhdGFZIC0gc3dpcGUuZGF0YVkgKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueVswXSAtIGNfaW5pdC5kYXRhWSkgLyB5U2NhbGUsXG4gICAgICAgICAgY19pbml0LmRhdGFZIC0gc3dpcGUuZGF0YVkgKyAoY29udGV4dC5pbml0aWFsUmFuZ2UueVsxXSAtIGNfaW5pdC5kYXRhWSkgLyB5U2NhbGVcbiAgICAgICAgXTtcbiAgICAgICAgZGlkWm9vbSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZy5kcmF3R3JhcGhfKGZhbHNlKTtcblxuICAvLyBXZSBvbmx5IGNhbGwgem9vbUNhbGxiYWNrIG9uIHpvb21zLCBub3QgcGFucywgdG8gbWlycm9yIGRlc2t0b3AgYmVoYXZpb3IuXG4gIGlmIChkaWRab29tICYmIHRvdWNoZXMubGVuZ3RoID4gMSAmJiBnLmdldEZ1bmN0aW9uT3B0aW9uKCd6b29tQ2FsbGJhY2snKSkge1xuICAgIHZhciB2aWV3V2luZG93ID0gZy54QXhpc1JhbmdlKCk7XG4gICAgZy5nZXRGdW5jdGlvbk9wdGlvbihcInpvb21DYWxsYmFja1wiKS5jYWxsKGcsIHZpZXdXaW5kb3dbMF0sIHZpZXdXaW5kb3dbMV0sIGcueUF4aXNSYW5nZXMoKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaEludGVyYWN0aW9uLmVuZFRvdWNoID0gZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gdGhpcyBpcyBlZmZlY3RpdmVseSBhIFwicmVzZXRcIlxuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIC8vIENvdWxkIGJlIHBhcnQgb2YgYSBcImRvdWJsZSB0YXBcIlxuICAgIC8vIFRoZSBoZXVyaXN0aWMgaGVyZSBpcyB0aGF0IGl0J3MgYSBkb3VibGUtdGFwIGlmIHRoZSB0d28gdG91Y2hlbmQgZXZlbnRzXG4gICAgLy8gb2NjdXIgd2l0aGluIDUwMG1zIGFuZCB3aXRoaW4gYSA1MHg1MCBwaXhlbCBib3guXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciB0ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgaWYgKGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgJiZcbiAgICAgICAgbm93IC0gY29udGV4dC5zdGFydFRpbWVGb3JEb3VibGVUYXBNcyA8IDUwMCAmJlxuICAgICAgICBjb250ZXh0LmRvdWJsZVRhcFggJiYgTWF0aC5hYnMoY29udGV4dC5kb3VibGVUYXBYIC0gdC5zY3JlZW5YKSA8IDUwICYmXG4gICAgICAgIGNvbnRleHQuZG91YmxlVGFwWSAmJiBNYXRoLmFicyhjb250ZXh0LmRvdWJsZVRhcFkgLSB0LnNjcmVlblkpIDwgNTApIHtcbiAgICAgIGcucmVzZXRab29tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3RhcnRUaW1lRm9yRG91YmxlVGFwTXMgPSBub3c7XG4gICAgICBjb250ZXh0LmRvdWJsZVRhcFggPSB0LnNjcmVlblg7XG4gICAgICBjb250ZXh0LmRvdWJsZVRhcFkgPSB0LnNjcmVlblk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20geCB0byBbbGVmdCwgcmlnaHRdLlxudmFyIGRpc3RhbmNlRnJvbUludGVydmFsID0gZnVuY3Rpb24oeCwgbGVmdCwgcmlnaHQpIHtcbiAgaWYgKHggPCBsZWZ0KSB7XG4gICAgcmV0dXJuIGxlZnQgLSB4O1xuICB9IGVsc2UgaWYgKHggPiByaWdodCkge1xuICAgIHJldHVybiB4IC0gcmlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBieSB3aGljaCB0aGUgZXZlbnQgaGFwcGVucyBmcm9tIHRoZSBuZWFyZXN0XG4gKiBlZGdlIG9mIHRoZSBjaGFydC4gRm9yIGV2ZW50cyBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIGNoYXJ0LCB0aGlzIHJldHVybnMgemVyby5cbiAqL1xudmFyIGRpc3RhbmNlRnJvbUNoYXJ0ID0gZnVuY3Rpb24oZXZlbnQsIGcpIHtcbiAgdmFyIGNoYXJ0UG9zID0gdXRpbHMuZmluZFBvcyhnLmNhbnZhc18pO1xuICB2YXIgYm94ID0ge1xuICAgIGxlZnQ6IGNoYXJ0UG9zLngsXG4gICAgcmlnaHQ6IGNoYXJ0UG9zLnggKyBnLmNhbnZhc18ub2Zmc2V0V2lkdGgsXG4gICAgdG9wOiBjaGFydFBvcy55LFxuICAgIGJvdHRvbTogY2hhcnRQb3MueSArIGcuY2FudmFzXy5vZmZzZXRIZWlnaHRcbiAgfTtcblxuICB2YXIgcHQgPSB7XG4gICAgeDogdXRpbHMucGFnZVgoZXZlbnQpLFxuICAgIHk6IHV0aWxzLnBhZ2VZKGV2ZW50KVxuICB9O1xuXG4gIHZhciBkeCA9IGRpc3RhbmNlRnJvbUludGVydmFsKHB0LngsIGJveC5sZWZ0LCBib3gucmlnaHQpLFxuICAgICAgZHkgPSBkaXN0YW5jZUZyb21JbnRlcnZhbChwdC55LCBib3gudG9wLCBib3guYm90dG9tKTtcbiAgcmV0dXJuIE1hdGgubWF4KGR4LCBkeSk7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW50ZXJhdGlvbiBtb2RlbCBmb3IgZHlncmFwaHMuIFlvdSBjYW4gcmVmZXIgdG8gc3BlY2lmaWMgZWxlbWVudHMgb2ZcbiAqIHRoaXMgd2hlbiBjb25zdHJ1Y3RpbmcgeW91ciBvd24gaW50ZXJhY3Rpb24gbW9kZWwsIGUuZy46XG4gKiBnLnVwZGF0ZU9wdGlvbnMoIHtcbiAqICAgaW50ZXJhY3Rpb25Nb2RlbDoge1xuICogICAgIG1vdXNlZG93bjogRHlncmFwaEludGVyYWN0aW9uLmRlZmF1bHRJbnRlcmFjdGlvbk1vZGVsLm1vdXNlZG93blxuICogICB9XG4gKiB9ICk7XG4gKi9cbkR5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWwgPSB7XG4gIC8vIFRyYWNrIHRoZSBiZWdpbm5pbmcgb2YgZHJhZyBldmVudHNcbiAgbW91c2Vkb3duOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIC8vIFJpZ2h0LWNsaWNrIHNob3VsZCBub3QgaW5pdGlhdGUgYSB6b29tLlxuICAgIGlmIChldmVudC5idXR0b24gJiYgZXZlbnQuYnV0dG9uID09IDIpIHJldHVybjtcblxuICAgIGNvbnRleHQuaW5pdGlhbGl6ZU1vdXNlRG93bihldmVudCwgZywgY29udGV4dCk7XG5cbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4oZXZlbnQsIGcsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB3ZSByZWdpc3RlciBtb3VzZW1vdmUvbW91c2V1cCBvbiBkb2N1bWVudCB0byBhbGxvdyBzb21lIGxlZXdheSBmb3JcbiAgICAvLyBldmVudHMgdG8gbW92ZSBvdXRzaWRlIG9mIHRoZSBjaGFydC4gSW50ZXJhY3Rpb24gbW9kZWwgZXZlbnRzIGdldFxuICAgIC8vIHJlZ2lzdGVyZWQgb24gdGhlIGNhbnZhcywgd2hpY2ggaXMgdG9vIHNtYWxsIHRvIGFsbG93IHRoaXMuXG4gICAgdmFyIG1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbW91c2UgbW92ZXMgPjIwMHB4IGZyb20gdGhlIGNoYXJ0IGVkZ2UsIGNhbmNlbCB0aGUgem9vbS5cbiAgICAgICAgdmFyIGQgPSBkaXN0YW5jZUZyb21DaGFydChldmVudCwgZyk7XG4gICAgICAgIGlmIChkIDwgRFJBR19FREdFX01BUkdJTikge1xuICAgICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlWm9vbShldmVudCwgZywgY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuZHJhZ0VuZFggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhZ0VuZFggPSBudWxsO1xuICAgICAgICAgICAgY29udGV4dC5kcmFnRW5kWSA9IG51bGw7XG4gICAgICAgICAgICBnLmNsZWFyWm9vbVJlY3RfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChjb250ZXh0LmlzWm9vbWluZykge1xuICAgICAgICBpZiAoY29udGV4dC5kcmFnRW5kWCAhPT0gbnVsbCkge1xuICAgICAgICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRab29tKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubWF5YmVUcmVhdE1vdXNlT3BBc0NsaWNrKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICBjb250ZXh0LmRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICBnLmFkZEFuZFRyYWNrRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJywgbW91c2V1cCk7XG4gIH0sXG4gIHdpbGxEZXN0cm95Q29udGV4dE15c2VsZjogdHJ1ZSxcblxuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFRvdWNoKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgdG91Y2htb3ZlOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIER5Z3JhcGhJbnRlcmFjdGlvbi5tb3ZlVG91Y2goZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICB0b3VjaGVuZDogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHQpIHtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kVG91Y2goZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8vIERpc2FibGUgem9vbWluZyBvdXQgaWYgcGFubmluZy5cbiAgZGJsY2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuY2FuY2VsTmV4dERibGNsaWNrKSB7XG4gICAgICBjb250ZXh0LmNhbmNlbE5leHREYmxjbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdpdmUgcGx1Z2lucyBhIGNoYW5jZSB0byBncmFiIHRoaXMgZXZlbnQuXG4gICAgdmFyIGUgPSB7XG4gICAgICBjYW52YXN4OiBjb250ZXh0LmRyYWdFbmRYLFxuICAgICAgY2FudmFzeTogY29udGV4dC5kcmFnRW5kWVxuICAgIH07XG4gICAgaWYgKGcuY2FzY2FkZUV2ZW50c18oJ2RibGNsaWNrJywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGcucmVzZXRab29tKCk7XG4gIH1cbn07XG5cbi8qXG5EeWdyYXBoLkRFRkFVTFRfQVRUUlMuaW50ZXJhY3Rpb25Nb2RlbCA9IER5Z3JhcGhJbnRlcmFjdGlvbi5kZWZhdWx0TW9kZWw7XG5cbi8vIG9sZCB3YXlzIG9mIGFjY2Vzc2luZyB0aGVzZSBtZXRob2RzL3Byb3BlcnRpZXNcbkR5Z3JhcGguZGVmYXVsdEludGVyYWN0aW9uTW9kZWwgPSBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsO1xuRHlncmFwaC5lbmRab29tID0gRHlncmFwaEludGVyYWN0aW9uLmVuZFpvb207XG5EeWdyYXBoLm1vdmVab29tID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVab29tO1xuRHlncmFwaC5zdGFydFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRab29tO1xuRHlncmFwaC5lbmRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kUGFuO1xuRHlncmFwaC5tb3ZlUGFuID0gRHlncmFwaEludGVyYWN0aW9uLm1vdmVQYW47XG5EeWdyYXBoLnN0YXJ0UGFuID0gRHlncmFwaEludGVyYWN0aW9uLnN0YXJ0UGFuO1xuKi9cblxuRHlncmFwaEludGVyYWN0aW9uLm5vbkludGVyYWN0aXZlTW9kZWxfID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgfSxcbiAgbW91c2V1cDogRHlncmFwaEludGVyYWN0aW9uLm1heWJlVHJlYXRNb3VzZU9wQXNDbGlja1xufTtcblxuLy8gRGVmYXVsdCBpbnRlcmFjdGlvbiBtb2RlbCB3aGVuIHVzaW5nIHRoZSByYW5nZSBzZWxlY3Rvci5cbkR5Z3JhcGhJbnRlcmFjdGlvbi5kcmFnSXNQYW5JbnRlcmFjdGlvbk1vZGVsID0ge1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5pbml0aWFsaXplTW91c2VEb3duKGV2ZW50LCBnLCBjb250ZXh0KTtcbiAgICBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW4oZXZlbnQsIGcsIGNvbnRleHQpO1xuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uKGV2ZW50LCBnLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9LFxuICBtb3VzZXVwOiBmdW5jdGlvbihldmVudCwgZywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmlzUGFubmluZykge1xuICAgICAgRHlncmFwaEludGVyYWN0aW9uLmVuZFBhbihldmVudCwgZywgY29udGV4dCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoSW50ZXJhY3Rpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBCYXNlZCBvbiBQbG90S2l0TGF5b3V0LCBidXQgbW9kaWZpZWQgdG8gbWVldCB0aGUgbmVlZHMgb2ZcbiAqIGR5Z3JhcGhzLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2R5Z3JhcGgtdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRHlncmFwaExheW91dCBvYmplY3QuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBhbGwgdGhlIGRhdGEgdG8gYmUgY2hhcnRlZC5cbiAqIEl0IHVzZXMgZGF0YSBjb29yZGluYXRlcywgYnV0IGFsc28gcmVjb3JkcyB0aGUgY2hhcnQgcmFuZ2UgKGluIGRhdGFcbiAqIGNvb3JkaW5hdGVzKSBhbmQgaGVuY2UgaXMgYWJsZSB0byBjYWxjdWxhdGUgcGVyY2VudGFnZSBwb3NpdGlvbnMgKCdJbiB0aGlzXG4gKiB2aWV3LCBQb2ludCBBIGxpZXMgMjUlIGRvd24gdGhlIHgtYXhpcy4nKVxuICpcbiAqIFR3byB0aGluZ3MgdGhhdCBpdCBkb2VzIG5vdCBkbyBhcmU6XG4gKiAxLiBSZWNvcmQgcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGFueXRoaW5nLlxuICogMi4gKG9kZGx5KSBkZXRlcm1pbmUgYW55dGhpbmcgYWJvdXQgdGhlIGxheW91dCBvZiBjaGFydCBlbGVtZW50cy5cbiAqXG4gKiBUaGUgbmFtaW5nIGlzIGEgdmVzdGlnZSBvZiBEeWdyYXBoJ3Mgb3JpZ2luYWwgUGxvdEtpdCByb290cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIER5Z3JhcGhMYXlvdXQgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICAvKipcbiAgICogQXJyYXkgb2YgcG9pbnRzIGZvciBlYWNoIHNlcmllcy5cbiAgICpcbiAgICogW3NlcmllcyBpbmRleF1bcm93IGluZGV4IGluIHNlcmllc10gPSB8UG9pbnR8IHN0cnVjdHVyZSxcbiAgICogd2hlcmUgc2VyaWVzIGluZGV4IHJlZmVycyB0byB2aXNpYmxlIHNlcmllcyBvbmx5LCBhbmQgdGhlXG4gICAqIHBvaW50IGluZGV4IGlzIGZvciB0aGUgcmVkdWNlZCBzZXQgb2YgcG9pbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiB6b29tIHJlZ2lvbiAoaW5jbHVkaW5nIG9uZSBwb2ludCBqdXN0IG91dHNpZGUgdGhlIHdpbmRvdykuXG4gICAqIEFsbCBwb2ludHMgaW4gdGhlIHNhbWUgcm93IGluZGV4IHNoYXJlIHRoZSBzYW1lIFggdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj59XG4gICAqL1xuICB0aGlzLnBvaW50cyA9IFtdO1xuICB0aGlzLnNldE5hbWVzID0gW107XG4gIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgdGhpcy55QXhlc18gPSBudWxsO1xuXG4gIC8vIFRPRE8oZGFudmspOiBpdCdzIG9kZCB0aGF0IHhUaWNrc18gYW5kIHlUaWNrc18gYXJlIGlucHV0cywgYnV0IHh0aWNrcyBhbmRcbiAgLy8geXRpY2tzIGFyZSBvdXRwdXRzLiBDbGVhbiB0aGlzIHVwLlxuICB0aGlzLnhUaWNrc18gPSBudWxsO1xuICB0aGlzLnlUaWNrc18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBBZGQgcG9pbnRzIGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNldG5hbWUgTmFtZSBvZiB0aGUgc2VyaWVzLlxuICogQHBhcmFtIHtBcnJheS48RHlncmFwaC5Qb2ludFR5cGU+fSBzZXRfeHkgUG9pbnRzIGZvciB0aGUgc2VyaWVzLlxuICovXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5hZGREYXRhc2V0ID0gZnVuY3Rpb24oc2V0bmFtZSwgc2V0X3h5KSB7XG4gIHRoaXMucG9pbnRzLnB1c2goc2V0X3h5KTtcbiAgdGhpcy5zZXROYW1lcy5wdXNoKHNldG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3ggd2hpY2ggdGhlIGNoYXJ0IHNob3VsZCBiZSBkcmF3biBpbi4gVGhpcyBpcyB0aGUgY2FudmFzJ3NcbiAqIGJveCwgbGVzcyBzcGFjZSBuZWVkZWQgZm9yIHRoZSBheGlzIGFuZCBjaGFydCBsYWJlbHMuXG4gKlxuICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcn19XG4gKi9cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmdldFBsb3RBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFyZWFfO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgYm94IHdoaWNoIHRoZSBjaGFydCBzaG91bGQgYmUgZHJhd24gaW4uIFRoaXMgaXMgdGhlIGNhbnZhcydzXG4vLyBib3gsIGxlc3Mgc3BhY2UgbmVlZGVkIGZvciBheGlzLCBjaGFydCBsYWJlbHMsIGFuZCBvdGhlciBwbHVnLWlucy5cbi8vIE5PVEU6IFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IER5Z3JhcGgucHJlZHJhd18oKS5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmNvbXB1dGVQbG90QXJlYSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXJlYSA9IHtcbiAgICAvLyBUT0RPKGRhbnZrKTogcGVyLWF4aXMgc2V0dGluZy5cbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBhcmVhLncgPSB0aGlzLmR5Z3JhcGhfLndpZHRoXyAtIGFyZWEueCAtIHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKCdyaWdodEdhcCcpO1xuICBhcmVhLmggPSB0aGlzLmR5Z3JhcGhfLmhlaWdodF87XG5cbiAgLy8gTGV0IHBsdWdpbnMgcmVzZXJ2ZSBzcGFjZS5cbiAgdmFyIGUgPSB7XG4gICAgY2hhcnRfZGl2OiB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2LFxuICAgIHJlc2VydmVTcGFjZUxlZnQ6IGZ1bmN0aW9uKHB4KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeDogYXJlYS54LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLnggKz0gcHg7XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVJpZ2h0OiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCArIGFyZWEudyAtIHB4LFxuICAgICAgICB5OiBhcmVhLnksXG4gICAgICAgIHc6IHB4LFxuICAgICAgICBoOiBhcmVhLmhcbiAgICAgIH07XG4gICAgICBhcmVhLncgLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlc2VydmVTcGFjZVRvcDogZnVuY3Rpb24ocHgpIHtcbiAgICAgIHZhciByID0ge1xuICAgICAgICB4OiBhcmVhLngsXG4gICAgICAgIHk6IGFyZWEueSxcbiAgICAgICAgdzogYXJlYS53LFxuICAgICAgICBoOiBweFxuICAgICAgfTtcbiAgICAgIGFyZWEueSArPSBweDtcbiAgICAgIGFyZWEuaCAtPSBweDtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgcmVzZXJ2ZVNwYWNlQm90dG9tOiBmdW5jdGlvbihweCkge1xuICAgICAgdmFyIHIgPSB7XG4gICAgICAgIHg6IGFyZWEueCxcbiAgICAgICAgeTogYXJlYS55ICsgYXJlYS5oIC0gcHgsXG4gICAgICAgIHc6IGFyZWEudyxcbiAgICAgICAgaDogcHhcbiAgICAgIH07XG4gICAgICBhcmVhLmggLT0gcHg7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIGNoYXJ0UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3g6YXJlYS54LCB5OmFyZWEueSwgdzphcmVhLncsIGg6YXJlYS5ofTtcbiAgICB9XG4gIH07XG4gIHRoaXMuZHlncmFwaF8uY2FzY2FkZUV2ZW50c18oJ2xheW91dCcsIGUpO1xuXG4gIHRoaXMuYXJlYV8gPSBhcmVhO1xufTtcblxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm4pIHtcbiAgLy8gVGhlIER5Z3JhcGggb2JqZWN0J3MgYW5ub3RhdGlvbnMgYXJlbid0IHBhcnNlZC4gV2UgcGFyc2UgdGhlbSBoZXJlIGFuZFxuICAvLyBzYXZlIGEgY29weS4gSWYgdGhlcmUgaXMgbm8gcGFyc2VyLCB0aGVuIHRoZSB1c2VyIG11c3QgYmUgdXNpbmcgcmF3IGZvcm1hdC5cbiAgdGhpcy5hbm5vdGF0aW9ucyA9IFtdO1xuICB2YXIgcGFyc2UgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbigneFZhbHVlUGFyc2VyJykgfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbm4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYSA9IHt9O1xuICAgIGlmICghYW5uW2ldLnh2YWwgJiYgYW5uW2ldLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkFubm90YXRpb25zIG11c3QgaGF2ZSBhbiAneCcgcHJvcGVydHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbm5baV0uaWNvbiAmJlxuICAgICAgICAhKGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSAmJlxuICAgICAgICAgIGFubltpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTXVzdCBzZXQgd2lkdGggYW5kIGhlaWdodCB3aGVuIHNldHRpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFubm90YXRpb24uaWNvbiBwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXRpbHMudXBkYXRlKGEsIGFubltpXSk7XG4gICAgaWYgKCFhLnh2YWwpIGEueHZhbCA9IHBhcnNlKGEueCk7XG4gICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGEpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5zZXRYVGlja3MgPSBmdW5jdGlvbih4VGlja3MpIHtcbiAgdGhpcy54VGlja3NfID0geFRpY2tzO1xufTtcblxuLy8gVE9ETyhkYW52ayk6IGFkZCB0aGlzIHRvIHRoZSBEeWdyYXBoIG9iamVjdCdzIEFQSSBvciBtb3ZlIGl0IGludG8gTGF5b3V0LlxuRHlncmFwaExheW91dC5wcm90b3R5cGUuc2V0WUF4ZXMgPSBmdW5jdGlvbiAoeUF4ZXMpIHtcbiAgdGhpcy55QXhlc18gPSB5QXhlcztcbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3hBeGlzID0ge307XG4gIHRoaXMuX2V2YWx1YXRlTGltaXRzKCk7XG4gIHRoaXMuX2V2YWx1YXRlTGluZUNoYXJ0cygpO1xuICB0aGlzLl9ldmFsdWF0ZUxpbmVUaWNrcygpO1xuICB0aGlzLl9ldmFsdWF0ZUFubm90YXRpb25zKCk7XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW1pdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHhsaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdGhpcy5feEF4aXMubWludmFsID0geGxpbWl0c1swXTtcbiAgdGhpcy5feEF4aXMubWF4dmFsID0geGxpbWl0c1sxXTtcbiAgdmFyIHhyYW5nZSA9IHhsaW1pdHNbMV0gLSB4bGltaXRzWzBdO1xuICB0aGlzLl94QXhpcy5zY2FsZSA9ICh4cmFuZ2UgIT09IDAgPyAxIC8geHJhbmdlIDogMS4wKTtcblxuICBpZiAodGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHRoaXMuX3hBeGlzLnhsb2dyYW5nZSA9IHV0aWxzLmxvZzEwKHRoaXMuX3hBeGlzLm1heHZhbCkgLSB1dGlscy5sb2cxMCh0aGlzLl94QXhpcy5taW52YWwpO1xuICAgIHRoaXMuX3hBeGlzLnhsb2dzY2FsZSA9ICh0aGlzLl94QXhpcy54bG9ncmFuZ2UgIT09IDAgPyAxLjAgLyB0aGlzLl94QXhpcy54bG9ncmFuZ2UgOiAxLjApO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55QXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGF4aXMubWlueXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgIGF4aXMubWF4eXZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdO1xuICAgIGF4aXMueXJhbmdlID0gYXhpcy5tYXh5dmFsIC0gYXhpcy5taW55dmFsO1xuICAgIGF4aXMueXNjYWxlID0gKGF4aXMueXJhbmdlICE9PSAwID8gMS4wIC8gYXhpcy55cmFuZ2UgOiAxLjApO1xuXG4gICAgaWYgKHRoaXMuZHlncmFwaF8uZ2V0T3B0aW9uKFwibG9nc2NhbGVcIikpIHtcbiAgICAgIGF4aXMueWxvZ3JhbmdlID0gdXRpbHMubG9nMTAoYXhpcy5tYXh5dmFsKSAtIHV0aWxzLmxvZzEwKGF4aXMubWlueXZhbCk7XG4gICAgICBheGlzLnlsb2dzY2FsZSA9IChheGlzLnlsb2dyYW5nZSAhPT0gMCA/IDEuMCAvIGF4aXMueWxvZ3JhbmdlIDogMS4wKTtcbiAgICAgIGlmICghaXNGaW5pdGUoYXhpcy55bG9ncmFuZ2UpIHx8IGlzTmFOKGF4aXMueWxvZ3JhbmdlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdheGlzICcgKyBpICsgJyBvZiBncmFwaCBhdCAnICsgYXhpcy5nICtcbiAgICAgICAgICAgICAgICAgICAgICAnIGNhblxcJ3QgYmUgZGlzcGxheWVkIGluIGxvZyBzY2FsZSBmb3IgcmFuZ2UgWycgK1xuICAgICAgICAgICAgICAgICAgICAgIGF4aXMubWlueXZhbCArICcgLSAnICsgYXhpcy5tYXh5dmFsICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQuY2FsY1hOb3JtYWxfID0gZnVuY3Rpb24odmFsdWUsIHhBeGlzLCBsb2dzY2FsZSkge1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICByZXR1cm4gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMCh4QXhpcy5taW52YWwpKSAqIHhBeGlzLnhsb2dzY2FsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHhBeGlzLm1pbnZhbCkgKiB4QXhpcy5zY2FsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0R5Z3JhcGhBeGlzVHlwZX0gYXhpc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvZ3NjYWxlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkR5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfID0gZnVuY3Rpb24oYXhpcywgdmFsdWUsIGxvZ3NjYWxlKSB7XG4gIGlmIChsb2dzY2FsZSkge1xuICAgIHZhciB4ID0gMS4wIC0gKCh1dGlscy5sb2cxMCh2YWx1ZSkgLSB1dGlscy5sb2cxMChheGlzLm1pbnl2YWwpKSAqIGF4aXMueWxvZ3NjYWxlKTtcbiAgICByZXR1cm4gaXNGaW5pdGUoeCkgPyB4IDogTmFOOyAgLy8gc2hpbSBmb3IgdjggaXNzdWU7IHNlZSBwdWxsIHJlcXVlc3QgMjc2XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEuMCAtICgodmFsdWUgLSBheGlzLm1pbnl2YWwpICogYXhpcy55c2NhbGUpO1xuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVMaW5lQ2hhcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1N0YWNrZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihcInN0YWNrZWRHcmFwaFwiKTtcbiAgdmFyIGlzTG9nc2NhbGVGb3JYID0gdGhpcy5keWdyYXBoXy5nZXRPcHRpb25Gb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKTtcblxuICBmb3IgKHZhciBzZXRJZHggPSAwOyBzZXRJZHggPCB0aGlzLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzW3NldElkeF07XG4gICAgdmFyIHNldE5hbWUgPSB0aGlzLnNldE5hbWVzW3NldElkeF07XG4gICAgdmFyIGNvbm5lY3RTZXBhcmF0ZWQgPSB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbignY29ubmVjdFNlcGFyYXRlZFBvaW50cycsIHNldE5hbWUpO1xuICAgIHZhciBheGlzID0gdGhpcy5keWdyYXBoXy5heGlzUHJvcGVydGllc0ZvclNlcmllcyhzZXROYW1lKTtcbiAgICAvLyBUT0RPIChrb25pZ3NiZXJnKTogdXNlIG9wdGlvbnNGb3JBeGlzIGluc3RlYWQuXG4gICAgdmFyIGxvZ3NjYWxlID0gdGhpcy5keWdyYXBoXy5hdHRyaWJ1dGVzXy5nZXRGb3JTZXJpZXMoXCJsb2dzY2FsZVwiLCBzZXROYW1lKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG5cbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyBsZWZ0IGFuZCAxIHJlcHJlc2VudHMgcmlnaHQuXG4gICAgICBwb2ludC54ID0gRHlncmFwaExheW91dC5jYWxjWE5vcm1hbF8ocG9pbnQueHZhbCwgdGhpcy5feEF4aXMsIGlzTG9nc2NhbGVGb3JYKTtcbiAgICAgIC8vIFJhbmdlIGZyb20gMC0xIHdoZXJlIDAgcmVwcmVzZW50cyB0b3AgYW5kIDEgcmVwcmVzZW50cyBib3R0b21cbiAgICAgIHZhciB5dmFsID0gcG9pbnQueXZhbDtcbiAgICAgIGlmIChpc1N0YWNrZWQpIHtcbiAgICAgICAgcG9pbnQueV9zdGFja2VkID0gRHlncmFwaExheW91dC5jYWxjWU5vcm1hbF8oXG4gICAgICAgICAgICBheGlzLCBwb2ludC55dmFsX3N0YWNrZWQsIGxvZ3NjYWxlKTtcbiAgICAgICAgaWYgKHl2YWwgIT09IG51bGwgJiYgIWlzTmFOKHl2YWwpKSB7XG4gICAgICAgICAgeXZhbCA9IHBvaW50Lnl2YWxfc3RhY2tlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHl2YWwgPT09IG51bGwpIHtcbiAgICAgICAgeXZhbCA9IE5hTjtcbiAgICAgICAgaWYgKCFjb25uZWN0U2VwYXJhdGVkKSB7XG4gICAgICAgICAgcG9pbnQueXZhbCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9pbnQueSA9IER5Z3JhcGhMYXlvdXQuY2FsY1lOb3JtYWxfKGF4aXMsIHl2YWwsIGxvZ3NjYWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLmR5Z3JhcGhfLmRhdGFIYW5kbGVyXy5vbkxpbmVFdmFsdWF0ZWQocG9pbnRzLCBheGlzLCBsb2dzY2FsZSk7XG4gIH1cbn07XG5cbkR5Z3JhcGhMYXlvdXQucHJvdG90eXBlLl9ldmFsdWF0ZUxpbmVUaWNrcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgdGljaywgbGFiZWwsIHBvcywgdiwgaGFzX3RpY2s7XG4gIHRoaXMueHRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnhUaWNrc18ubGVuZ3RoOyBpKyspIHtcbiAgICB0aWNrID0gdGhpcy54VGlja3NfW2ldO1xuICAgIGxhYmVsID0gdGljay5sYWJlbDtcbiAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgIHYgPSBoYXNfdGljayA/IHRpY2sudiA6IHRpY2subGFiZWxfdjtcbiAgICBwb3MgPSB0aGlzLmR5Z3JhcGhfLnRvUGVyY2VudFhDb29yZCh2KTtcbiAgICBpZiAoKHBvcyA+PSAwLjApICYmIChwb3MgPCAxLjApKSB7XG4gICAgICB0aGlzLnh0aWNrcy5wdXNoKHtwb3MsIGxhYmVsLCBoYXNfdGlja30pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueXRpY2tzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnlBeGVzXy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgYXhpcyA9IHRoaXMueUF4ZXNfW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXhpcy50aWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgdGljayA9IGF4aXMudGlja3Nbal07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBoYXNfdGljayA9ICEoJ2xhYmVsX3YnIGluIHRpY2spO1xuICAgICAgdiA9IGhhc190aWNrID8gdGljay52IDogdGljay5sYWJlbF92O1xuICAgICAgcG9zID0gdGhpcy5keWdyYXBoXy50b1BlcmNlbnRZQ29vcmQodiwgaSk7XG4gICAgICBpZiAoKHBvcyA+IDAuMCkgJiYgKHBvcyA8PSAxLjApKSB7XG4gICAgICAgIHRoaXMueXRpY2tzLnB1c2goe2F4aXM6IGksIHBvcywgbGFiZWwsIGhhc190aWNrfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5EeWdyYXBoTGF5b3V0LnByb3RvdHlwZS5fZXZhbHVhdGVBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIHRvIHRoZSBwb2ludCB0byB3aGljaCB0aGV5IGJlbG9uZy5cbiAgLy8gTWFrZSBhIG1hcCBmcm9tIChzZXROYW1lLCB4dmFsKSB0byBhbm5vdGF0aW9uIGZvciBxdWljayBsb29rdXBzLlxuICB2YXIgaTtcbiAgdmFyIGFubm90YXRpb25zID0ge307XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zW2ldO1xuICAgIGFubm90YXRpb25zW2EueHZhbCArIFwiLFwiICsgYS5zZXJpZXNdID0gYTtcbiAgfVxuXG4gIHRoaXMuYW5ub3RhdGVkX3BvaW50cyA9IFtdO1xuXG4gIC8vIEV4aXQgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZXJlIGFyZSBubyBhbm5vdGF0aW9ucy5cbiAgaWYgKCF0aGlzLmFubm90YXRpb25zIHx8ICF0aGlzLmFubm90YXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8oYW50cm9iKTogbG9vcCB0aHJvdWdoIGFubm90YXRpb25zIG5vdCBwb2ludHMuXG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMucG9pbnRzLmxlbmd0aDsgc2V0SWR4KyspIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBrID0gcC54dmFsICsgXCIsXCIgKyBwLm5hbWU7XG4gICAgICBpZiAoayBpbiBhbm5vdGF0aW9ucykge1xuICAgICAgICBwLmFubm90YXRpb24gPSBhbm5vdGF0aW9uc1trXTtcbiAgICAgICAgdGhpcy5hbm5vdGF0ZWRfcG9pbnRzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbGwgdGhlIGRhdGEgc2V0cyBmcm9tIGEgZ3JhcGhcbiAqL1xuRHlncmFwaExheW91dC5wcm90b3R5cGUucmVtb3ZlQWxsRGF0YXNldHMgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMucG9pbnRzO1xuICBkZWxldGUgdGhpcy5zZXROYW1lcztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzTGVuZ3RocztcbiAgZGVsZXRlIHRoaXMuc2V0UG9pbnRzT2Zmc2V0cztcbiAgdGhpcy5wb2ludHMgPSBbXTtcbiAgdGhpcy5zZXROYW1lcyA9IFtdO1xuICB0aGlzLnNldFBvaW50c0xlbmd0aHMgPSBbXTtcbiAgdGhpcy5zZXRQb2ludHNPZmZzZXRzID0gW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoTGF5b3V0O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE9QVElPTlNfUkVGRVJFTkNFID0gbnVsbDtcblxuLy8gRm9yIFwicHJvZHVjdGlvblwiIGNvZGUsIHRoaXMgZ2V0cyByZW1vdmVkIGJ5IHVnbGlmeWpzLlxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuXG4vLyBOT1RFOiBpbiBhZGRpdGlvbiB0byBwYXJzaW5nIGFzIEpTLCB0aGlzIHNuaXBwZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdmFsaWRcbi8vIEpTT04uIFRoaXMgYXNzdW1wdGlvbiBjYW5ub3QgYmUgY2hlY2tlZCBpbiBKUywgYnV0IGl0IHdpbGwgYmUgY2hlY2tlZCB3aGVuXG4vLyBkb2N1bWVudGF0aW9uIGlzIGdlbmVyYXRlZCBieSB0aGUgZ2VuZXJhdGUtZG9jdW1lbnRhdGlvbi5weSBzY3JpcHQuIEZvciB0aGVcbi8vIG1vc3QgcGFydCwgdGhpcyBqdXN0IG1lYW5zIHRoYXQgeW91IHNob3VsZCBhbHdheXMgdXNlIGRvdWJsZSBxdW90ZXMuXG5PUFRJT05TX1JFRkVSRU5DRSA9ICAvLyA8SlNPTj5cbntcbiAgXCJ4VmFsdWVQYXJzZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInBhcnNlRmxvYXQoKSBvciBEYXRlLnBhcnNlKCkqXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oc3RyKSAtPiBudW1iZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB3aGljaCBwYXJzZXMgeC12YWx1ZXMgKGkuZS4gdGhlIGRlcGVuZGVudCBzZXJpZXMpLiBNdXN0IHJldHVybiBhIG51bWJlciwgZXZlbiB3aGVuIHRoZSB2YWx1ZXMgYXJlIGRhdGVzLiBJbiB0aGlzIGNhc2UsIG1pbGxpcyBzaW5jZSBlcG9jaCBhcmUgdXNlZC4gVGhpcyBpcyB1c2VkIHByaW1hcmlseSBmb3IgcGFyc2luZyBDU1YgZGF0YS4gKj1EeWdyYXBocyBpcyBzbGlnaHRseSBtb3JlIGFjY2VwdGluZyBpbiB0aGUgZGF0ZXMgd2hpY2ggaXQgd2lsbCBwYXJzZS4gU2VlIGNvZGUgZm9yIGRldGFpbHMuXCJcbiAgfSxcbiAgXCJzdGFja2VkR3JhcGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBzZXQsIHN0YWNrIHNlcmllcyBvbiB0b3Agb2Ygb25lIGFub3RoZXIgcmF0aGVyIHRoYW4gZHJhd2luZyB0aGVtIGluZGVwZW5kZW50bHkuIFRoZSBmaXJzdCBzZXJpZXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBkYXRhIHdpbGwgd2luZCB1cCBvbiB0b3Agb2YgdGhlIGNoYXJ0IGFuZCB0aGUgbGFzdCB3aWxsIGJlIG9uIGJvdHRvbS4gTmFOIHZhbHVlcyBhcmUgZHJhd24gYXMgd2hpdGUgYXJlYXMgd2l0aG91dCBhIGxpbmUgb24gdG9wLCBzZWUgc3RhY2tlZEdyYXBoTmFORmlsbCBmb3IgZGV0YWlscy5cIlxuICB9LFxuICBcInN0YWNrZWRHcmFwaE5hTkZpbGxcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImFsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb250cm9scyBoYW5kbGluZyBvZiBOYU4gdmFsdWVzIGluc2lkZSBhIHN0YWNrZWQgZ3JhcGguIE5hTiB2YWx1ZXMgYXJlIGludGVycG9sYXRlZC9leHRlbmRlZCBmb3Igc3RhY2tpbmcgcHVycG9zZXMsIGJ1dCB0aGUgYWN0dWFsIHBvaW50IHZhbHVlIHJlbWFpbnMgTmFOIGluIHRoZSBsZWdlbmQgZGlzcGxheS4gVmFsaWQgb3B0aW9uIHZhbHVlcyBhcmUgXFxcImFsbFxcXCIgKGludGVycG9sYXRlIGludGVybmFsbHksIHJlcGVhdCBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHZhbHVlIGFzIG5lZWRlZCksIFxcXCJpbnNpZGVcXFwiIChpbnRlcnBvbGF0ZSBpbnRlcm5hbGx5IG9ubHksIHVzZSB6ZXJvIG91dHNpZGUgbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCB2YWx1ZSksIGFuZCBcXFwibm9uZVxcXCIgKHRyZWF0IE5hTiBhcyB6ZXJvIGV2ZXJ5d2hlcmUpLlwiXG4gIH0sXG4gIFwicG9pbnRTaXplXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc2l6ZSBvZiB0aGUgZG90IHRvIGRyYXcgb24gZWFjaCBwb2ludCBpbiBwaXhlbHMgKHNlZSBkcmF3UG9pbnRzKS4gQSBkb3QgaXMgYWx3YXlzIGRyYXduIHdoZW4gYSBwb2ludCBpcyBcXFwiaXNvbGF0ZWRcXFwiLCBpLmUuIHRoZXJlIGlzIGEgbWlzc2luZyBwb2ludCBvbiBlaXRoZXIgc2lkZSBvZiBpdC4gVGhpcyBhbHNvIGNvbnRyb2xzIHRoZSBzaXplIG9mIHRob3NlIGRvdHMuXCJcbiAgfSxcbiAgXCJsYWJlbHNEaXZTdHlsZXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwie31cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkaXRpb25hbCBzdHlsZXMgdG8gYXBwbHkgdG8gdGhlIGN1cnJlbnRseS1oaWdobGlnaHRlZCBwb2ludHMgZGl2LiBGb3IgZXhhbXBsZSwgeyAnZm9udFdlaWdodCc6ICdib2xkJyB9IHdpbGwgbWFrZSB0aGUgbGFiZWxzIGJvbGQuIEluIGdlbmVyYWwsIGl0IGlzIGJldHRlciB0byB1c2UgQ1NTIHRvIHN0eWxlIHRoZSAuZHlncmFwaC1sZWdlbmQgY2xhc3MgdGhhbiB0byB1c2UgdGhpcyBwcm9wZXJ0eS5cIlxuICB9LFxuICBcImRyYXdQb2ludHNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEcmF3IGEgc21hbGwgZG90IGF0IGVhY2ggcG9pbnQsIGluIGFkZGl0aW9uIHRvIGEgbGluZSBnb2luZyB0aHJvdWdoIHRoZSBwb2ludC4gVGhpcyBtYWtlcyB0aGUgaW5kaXZpZHVhbCBkYXRhIHBvaW50cyBlYXNpZXIgdG8gc2VlLCBidXQgY2FuIGluY3JlYXNlIHZpc3VhbCBjbHV0dGVyIGluIHRoZSBjaGFydC4gVGhlIHNtYWxsIGRvdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIGN1c3RvbSByZW5kZXJpbmcgYnkgc3VwcGx5aW5nIGEgPGEgaHJlZj0nI2RyYXdQb2ludENhbGxiYWNrJz5kcmF3UG9pbnRDYWxsYmFjazwvYT4uXCJcbiAgfSxcbiAgXCJkcmF3R2FwRWRnZVBvaW50c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgcG9pbnRzIGF0IHRoZSBlZGdlcyBvZiBnYXBzIGluIHRoZSBkYXRhLiBUaGlzIGltcHJvdmVzIHZpc2liaWxpdHkgb2Ygc21hbGwgZGF0YSBzZWdtZW50cyBvciBvdGhlciBkYXRhIGlycmVndWxhcml0aWVzLlwiXG4gIH0sXG4gIFwiZHJhd1BvaW50Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihnLCBzZXJpZXNOYW1lLCBjYW52YXNDb250ZXh0LCBjeCwgY3ksIGNvbG9yLCBwb2ludFNpemUpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJnXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcInNlcmllc05hbWVcIiAsIFwidGhlIG5hbWUgb2YgdGhlIHNlcmllc1wiIF0sXG4gICAgICBbIFwiY2FudmFzQ29udGV4dFwiICwgXCJ0aGUgY2FudmFzIHRvIGRyYXcgb25cIiBdLFxuICAgICAgWyBcImN4XCIgLCBcImNlbnRlciB4IGNvb3JkaW5hdGVcIiBdLFxuICAgICAgWyBcImN5XCIgLCBcImNlbnRlciB5IGNvb3JkaW5hdGVcIiBdLFxuICAgICAgWyBcImNvbG9yXCIgLCBcInNlcmllcyBjb2xvclwiIF0sXG4gICAgICBbIFwicG9pbnRTaXplXCIgLCBcInRoZSByYWRpdXMgb2YgdGhlIGltYWdlLlwiIF0sXG4gICAgICBbIFwiaWR4XCIgLCBcInRoZSByb3ctaW5kZXggb2YgdGhlIHBvaW50IGluIHRoZSBkYXRhLlwiXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRyYXcgYSBjdXN0b20gaXRlbSB3aGVuIGRyYXdQb2ludHMgaXMgZW5hYmxlZC4gRGVmYXVsdCBpcyBhIHNtYWxsIGRvdCBtYXRjaGluZyB0aGUgc2VyaWVzIGNvbG9yLiBUaGlzIG1ldGhvZCBzaG91bGQgY29uc3RyYWluIGRyYXdpbmcgdG8gd2l0aGluIHBvaW50U2l6ZSBwaXhlbHMgZnJvbSAoY3gsIGN5KS4gIEFsc28gc2VlIDxhIGhyZWY9JyNkcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFjayc+ZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2s8L2E+XCJcbiAgfSxcbiAgXCJoZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjMyMFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIk92ZXJhbGwgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCwgaW4gcGl4ZWxzLCBvZiB0aGUgY2hhcnQuIElmIHRoZSBjb250YWluZXIgZGl2IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2l6ZWQsIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlwiXG4gIH0sXG4gIFwiem9vbUNhbGxiYWNrXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG1pbkRhdGUsIG1heERhdGUsIHlSYW5nZXMpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJtaW5EYXRlXCIgLCBcIm1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaFwiIF0sXG4gICAgICBbIFwibWF4RGF0ZVwiICwgXCJtaWxsaXNlY29uZHMgc2luY2UgZXBvY2guXCIgXSxcbiAgICAgIFsgXCJ5UmFuZ2VzXCIgLCBcImlzIGFuIGFycmF5IG9mIFtib3R0b20sIHRvcF0gcGFpcnMsIG9uZSBmb3IgZWFjaCB5LWF4aXMuXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB6b29tIHdpbmRvdyBpcyBjaGFuZ2VkIChlaXRoZXIgYnkgem9vbWluZyBpbiBvciBvdXQpLiBXaGVuIGFuaW1hdGVkWm9vbXMgaXMgc2V0LCB6b29tQ2FsbGJhY2sgaXMgY2FsbGVkIG9uY2UgYXQgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbiAoaXQgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBpbnRlcm1lZGlhdGUgZnJhbWVzKS5cIlxuICB9LFxuICBcInBvaW50Q2xpY2tDYWxsYmFja1wiOiB7XG4gICAgXCJzbmlwcGV0XCI6IFwiZnVuY3Rpb24oZSwgcG9pbnQpezxicj4mbmJzcDsmbmJzcDthbGVydChwb2ludCk7PGJyPn1cIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCIsIFwiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZSwgcG9pbnQpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJlXCIgLCBcInRoZSBldmVudCBvYmplY3QgZm9yIHRoZSBjbGlja1wiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IHRoYXQgd2FzIGNsaWNrZWQgU2VlIDxhIGhyZWY9JyNwb2ludF9wcm9wZXJ0aWVzJz5Qb2ludCBwcm9wZXJ0aWVzPC9hPiBmb3IgZGV0YWlsc1wiIF1cbiAgICBdLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGEgcG9pbnQgaXMgY2xpY2tlZC4gYW5kIHRoZSBwb2ludCB0aGF0IHdhcyBjbGlja2VkLlwiXG4gIH0sXG4gIFwiY29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihzZWUgZGVzY3JpcHRpb24pXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcInJlZFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHBlci1zZXJpZXMgY29sb3IgZGVmaW5pdGlvbi4gVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoLCBhbmQgb3ZlcnJpZGVzLCB0aGUgY29sb3JzIG9wdGlvbi5cIlxuICB9LFxuICBcImNvbG9yc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNlZSBkZXNjcmlwdGlvbilcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYXJyYXk8c3RyaW5nPlwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIlsncmVkJywgJyMwMEZGMDAnXVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMaXN0IG9mIGNvbG9ycyBmb3IgdGhlIGRhdGEgc2VyaWVzLiBUaGVzZSBjYW4gYmUgb2YgdGhlIGZvcm0gXFxcIiNBQUJCQ0NcXFwiIG9yIFxcXCJyZ2IoMjU1LDEwMCwyMDApXFxcIiBvciBcXFwieWVsbG93XFxcIiwgZXRjLiBJZiBub3Qgc3BlY2lmaWVkLCBlcXVhbGx5LXNwYWNlZCBwb2ludHMgYXJvdW5kIGEgY29sb3Igd2hlZWwgYXJlIHVzZWQuIE92ZXJyaWRkZW4gYnkgdGhlICdjb2xvcicgb3B0aW9uLlwiXG4gIH0sXG4gIFwiY29ubmVjdFNlcGFyYXRlZFBvaW50c1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlVzdWFsbHksIHdoZW4gRHlncmFwaHMgZW5jb3VudGVycyBhIG1pc3NpbmcgdmFsdWUgaW4gYSBkYXRhIHNlcmllcywgaXQgaW50ZXJwcmV0cyB0aGlzIGFzIGEgZ2FwIGFuZCBkcmF3cyBpdCBhcyBzdWNoLiBJZiwgaW5zdGVhZCwgdGhlIG1pc3NpbmcgdmFsdWVzIHJlcHJlc2VudHMgYW4geC12YWx1ZSBmb3Igd2hpY2ggb25seSBhIGRpZmZlcmVudCBzZXJpZXMgaGFzIGRhdGEsIHRoZW4geW91J2xsIHdhbnQgdG8gY29ubmVjdCB0aGUgZG90cyBieSBzZXR0aW5nIHRoaXMgdG8gdHJ1ZS4gVG8gZXhwbGljaXRseSBpbmNsdWRlIGEgZ2FwIHdpdGggdGhpcyBvcHRpb24gc2V0LCB1c2UgYSB2YWx1ZSBvZiBOYU4uXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNhbGxiYWNrc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihldmVudCwgeCwgcG9pbnRzLCByb3csIHNlcmllc05hbWUpXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCB0aGlzIGNhbGxiYWNrIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBuZXcgcG9pbnQgaXMgaGlnaGxpZ2h0ZWQuXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFtcImV2ZW50XCIsIFwidGhlIEphdmFTY3JpcHQgbW91c2Vtb3ZlIGV2ZW50XCJdLFxuICAgICAgW1wieFwiLCBcInRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGhpZ2hsaWdodGVkIHBvaW50c1wiXSxcbiAgICAgIFtcInBvaW50c1wiLCBcImFuIGFycmF5IG9mIGhpZ2hsaWdodGVkIHBvaW50czogPGNvZGU+WyB7bmFtZTogJ3NlcmllcycsIHl2YWw6IHktdmFsdWV9LCAmaGVsbGlwOyBdPC9jb2RlPlwiXSxcbiAgICAgIFtcInJvd1wiLCBcImludGVnZXIgaW5kZXggb2YgdGhlIGhpZ2hsaWdodGVkIHJvdyBpbiB0aGUgZGF0YSB0YWJsZSwgc3RhcnRpbmcgZnJvbSAwXCJdLFxuICAgICAgW1wic2VyaWVzTmFtZVwiLCBcIm5hbWUgb2YgdGhlIGhpZ2hsaWdodGVkIHNlcmllcywgb25seSBwcmVzZW50IGlmIGhpZ2hsaWdodFNlcmllc09wdHMgaXMgc2V0LlwiXVxuICAgIF1cbiAgfSxcbiAgXCJkcmF3SGlnaGxpZ2h0UG9pbnRDYWxsYmFja1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGcsIHNlcmllc05hbWUsIGNhbnZhc0NvbnRleHQsIGN4LCBjeSwgY29sb3IsIHBvaW50U2l6ZSlcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImdcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwic2VyaWVzTmFtZVwiICwgXCJ0aGUgbmFtZSBvZiB0aGUgc2VyaWVzXCIgXSxcbiAgICAgIFsgXCJjYW52YXNDb250ZXh0XCIgLCBcInRoZSBjYW52YXMgdG8gZHJhdyBvblwiIF0sXG4gICAgICBbIFwiY3hcIiAsIFwiY2VudGVyIHggY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY3lcIiAsIFwiY2VudGVyIHkgY29vcmRpbmF0ZVwiIF0sXG4gICAgICBbIFwiY29sb3JcIiAsIFwic2VyaWVzIGNvbG9yXCIgXSxcbiAgICAgIFsgXCJwb2ludFNpemVcIiAsIFwidGhlIHJhZGl1cyBvZiB0aGUgaW1hZ2UuXCIgXSxcbiAgICAgIFsgXCJpZHhcIiAsIFwidGhlIHJvdy1pbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhlIGRhdGEuXCJdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBhIGN1c3RvbSBpdGVtIHdoZW4gYSBwb2ludCBpcyBoaWdobGlnaHRlZC4gIERlZmF1bHQgaXMgYSBzbWFsbCBkb3QgbWF0Y2hpbmcgdGhlIHNlcmllcyBjb2xvci4gVGhpcyBtZXRob2Qgc2hvdWxkIGNvbnN0cmFpbiBkcmF3aW5nIHRvIHdpdGhpbiBwb2ludFNpemUgcGl4ZWxzIGZyb20gKGN4LCBjeSkgQWxzbyBzZWUgPGEgaHJlZj0nI2RyYXdQb2ludENhbGxiYWNrJz5kcmF3UG9pbnRDYWxsYmFjazwvYT5cIlxuICB9LFxuICBcImhpZ2hsaWdodFNlcmllc09wdHNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJPYmplY3RcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoZSBvcHRpb25zIGZyb20gdGhpcyBvYmplY3QgYXJlIGFwcGxpZWQgdG8gdGhlIHRpbWVzZXJpZXMgY2xvc2VzdCB0byB0aGUgbW91c2UgcG9pbnRlciBmb3IgaW50ZXJhY3RpdmUgaGlnaGxpZ2h0aW5nLiBTZWUgYWxzbyAnaGlnaGxpZ2h0Q2FsbGJhY2snLiBFeGFtcGxlOiBoaWdobGlnaHRTZXJpZXNPcHRzOiB7IHN0cm9rZVdpZHRoOiAzIH0uXCJcbiAgfSxcbiAgXCJoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGFcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjAuNVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkZhZGUgdGhlIGJhY2tncm91bmQgd2hpbGUgaGlnaGxpZ2h0aW5nIHNlcmllcy4gMT1mdWxseSB2aXNpYmxlIGJhY2tncm91bmQgKGRpc2FibGUgZmFkaW5nKSwgMD1oaWRkZGVuIGJhY2tncm91bmQgKHNob3cgaGlnaGxpZ2h0ZWQgc2VyaWVzIG9ubHkpLlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZENvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciB1c2VkIHRvIGZhZGUgb3V0IHRoZSBzZXJpZXMgaW4gY29uanVuY3Rpb24gd2l0aCAnaGlnaGxpZ2h0U2VyaWVzQmFja2dyb3VuZEFscGhhJy5cIlxuICB9LFxuICBcImluY2x1ZGVaZXJvXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlVzdWFsbHksIGR5Z3JhcGhzIHdpbGwgdXNlIHRoZSByYW5nZSBvZiB0aGUgZGF0YSBwbHVzIHNvbWUgcGFkZGluZyB0byBzZXQgdGhlIHJhbmdlIG9mIHRoZSB5LWF4aXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHktYXhpcyB3aWxsIGFsd2F5cyBpbmNsdWRlIHplcm8sIHR5cGljYWxseSBhcyB0aGUgbG93ZXN0IHZhbHVlLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGF2b2lkIGV4YWdnZXJhdGluZyB0aGUgdmFyaWFuY2UgaW4gdGhlIGRhdGFcIlxuICB9LFxuICBcInJvbGxQZXJpb2RcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjFcIixcbiAgICBcImxhYmVsc1wiOiBbXCJFcnJvciBCYXJzXCIsIFwiUm9sbGluZyBBdmVyYWdlc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyICZndDs9IDFcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTnVtYmVyIG9mIGRheXMgb3ZlciB3aGljaCB0byBhdmVyYWdlIGRhdGEuIERpc2N1c3NlZCBleHRlbnNpdmVseSBhYm92ZS5cIlxuICB9LFxuICBcInVuaGlnaGxpZ2h0Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZXZlbnQpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgdXNlciBzdG9wcyBoaWdobGlnaHRpbmcgYW55IHBvaW50IGJ5IG1vdXNpbmcgb3V0IG9mIHRoZSBncmFwaC5cIlxuICB9LFxuICBcImF4aXNUaWNrU2l6ZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMy4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc2l6ZSBvZiB0aGUgbGluZSB0byBkaXNwbGF5IG5leHQgdG8gZWFjaCB0aWNrIG1hcmsgb24geC0gb3IgeS1heGVzLlwiXG4gIH0sXG4gIFwibGFiZWxzU2VwYXJhdGVMaW5lc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJQdXQgPGNvZGU+Jmx0O2JyLyZndDs8L2NvZGU+IGJldHdlZW4gbGluZXMgaW4gdGhlIGxhYmVsIHN0cmluZy4gT2Z0ZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIDxzdHJvbmc+bGFiZWxzRGl2PC9zdHJvbmc+LlwiXG4gIH0sXG4gIFwidmFsdWVGb3JtYXR0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIkRlcGVuZHMgb24gdGhlIHR5cGUgb2YgeW91ciBkYXRhLlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiLCBcIlZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZ1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihudW0gb3IgbWlsbGlzLCBvcHRzLCBzZXJpZXNOYW1lLCBkeWdyYXBoLCByb3csIGNvbClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRnVuY3Rpb24gdG8gcHJvdmlkZSBhIGN1c3RvbSBkaXNwbGF5IGZvcm1hdCBmb3IgdGhlIHZhbHVlcyBkaXNwbGF5ZWQgb24gbW91c2VvdmVyLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgdmFsdWVzIHRoYXQgYXBwZWFyIG9uIHRpY2sgbWFya3MgbmV4dCB0byB0aGUgYXhlcy4gVG8gZm9ybWF0IHRob3NlLCBzZWUgYXhpc0xhYmVsRm9ybWF0dGVyLiBUaGlzIGlzIHVzdWFsbHkgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLWF4aXM8L2E+IGJhc2lzLiAuXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFtcIm51bV9vcl9taWxsaXNcIiwgXCJUaGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkLiBUaGlzIGlzIGFsd2F5cyBhIG51bWJlci4gRm9yIGRhdGUgYXhlcywgaXQncyBtaWxsaXMgc2luY2UgZXBvY2guIFlvdSBjYW4gY2FsbCBuZXcgRGF0ZShtaWxsaXMpIHRvIGdldCBhIERhdGUgb2JqZWN0LlwiXSxcbiAgICAgIFtcIm9wdHNcIiwgXCJUaGlzIGlzIGEgZnVuY3Rpb24geW91IGNhbiBjYWxsIHRvIGFjY2VzcyB2YXJpb3VzIG9wdGlvbnMgKGUuZy4gb3B0cygnbGFiZWxzS01CJykpLiBJdCByZXR1cm5zIHBlci1heGlzIHZhbHVlcyBmb3IgdGhlIG9wdGlvbiB3aGVuIGF2YWlsYWJsZS5cIl0sXG4gICAgICBbXCJzZXJpZXNOYW1lXCIsIFwiVGhlIG5hbWUgb2YgdGhlIHNlcmllcyBmcm9tIHdoaWNoIHRoZSBwb2ludCBjYW1lLCBlLmcuICdYJywgJ1knLCAnQScsIGV0Yy5cIl0sXG4gICAgICBbXCJkeWdyYXBoXCIsIFwiVGhlIGR5Z3JhcGggb2JqZWN0IGZvciB3aGljaCB0aGUgZm9ybWF0dGluZyBpcyBiZWluZyBkb25lXCJdLFxuICAgICAgW1wicm93XCIsIFwiVGhlIHJvdyBvZiB0aGUgZGF0YSBmcm9tIHdoaWNoIHRoaXMgcG9pbnQgY29tZXMuIGcuZ2V0VmFsdWUocm93LCAwKSB3aWxsIHJldHVybiB0aGUgeC12YWx1ZSBmb3IgdGhpcyBwb2ludC5cIl0sXG4gICAgICBbXCJjb2xcIiwgXCJUaGUgY29sdW1uIG9mIHRoZSBkYXRhIGZyb20gd2hpY2ggdGhpcyBwb2ludCBjb21lcy4gZy5nZXRWYWx1ZShyb3csIGNvbCkgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHktdmFsdWUgZm9yIHRoaXMgcG9pbnQuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBmdWxsIGNvbmZpZGVuY2UgaW50ZXJ2YWwgZm9yIHRoZSBwb2ludCwgb3IgYWNjZXNzIHVuLXJvbGxlZCB2YWx1ZXMgZm9yIHRoZSBwb2ludC5cIl1cbiAgICBdXG4gIH0sXG4gIFwiYW5ub3RhdGlvbk1vdXNlT3ZlckhhbmRsZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBbm5vdGF0aW9uc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihhbm5vdGF0aW9uLCBwb2ludCwgZHlncmFwaCwgZXZlbnQpXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBtb3VzZXMgb3ZlciBhbiBhbm5vdGF0aW9uLlwiXG4gIH0sXG4gIFwiYW5ub3RhdGlvbk1vdXNlT3V0SGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGFubm90YXRpb24sIHBvaW50LCBkeWdyYXBoLCBldmVudClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImFubm90YXRpb25cIiAsIFwidGhlIGFubm90YXRpb24gbGVmdFwiIF0sXG4gICAgICBbIFwicG9pbnRcIiAsIFwidGhlIHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5ub3RhdGlvblwiIF0sXG4gICAgICBbIFwiZHlncmFwaFwiICwgXCJ0aGUgcmVmZXJlbmNlIGdyYXBoXCIgXSxcbiAgICAgIFsgXCJldmVudFwiICwgXCJ0aGUgbW91c2UgZXZlbnRcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIG1vdXNlcyBvdXQgb2YgYW4gYW5ub3RhdGlvbi5cIlxuICB9LFxuICBcImFubm90YXRpb25DbGlja0hhbmRsZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBbm5vdGF0aW9uc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihhbm5vdGF0aW9uLCBwb2ludCwgZHlncmFwaCwgZXZlbnQpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJhbm5vdGF0aW9uXCIgLCBcInRoZSBhbm5vdGF0aW9uIGxlZnRcIiBdLFxuICAgICAgWyBcInBvaW50XCIgLCBcInRoZSBwb2ludCBhc3NvY2lhdGVkIHdpdGggdGhlIGFubm90YXRpb25cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwiZXZlbnRcIiAsIFwidGhlIG1vdXNlIGV2ZW50XCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBjbGlja3Mgb24gYW4gYW5ub3RhdGlvbi5cIlxuICB9LFxuICBcImFubm90YXRpb25EYmxDbGlja0hhbmRsZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBbm5vdGF0aW9uc1wiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihhbm5vdGF0aW9uLCBwb2ludCwgZHlncmFwaCwgZXZlbnQpXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IFtcbiAgICAgIFsgXCJhbm5vdGF0aW9uXCIgLCBcInRoZSBhbm5vdGF0aW9uIGxlZnRcIiBdLFxuICAgICAgWyBcInBvaW50XCIgLCBcInRoZSBwb2ludCBhc3NvY2lhdGVkIHdpdGggdGhlIGFubm90YXRpb25cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZSBncmFwaFwiIF0sXG4gICAgICBbIFwiZXZlbnRcIiAsIFwidGhlIG1vdXNlIGV2ZW50XCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIGFuIGFubm90YXRpb24uXCJcbiAgfSxcbiAgXCJkcmF3Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZHlncmFwaCwgaXNfaW5pdGlhbClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwiVGhlIGdyYXBoIGJlaW5nIGRyYXduXCIgXSxcbiAgICAgIFsgXCJpc19pbml0aWFsXCIgLCBcIlRydWUgaWYgdGhpcyBpcyB0aGUgaW5pdGlhbCBkcmF3LCBmYWxzZSBmb3Igc3Vic2VxdWVudCBkcmF3cy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgZHlncmFwaCBpcyBkcmF3bi4gVGhpcyBpbmNsdWRlcyB0aGUgaW5pdGlhbCBkcmF3LCBhZnRlciB6b29taW5nIGFuZCByZXBlYXRlZGx5IHdoaWxlIHBhbm5pbmcuXCJcbiAgfSxcbiAgXCJsYWJlbHNLTUcyXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZ1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3cgay9NL0cgZm9yIGtpbG8vTWVnYS9HaWdhIG9uIHktYXhpcy4gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiA8Y29kZT5sYWJlbHNLTUI8L2NvZGU+IGluIHRoYXQgaXQgdXNlcyBiYXNlIDIsIG5vdCAxMC5cIlxuICB9LFxuICBcImRlbGltaXRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiLFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZGVsaW1pdGVyIHRvIGxvb2sgZm9yIHdoZW4gc2VwYXJhdGluZyBmaWVsZHMgb2YgYSBDU1YgZmlsZS4gU2V0dGluZyB0aGlzIHRvIGEgdGFiIGlzIG5vdCB1c3VhbGx5IG5lY2Vzc2FyeSwgc2luY2UgdGFiLWRlbGltaXRlZCBkYXRhIGlzIGF1dG8tZGV0ZWN0ZWQuXCJcbiAgfSxcbiAgXCJheGlzTGFiZWxGb250U2l6ZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMTRcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaXplIG9mIHRoZSBmb250IChpbiBwaXhlbHMpIHRvIHVzZSBpbiB0aGUgYXhpcyBsYWJlbHMsIGJvdGggeC0gYW5kIHktYXhpcy5cIlxuICB9LFxuICBcInVuZGVybGF5Q2FsbGJhY2tcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJDYWxsYmFja3NcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oY29udGV4dCwgYXJlYSwgZHlncmFwaClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImNvbnRleHRcIiAsIFwidGhlIGNhbnZhcyBkcmF3aW5nIGNvbnRleHQgb24gd2hpY2ggdG8gZHJhd1wiIF0sXG4gICAgICBbIFwiYXJlYVwiICwgXCJBbiBvYmplY3Qgd2l0aCB7eCx5LHcsaH0gcHJvcGVydGllcyBkZXNjcmliaW5nIHRoZSBkcmF3aW5nIGFyZWEuXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBzZXQsIHRoaXMgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlIHRoZSBjaGFydCBpcyBkcmF3bi4gSXQgZGV0YWlscyBvbiBob3cgdG8gdXNlIHRoaXMuXCJcbiAgfSxcbiAgXCJ3aWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiNDgwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiT3ZlcmFsbCBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2lkdGgsIGluIHBpeGVscywgb2YgdGhlIGNoYXJ0LiBJZiB0aGUgY29udGFpbmVyIGRpdiBoYXMgYmVlbiBleHBsaWNpdGx5IHNpemVkLCB0aGlzIHdpbGwgYmUgaWdub3JlZC5cIlxuICB9LFxuICBcImludGVyYWN0aW9uTW9kZWxcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIi4uLlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcIk9iamVjdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUT0RPKGtvbmlnc2JlcmcpOiBkb2N1bWVudCB0aGlzXCJcbiAgfSxcbiAgXCJ0aWNrZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIkR5Z3JhcGguZGF0ZVRpY2tlciBvciBEeWdyYXBoLm51bWVyaWNUaWNrc1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvbihtaW4sIG1heCwgcGl4ZWxzLCBvcHRzLCBkeWdyYXBoLCB2YWxzKSAtPiBbe3Y6IC4uLiwgbGFiZWw6IC4uLn0sIC4uLl1cIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm1pblwiICwgXCJcIiBdLFxuICAgICAgWyBcIm1heFwiICwgXCJcIiBdLFxuICAgICAgWyBcInBpeGVsc1wiICwgXCJcIiBdLFxuICAgICAgWyBcIm9wdHNcIiAsIFwiXCIgXSxcbiAgICAgIFsgXCJkeWdyYXBoXCIgLCBcInRoZSByZWZlcmVuY2UgZ3JhcGhcIiBdLFxuICAgICAgWyBcInZhbHNcIiAsIFwiXCIgXVxuICAgIF0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoaXMgbGV0cyB5b3Ugc3BlY2lmeSBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGljayBtYXJrcyBvbiBhbiBheGlzLiBUaGUgdGljayBtYXJrcyBhcmUgYW4gYXJyYXkgb2YgKHZhbHVlLCBsYWJlbCkgcGFpcnMuIFRoZSBidWlsdC1pbiBmdW5jdGlvbnMgZ28gdG8gZ3JlYXQgbGVuZ3RocyB0byBjaG9vc2UgZ29vZCB0aWNrIG1hcmtzIHNvLCBpZiB5b3Ugc2V0IHRoaXMgb3B0aW9uLCB5b3UnbGwgbW9zdCBsaWtlbHkgd2FudCB0byBjYWxsIG9uZSBvZiB0aGVtIGFuZCBtb2RpZnkgdGhlIHJlc3VsdC4gU2VlIGR5Z3JhcGgtdGlja2Vycy5qcyBmb3IgYW4gZXh0ZW5zaXZlIGRpc2N1c3Npb24uIFRoaXMgaXMgc2V0IG9uIGEgPGEgaHJlZj0ncGVyLWF4aXMuaHRtbCc+cGVyLWF4aXM8L2E+IGJhc2lzLlwiXG4gIH0sXG4gIFwieEF4aXNIZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIihudWxsKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkhlaWdodCwgaW4gcGl4ZWxzLCBvZiB0aGUgeC1heGlzLiBJZiBub3Qgc2V0IGV4cGxpY2l0bHksIHRoaXMgaXMgY29tcHV0ZWQgYmFzZWQgb24gYXhpc0xhYmVsRm9udFNpemUgYW5kIGF4aXNUaWNrU2l6ZS5cIlxuICB9LFxuICBcInNob3dMYWJlbHNPbkhpZ2hsaWdodFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCIsIFwiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0byBzaG93IHRoZSBsZWdlbmQgdXBvbiBtb3VzZW92ZXIuXCJcbiAgfSxcbiAgXCJheGlzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIobm9uZSlcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldCB0byBlaXRoZXIgJ3kxJyBvciAneTInIHRvIGFzc2lnbiBhIHNlcmllcyB0byBhIHktYXhpcyAocHJpbWFyeSBvciBzZWNvbmRhcnkpLiBNdXN0IGJlIHNldCBwZXItc2VyaWVzLlwiXG4gIH0sXG4gIFwicGl4ZWxzUGVyTGFiZWxcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjcwICh4LWF4aXMpIG9yIDMwICh5LWF4ZXMpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCIsIFwiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIk51bWJlciBvZiBwaXhlbHMgdG8gcmVxdWlyZSBiZXR3ZWVuIGVhY2ggeC0gYW5kIHktbGFiZWwuIExhcmdlciB2YWx1ZXMgd2lsbCB5aWVsZCBhIHNwYXJzZXIgYXhpcyB3aXRoIGZld2VyIHRpY2tzLiBUaGlzIGlzIHNldCBvbiBhIDxhIGhyZWY9J3Blci1heGlzLmh0bWwnPnBlci1heGlzPC9hPiBiYXNpcy5cIlxuICB9LFxuICBcImxhYmVsc0RpdlwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJET00gZWxlbWVudCBvciBzdHJpbmdcIixcbiAgICBcImV4YW1wbGVcIjogXCI8Y29kZSBzdHlsZT0nZm9udC1zaXplOiBzbWFsbCc+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpPC9jb2RlPm9yPGNvZGU+J2ZvbydcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyBkYXRhIGxhYmVscyBpbiBhbiBleHRlcm5hbCBkaXYsIHJhdGhlciB0aGFuIG9uIHRoZSBncmFwaC4gIFRoaXMgdmFsdWUgY2FuIGVpdGhlciBiZSBhIGRpdiBlbGVtZW50IG9yIGEgZGl2IGlkLlwiXG4gIH0sXG4gIFwiZnJhY3Rpb25zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCIsIFwiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBhdHRlbXB0IHRvIHBhcnNlIGVhY2ggY2VsbCBpbiB0aGUgQ1NWIGZpbGUgYXMgXFxcImEvYlxcXCIsIHdoZXJlIGEgYW5kIGIgYXJlIGludGVnZXJzLiBUaGUgcmF0aW8gd2lsbCBiZSBwbG90dGVkLiBUaGlzIGFsbG93cyBjb21wdXRhdGlvbiBvZiBXaWxzb24gY29uZmlkZW5jZSBpbnRlcnZhbHMgKHNlZSBiZWxvdykuXCJcbiAgfSxcbiAgXCJsb2dzY2FsZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCBmb3IgdGhlIHktYXhpcyBvciB4LWF4aXMsIHRoZSBncmFwaCBzaG93cyB0aGF0IGF4aXMgaW4gbG9nIHNjYWxlLiBBbnkgdmFsdWVzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFyZSBub3QgZGlzcGxheWVkLiBTaG93aW5nIGxvZyBzY2FsZSB3aXRoIHJhbmdlcyB0aGF0IGdvIGJlbG93IHplcm8gd2lsbCByZXN1bHQgaW4gYW4gdW52aWV3YWJsZSBncmFwaC5cXG5cXG4gTm90IGNvbXBhdGlibGUgd2l0aCBzaG93WmVyby4gY29ubmVjdFNlcGFyYXRlZFBvaW50cyBpcyBpZ25vcmVkLiBUaGlzIGlzIGlnbm9yZWQgZm9yIGRhdGUtYmFzZWQgeC1heGVzLlwiXG4gIH0sXG4gIFwic3Ryb2tlV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjEuMFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJleGFtcGxlXCI6IFwiMC41LCAyLjBcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBjb25uZWN0aW5nIGRhdGEgcG9pbnRzLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGluY3JlYXNlIHRoZSBjb250cmFzdCBvciBzb21lIGdyYXBocy5cIlxuICB9LFxuICBcInN0cm9rZVBhdHRlcm5cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxpbnRlZ2VyPlwiLFxuICAgIFwiZXhhbXBsZVwiOiBcIlsxMCwgMiwgNSwgMl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBjdXN0b20gcGF0dGVybiBhcnJheSB3aGVyZSB0aGUgZXZlbiBpbmRleCBpcyBhIGRyYXcgYW5kIG9kZCBpcyBhIHNwYWNlIGluIHBpeGVscy4gSWYgbnVsbCB0aGVuIGl0IGRyYXdzIGEgc29saWQgbGluZS4gVGhlIGFycmF5IHNob3VsZCBoYXZlIGEgZXZlbiBsZW5ndGggYXMgYW55IG9kZCBsZW5ndGhlZCBhcnJheSBjb3VsZCBiZSBleHByZXNzZWQgYXMgYSBzbWFsbGVyIGV2ZW4gbGVuZ3RoIGFycmF5LiBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGRhc2hlZCBsaW5lcy5cIlxuICB9LFxuICBcInN0cm9rZUJvcmRlcldpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImV4YW1wbGVcIjogXCIxLjBcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRHJhdyBhIGJvcmRlciBhcm91bmQgZ3JhcGggbGluZXMgdG8gbWFrZSBjcm9zc2luZyBsaW5lcyBtb3JlIGVhc2lseSBkaXN0aW5ndWlzaGFibGUuIFVzZWZ1bCBmb3IgZ3JhcGhzIHdpdGggbWFueSBsaW5lcy5cIlxuICB9LFxuICBcInN0cm9rZUJvcmRlckNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ3aGl0ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcInJlZCwgI2NjZmZkZFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb2xvciBmb3IgdGhlIGxpbmUgYm9yZGVyIHVzZWQgaWYgc3Ryb2tlQm9yZGVyV2lkdGggaXMgc2V0LlwiXG4gIH0sXG4gIFwid2lsc29uSW50ZXJ2YWxcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIFxcXCJmcmFjdGlvbnNcXFwiIG9wdGlvbi4gSW5zdGVhZCBvZiBwbG90dGluZyArLy0gTiBzdGFuZGFyZCBkZXZpYXRpb25zLCBkeWdyYXBocyB3aWxsIGNvbXB1dGUgYSBXaWxzb24gY29uZmlkZW5jZSBpbnRlcnZhbCBhbmQgcGxvdCB0aGF0LiBUaGlzIGhhcyBtb3JlIHJlYXNvbmFibGUgYmVoYXZpb3IgZm9yIHJhdGlvcyBjbG9zZSB0byAwIG9yIDEuXCJcbiAgfSxcbiAgXCJmaWxsR3JhcGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG91bGQgdGhlIGFyZWEgdW5kZXJuZWF0aCB0aGUgZ3JhcGggYmUgZmlsbGVkPyBUaGlzIG9wdGlvbiBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGVycm9yIGJhcnMuIFRoaXMgbWF5IGJlIHNldCBvbiBhIDxhIGhyZWY9J3Blci1heGlzLmh0bWwnPnBlci1zZXJpZXM8L2E+IGJhc2lzLlwiXG4gIH0sXG4gIFwiaGlnaGxpZ2h0Q2lyY2xlU2l6ZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiM1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNpemUgaW4gcGl4ZWxzIG9mIHRoZSBkb3QgZHJhd24gb3ZlciBoaWdobGlnaHRlZCBwb2ludHMuXCJcbiAgfSxcbiAgXCJncmlkTGluZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJyZ2IoMTI4LDEyOCwxMjgpXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiR3JpZFwiXSxcbiAgICBcInR5cGVcIjogXCJyZWQsIGJsdWVcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBncmlkbGluZXMuIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSBlYWNoIGF4aXMnIGdyaWQgc2VwYXJhdGVseS5cIlxuICB9LFxuICBcImdyaWRMaW5lUGF0dGVyblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYXJyYXk8aW50ZWdlcj5cIixcbiAgICBcImV4YW1wbGVcIjogXCJbMTAsIDIsIDUsIDJdXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgY3VzdG9tIHBhdHRlcm4gYXJyYXkgd2hlcmUgdGhlIGV2ZW4gaW5kZXggaXMgYSBkcmF3IGFuZCBvZGQgaXMgYSBzcGFjZSBpbiBwaXhlbHMuIElmIG51bGwgdGhlbiBpdCBkcmF3cyBhIHNvbGlkIGxpbmUuIFRoZSBhcnJheSBzaG91bGQgaGF2ZSBhIGV2ZW4gbGVuZ3RoIGFzIGFueSBvZGQgbGVuZ3RoZWQgYXJyYXkgY291bGQgYmUgZXhwcmVzc2VkIGFzIGEgc21hbGxlciBldmVuIGxlbmd0aCBhcnJheS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBkYXNoZWQgZ3JpZGxpbmVzLlwiXG4gIH0sXG4gIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiW3RydWUsIHRydWUsIC4uLl1cIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIExpbmUgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheSBvZiBib29sZWFuc1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGljaCBzZXJpZXMgc2hvdWxkIGluaXRpYWxseSBiZSB2aXNpYmxlPyBPbmNlIHRoZSBEeWdyYXBoIGhhcyBiZWVuIGNvbnN0cnVjdGVkLCB5b3UgY2FuIGFjY2VzcyBhbmQgbW9kaWZ5IHRoZSB2aXNpYmlsaXR5IG9mIGVhY2ggc2VyaWVzIHVzaW5nIHRoZSA8Y29kZT52aXNpYmlsaXR5PC9jb2RlPiBhbmQgPGNvZGU+c2V0VmlzaWJpbGl0eTwvY29kZT4gbWV0aG9kcy5cIlxuICB9LFxuICBcInZhbHVlUmFuZ2VcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIkZ1bGwgcmFuZ2Ugb2YgdGhlIGlucHV0IGlzIHNob3duXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcIkFycmF5IG9mIHR3byBudW1iZXJzXCIsXG4gICAgXCJleGFtcGxlXCI6IFwiWzEwLCAxMTBdXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkV4cGxpY2l0bHkgc2V0IHRoZSB2ZXJ0aWNhbCByYW5nZSBvZiB0aGUgZ3JhcGggdG8gW2xvdywgaGlnaF0uIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSBlYWNoIHktYXhpcyBzZXBhcmF0ZWx5LiBJZiBlaXRoZXIgbGltaXQgaXMgdW5zcGVjaWZpZWQsIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IChlLmcuIFtudWxsLCAzMF0gdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUganVzdCB0aGUgbG93ZXIgYm91bmQpXCJcbiAgfSxcbiAgXCJsYWJlbHNEaXZXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMjUwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2lkdGggKGluIHBpeGVscykgb2YgdGhlIGRpdiB3aGljaCBzaG93cyBpbmZvcm1hdGlvbiBvbiB0aGUgY3VycmVudGx5LWhpZ2hsaWdodGVkIHBvaW50cy5cIlxuICB9LFxuICBcImNvbG9yU2F0dXJhdGlvblwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMS4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIDxzdHJvbmc+Y29sb3JzPC9zdHJvbmc+IGlzIG5vdCBzcGVjaWZpZWQsIHNhdHVyYXRpb24gb2YgdGhlIGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIGRhdGEgc2VyaWVzIGNvbG9ycy5cIlxuICB9LFxuICBcImhpZGVPdmVybGF5T25Nb3VzZU91dFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwidHJ1ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkludGVyYWN0aXZlIEVsZW1lbnRzXCIsIFwiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hldGhlciB0byBoaWRlIHRoZSBsZWdlbmQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjaGFydCBhcmVhLlwiXG4gIH0sXG4gIFwibGVnZW5kXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJvbm1vdXNlb3ZlclwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiB0byBkaXNwbGF5IHRoZSBsZWdlbmQuIEJ5IGRlZmF1bHQsIGl0IG9ubHkgYXBwZWFycyB3aGVuIGEgdXNlciBtb3VzZXMgb3ZlciB0aGUgY2hhcnQuIFNldCBpdCB0byBcXFwiYWx3YXlzXFxcIiB0byBhbHdheXMgZGlzcGxheSBhIGxlZ2VuZCBvZiBzb21lIHNvcnQuIFdoZW4gc2V0IHRvIFxcXCJmb2xsb3dcXFwiLCBsZWdlbmQgZm9sbG93cyBoaWdobGlnaHRlZCBwb2ludHMuXCJcbiAgfSxcbiAgXCJsZWdlbmRGb3JtYXR0ZXJcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJMZWdlbmRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb24oZGF0YSk6IHN0cmluZ1wiLFxuICAgIFwicGFyYW1zXCI6IFtcbiAgICAgIFsgXCJkYXRhXCIsIFwiQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlbGVjdGlvbiAob3IgbGFjayBvZiBhIHNlbGVjdGlvbikuIFRoaXMgaW5jbHVkZXMgZm9ybWF0dGVkIHZhbHVlcyBhbmQgc2VyaWVzIGluZm9ybWF0aW9uLiBTZWUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL2RhbnZrL2R5Z3JhcGhzL3B1bGwvNjgzXFxcIj5oZXJlPC9hPiBmb3Igc2FtcGxlIHZhbHVlcy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2V0IHRoaXMgdG8gc3VwcGx5IGEgY3VzdG9tIGZvcm1hdHRlciBmb3IgdGhlIGxlZ2VuZC4gU2VlIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9kYW52ay9keWdyYXBocy9wdWxsLzY4M1xcXCI+dGhpcyBjb21tZW50PC9hPiBhbmQgdGhlIDxhIGhyZWY9XFxcInRlc3RzL2xlZ2VuZC1mb3JtYXR0ZXIuaHRtbFxcXCI+bGVnZW5kRm9ybWF0dGVyIGRlbW88L2E+IGZvciB1c2FnZS5cIlxuICB9LFxuICBcImxhYmVsc1Nob3daZXJvVmFsdWVzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiTGVnZW5kXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiU2hvdyB6ZXJvIHZhbHVlIGxhYmVscyBpbiB0aGUgbGFiZWxzRGl2LlwiXG4gIH0sXG4gIFwic3RlcFBsb3RcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRGF0YSBMaW5lIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIHNldCwgZGlzcGxheSB0aGUgZ3JhcGggYXMgYSBzdGVwIHBsb3QgaW5zdGVhZCBvZiBhIGxpbmUgcGxvdC4gVGhpcyBvcHRpb24gbWF5IGVpdGhlciBiZSBzZXQgZm9yIHRoZSB3aG9sZSBncmFwaCBvciBmb3Igc2luZ2xlIHNlcmllcy5cIlxuICB9LFxuICBcImxhYmVsc1VUQ1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIiwgXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IGRhdGUvdGltZSBsYWJlbHMgYWNjb3JkaW5nIHRvIFVUQyAoaW5zdGVhZCBvZiBsb2NhbCB0aW1lKS5cIlxuICB9LFxuICBcImxhYmVsc0tNQlwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IEsvTS9CIGZvciB0aG91c2FuZHMvbWlsbGlvbnMvYmlsbGlvbnMgb24geS1heGlzLlwiXG4gIH0sXG4gIFwicmlnaHRHYXBcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJPdmVyYWxsIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgcGl4ZWxzIHRvIGxlYXZlIGJsYW5rIGF0IHRoZSByaWdodCBlZGdlIG9mIHRoZSBEeWdyYXBoLiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBoaWdobGlnaHQgdGhlIHJpZ2h0LW1vc3QgZGF0YSBwb2ludC5cIlxuICB9LFxuICBcImF2b2lkTWluWmVyb1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEZXByZWNhdGVkXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSB5UmFuZ2VQYWQgaW5zdGVhZC4gV2hlbiBzZXQsIHRoZSBoZXVyaXN0aWMgdGhhdCBmaXhlcyB0aGUgWSBheGlzIGF0IHplcm8gZm9yIGEgZGF0YSBzZXQgd2l0aCB0aGUgbWluaW11bSBZIHZhbHVlIG9mIHplcm8gaXMgZGlzYWJsZWQuIFxcblRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZGF0YSBzZXRzIHRoYXQgY29udGFpbiBtYW55IHplcm8gdmFsdWVzLCBlc3BlY2lhbGx5IGZvciBzdGVwIHBsb3RzIHdoaWNoIG1heSBvdGhlcndpc2UgaGF2ZSBsaW5lcyBub3QgdmlzaWJsZSBydW5uaW5nIGFsb25nIHRoZSBib3R0b20gYXhpcy5cIlxuICB9LFxuICBcImRyYXdBeGVzQXRaZXJvXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBkcmF3IHRoZSBYIGF4aXMgYXQgdGhlIFk9MCBwb3NpdGlvbiBhbmQgdGhlIFkgYXhpcyBhdCB0aGUgWD0wIHBvc2l0aW9uIGlmIHRob3NlIHBvc2l0aW9ucyBhcmUgaW5zaWRlIHRoZSBncmFwaCdzIHZpc2libGUgYXJlYS4gT3RoZXJ3aXNlLCBkcmF3IHRoZSBheGVzIGF0IHRoZSBib3R0b20gb3IgbGVmdCBncmFwaCBlZGdlIGFzIHVzdWFsLlwiXG4gIH0sXG4gIFwieFJhbmdlUGFkXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFgtYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS5cIlxuICB9LFxuICBcInlSYW5nZVBhZFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiBzZXQsIGFkZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiBleHRyYSBzcGFjZSAoaW4gcGl4ZWxzKSBhcm91bmQgdGhlIFktYXhpcyB2YWx1ZSByYW5nZSB0byBlbnN1cmUgcG9pbnRzIGF0IHRoZSBlZGdlcyByZW1haW4gdmlzaWJsZS4gSWYgdW5zZXQsIHVzZSB0aGUgdHJhZGl0aW9uYWwgWSBwYWRkaW5nIGFsZ29yaXRobS5cIlxuICB9LFxuICBcImF4aXNMYWJlbEZvcm1hdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiRGVwZW5kcyBvbiB0aGUgZGF0YSB0eXBlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKG51bWJlciBvciBEYXRlLCBncmFudWxhcml0eSwgb3B0cywgZHlncmFwaClcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcIm51bWJlciBvciBkYXRlXCIgLCBcIkVpdGhlciBhIG51bWJlciAoZm9yIGEgbnVtZXJpYyBheGlzKSBvciBhIERhdGUgb2JqZWN0IChmb3IgYSBkYXRlIGF4aXMpXCIgXSxcbiAgICAgIFsgXCJncmFudWxhcml0eVwiICwgXCJzcGVjaWZpZXMgaG93IGZpbmUtZ3JhaW5lZCB0aGUgYXhpcyBpcy4gRm9yIGRhdGUgYXhlcywgdGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZSBncmFudWxhcml0eSBlbnVtZXJhdGlvbiwgZGVmaW5lZCBpbiBkeWdyYXBoLXRpY2tlcnMuanMsIGUuZy4gRHlncmFwaC5XRUVLTFkuXCIgXSxcbiAgICAgIFsgXCJvcHRzXCIgLCBcImEgZnVuY3Rpb24gd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIHZhcmlvdXMgb3B0aW9ucyBvbiB0aGUgZHlncmFwaCwgZS5nLiBvcHRzKCdsYWJlbHNLTUInKS5cIiBdLFxuICAgICAgWyBcImR5Z3JhcGhcIiAsIFwidGhlIHJlZmVyZW5jZWQgZ3JhcGhcIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRnVuY3Rpb24gdG8gY2FsbCB0byBmb3JtYXQgdGhlIHRpY2sgdmFsdWVzIHRoYXQgYXBwZWFyIGFsb25nIGFuIGF4aXMuIFRoaXMgaXMgdXN1YWxseSBzZXQgb24gYSA8YSBocmVmPSdwZXItYXhpcy5odG1sJz5wZXItYXhpczwvYT4gYmFzaXMuXCJcbiAgfSxcbiAgXCJjbGlja0NhbGxiYWNrXCI6IHtcbiAgICBcInNuaXBwZXRcIjogXCJmdW5jdGlvbihlLCBkYXRlX21pbGxpcyl7PGJyPiZuYnNwOyZuYnNwO2FsZXJ0KG5ldyBEYXRlKGRhdGVfbWlsbGlzKSk7PGJyPn1cIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2FsbGJhY2tzXCJdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uKGUsIHgsIHBvaW50cylcIixcbiAgICBcInBhcmFtZXRlcnNcIjogW1xuICAgICAgWyBcImVcIiAsIFwiVGhlIGV2ZW50IG9iamVjdCBmb3IgdGhlIGNsaWNrXCIgXSxcbiAgICAgIFsgXCJ4XCIgLCBcIlRoZSB4IHZhbHVlIHRoYXQgd2FzIGNsaWNrZWQgKGZvciBkYXRlcywgdGhpcyBpcyBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2gpXCIgXSxcbiAgICAgIFsgXCJwb2ludHNcIiAsIFwiVGhlIGNsb3Nlc3QgcG9pbnRzIGFsb25nIHRoYXQgZGF0ZS4gU2VlIDxhIGhyZWY9JyNwb2ludF9wcm9wZXJ0aWVzJz5Qb2ludCBwcm9wZXJ0aWVzPC9hPiBmb3IgZGV0YWlscy5cIiBdXG4gICAgXSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGNhbnZhcyBpcyBjbGlja2VkLlwiXG4gIH0sXG4gIFwibGFiZWxzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbXFxcIlhcXFwiLCBcXFwiWTFcXFwiLCBcXFwiWTJcXFwiLCAuLi5dKlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkxlZ2VuZFwiXSxcbiAgICBcInR5cGVcIjogXCJhcnJheTxzdHJpbmc+XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbmFtZSBmb3IgZWFjaCBkYXRhIHNlcmllcywgaW5jbHVkaW5nIHRoZSBpbmRlcGVuZGVudCAoWCkgc2VyaWVzLiBGb3IgQ1NWIGZpbGVzIGFuZCBEYXRhVGFibGUgb2JqZWN0aW9ucywgdGhpcyBpcyBkZXRlcm1pbmVkIGJ5IGNvbnRleHQuIEZvciByYXcgZGF0YSwgdGhpcyBtdXN0IGJlIHNwZWNpZmllZC4gSWYgaXQgaXMgbm90LCBkZWZhdWx0IHZhbHVlcyBhcmUgc3VwcGxpZWQgYW5kIGEgd2FybmluZyBpcyBsb2dnZWQuXCJcbiAgfSxcbiAgXCJkYXRlV2luZG93XCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJGdWxsIHJhbmdlIG9mIHRoZSBpbnB1dCBpcyBzaG93blwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiXSxcbiAgICBcInR5cGVcIjogXCJBcnJheSBvZiB0d28gbnVtYmVyc1wiLFxuICAgIFwiZXhhbXBsZVwiOiBcIls8YnI+Jm5ic3A7Jm5ic3A7RGF0ZS5wYXJzZSgnMjAwNi0wMS0wMScpLDxicj4mbmJzcDsmbmJzcDsobmV3IERhdGUoKSkudmFsdWVPZigpPGJyPl1cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSW5pdGlhbGx5IHpvb20gaW4gb24gYSBzZWN0aW9uIG9mIHRoZSBncmFwaC4gSXMgb2YgdGhlIGZvcm0gW2VhcmxpZXN0LCBsYXRlc3RdLCB3aGVyZSBlYXJsaWVzdC9sYXRlc3QgYXJlIG1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaC4gSWYgdGhlIGRhdGEgZm9yIHRoZSB4LWF4aXMgaXMgbnVtZXJpYywgdGhlIHZhbHVlcyBpbiBkYXRlV2luZG93IG11c3QgYWxzbyBiZSBudW1iZXJzLlwiXG4gIH0sXG4gIFwic2hvd1JvbGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiLCBcIlJvbGxpbmcgQXZlcmFnZXNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0aGUgcm9sbGluZyBhdmVyYWdlIHBlcmlvZCB0ZXh0IGJveCBzaG91bGQgYmUgc2hvd24uXCJcbiAgfSxcbiAgXCJzaWdtYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMi4wXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGVuIGVycm9yQmFycyBpcyBzZXQsIHNoYWRlIHRoaXMgbWFueSBzdGFuZGFyZCBkZXZpYXRpb25zIGFib3ZlL2JlbG93IGVhY2ggcG9pbnQuXCJcbiAgfSxcbiAgXCJjdXN0b21CYXJzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNTViBwYXJzaW5nXCIsIFwiRXJyb3IgQmFyc1wiXSxcbiAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIldoZW4gc2V0LCBwYXJzZSBlYWNoIENTViBjZWxsIGFzIFxcXCJsb3c7bWlkZGxlO2hpZ2hcXFwiLiBFcnJvciBiYXJzIHdpbGwgYmUgZHJhd24gZm9yIGVhY2ggcG9pbnQgYmV0d2VlbiBsb3cgYW5kIGhpZ2gsIHdpdGggdGhlIHNlcmllcyBpdHNlbGYgZ29pbmcgdGhyb3VnaCBtaWRkbGUuXCJcbiAgfSxcbiAgXCJjb2xvclZhbHVlXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxLjBcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhIFNlcmllcyBDb2xvcnNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgY29sb3JzIGlzIG5vdCBzcGVjaWZpZWQsIHZhbHVlIG9mIHRoZSBkYXRhIHNlcmllcyBjb2xvcnMsIGFzIGluIGh1ZS9zYXR1cmF0aW9uL3ZhbHVlLiAoMC4wLTEuMCwgZGVmYXVsdCAwLjUpXCJcbiAgfSxcbiAgXCJlcnJvckJhcnNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ1NWIHBhcnNpbmdcIiwgXCJFcnJvciBCYXJzXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiRG9lcyB0aGUgZGF0YSBjb250YWluIHN0YW5kYXJkIGRldmlhdGlvbnM/IFNldHRpbmcgdGhpcyB0byB0cnVlIGFsdGVycyB0aGUgaW5wdXQgZm9ybWF0IChzZWUgYWJvdmUpLlwiXG4gIH0sXG4gIFwiZGlzcGxheUFubm90YXRpb25zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJmYWxzZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkFubm90YXRpb25zXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiT25seSBhcHBsaWVzIHdoZW4gRHlncmFwaHMgaXMgdXNlZCBhcyBhIEdWaXogY2hhcnQuIENhdXNlcyBzdHJpbmcgY29sdW1ucyBmb2xsb3dpbmcgYSBkYXRhIHNlcmllcyB0byBiZSBpbnRlcnByZXRlZCBhcyBhbm5vdGF0aW9ucyBvbiBwb2ludHMgaW4gdGhhdCBzZXJpZXMuIFRoaXMgaXMgdGhlIHNhbWUgZm9ybWF0IHVzZWQgYnkgR29vZ2xlJ3MgQW5ub3RhdGVkVGltZUxpbmUgY2hhcnQuXCJcbiAgfSxcbiAgXCJwYW5FZGdlRnJhY3Rpb25cIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJJbnRlcmFjdGl2ZSBFbGVtZW50c1wiXSxcbiAgICBcInR5cGVcIjogXCJmbG9hdFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgZmFydGhlc3QgYSBncmFwaCBtYXkgYmUgcGFubmVkLCBpbiBwZXJjZW50IG9mIHRoZSBkaXNwbGF5LiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAwLjEgbWVhbnMgdGhhdCB0aGUgZ3JhcGggY2FuIG9ubHkgYmUgcGFubmVkIDEwJSBwYXNlZCB0aGUgZWRnZXMgb2YgdGhlIGRpc3BsYXllZCB2YWx1ZXMuIG51bGwgbWVhbnMgbm8gYm91bmRzLlwiXG4gIH0sXG4gIFwidGl0bGVcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSBhYm92ZSB0aGUgY2hhcnQuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXRpdGxlJyBjbGFzc2VzLlwiXG4gIH0sXG4gIFwidGl0bGVIZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjE4XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGVpZ2h0IG9mIHRoZSBjaGFydCB0aXRsZSwgaW4gcGl4ZWxzLiBUaGlzIGFsc28gY29udHJvbHMgdGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSB0aXRsZS4gSWYgeW91IHN0eWxlIHRoZSB0aXRsZSBvbiB5b3VyIG93biwgdGhpcyBjb250cm9scyBob3cgbXVjaCBzcGFjZSBpcyBzZXQgYXNpZGUgYWJvdmUgdGhlIGNoYXJ0IGZvciB0aGUgdGl0bGUncyBkaXYuXCJcbiAgfSxcbiAgXCJ4bGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSBiZWxvdyB0aGUgY2hhcnQncyB4LWF4aXMuIFlvdSBjYW4gc3VwcGx5IGFueSBIVE1MIGZvciB0aGlzIHZhbHVlLCBub3QganVzdCB0ZXh0LiBJZiB5b3Ugd2lzaCB0byBzdHlsZSBpdCB1c2luZyBDU1MsIHVzZSB0aGUgJ2R5Z3JhcGgtbGFiZWwnIG9yICdkeWdyYXBoLXhsYWJlbCcgY2xhc3Nlcy5cIlxuICB9LFxuICBcInhMYWJlbEhlaWdodFwiOiB7XG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlZmF1bHRcIjogXCIxOFwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQgb2YgdGhlIHgtYXhpcyBsYWJlbCwgaW4gcGl4ZWxzLiBUaGlzIGFsc28gY29udHJvbHMgdGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSB4LWF4aXMgbGFiZWwuIElmIHlvdSBzdHlsZSB0aGUgbGFiZWwgb24geW91ciBvd24sIHRoaXMgY29udHJvbHMgaG93IG11Y2ggc3BhY2UgaXMgc2V0IGFzaWRlIGJlbG93IHRoZSBjaGFydCBmb3IgdGhlIHgtYXhpcyBsYWJlbCdzIGRpdi5cIlxuICB9LFxuICBcInlsYWJlbFwiOiB7XG4gICAgXCJsYWJlbHNcIjogW1wiQ2hhcnQgbGFiZWxzXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGV4dCB0byBkaXNwbGF5IHRvIHRoZSBsZWZ0IG9mIHRoZSBjaGFydCdzIHktYXhpcy4gWW91IGNhbiBzdXBwbHkgYW55IEhUTUwgZm9yIHRoaXMgdmFsdWUsIG5vdCBqdXN0IHRleHQuIElmIHlvdSB3aXNoIHRvIHN0eWxlIGl0IHVzaW5nIENTUywgdXNlIHRoZSAnZHlncmFwaC1sYWJlbCcgb3IgJ2R5Z3JhcGgteWxhYmVsJyBjbGFzc2VzLiBUaGUgdGV4dCB3aWxsIGJlIHJvdGF0ZWQgOTAgZGVncmVlcyBieSBkZWZhdWx0LCBzbyBDU1MgcnVsZXMgbWF5IGJlaGF2ZSBpbiB1bmludHVpdGl2ZSB3YXlzLiBObyBhZGRpdGlvbmFsIHNwYWNlIGlzIHNldCBhc2lkZSBmb3IgYSB5LWF4aXMgbGFiZWwuIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UsIGluY3JlYXNlIHRoZSB3aWR0aCBvZiB0aGUgeS1heGlzIHRpY2sgbGFiZWxzIHVzaW5nIHRoZSB5QXhpc0xhYmVsV2lkdGggb3B0aW9uLiBJZiB5b3UgbmVlZCBhIHdpZGVyIGRpdiBmb3IgdGhlIHktYXhpcyBsYWJlbCwgZWl0aGVyIHN0eWxlIGl0IHRoYXQgd2F5IHdpdGggQ1NTIChidXQgcmVtZW1iZXIgdGhhdCBpdCdzIHJvdGF0ZWQsIHNvIHdpZHRoIGlzIGNvbnRyb2xsZWQgYnkgdGhlICdoZWlnaHQnIHByb3BlcnR5KSBvciBzZXQgdGhlIHlMYWJlbFdpZHRoIG9wdGlvbi5cIlxuICB9LFxuICBcInkybGFiZWxcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRleHQgdG8gZGlzcGxheSB0byB0aGUgcmlnaHQgb2YgdGhlIGNoYXJ0J3Mgc2Vjb25kYXJ5IHktYXhpcy4gVGhpcyBsYWJlbCBpcyBvbmx5IGRpc3BsYXllZCBpZiBhIHNlY29uZGFyeSB5LWF4aXMgaXMgcHJlc2VudC4gU2VlIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vdGVzdHMvdHdvLWF4ZXMuaHRtbCc+dGhpcyB0ZXN0PC9hPiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZG8gdGhpcy4gVGhlIGNvbW1lbnRzIGZvciB0aGUgJ3lsYWJlbCcgb3B0aW9uIGdlbmVyYWxseSBhcHBseSBoZXJlIGFzIHdlbGwuIFRoaXMgbGFiZWwgZ2V0cyBhICdkeWdyYXBoLXkybGFiZWwnIGluc3RlYWQgb2YgYSAnZHlncmFwaC15bGFiZWwnIGNsYXNzLlwiXG4gIH0sXG4gIFwieUxhYmVsV2lkdGhcIjoge1xuICAgIFwibGFiZWxzXCI6IFtcIkNoYXJ0IGxhYmVsc1wiXSxcbiAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiMThcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2lkdGggb2YgdGhlIGRpdiB3aGljaCBjb250YWlucyB0aGUgeS1heGlzIGxhYmVsLiBTaW5jZSB0aGUgeS1heGlzIGxhYmVsIGFwcGVhcnMgcm90YXRlZCA5MCBkZWdyZWVzLCB0aGlzIGFjdHVhbGx5IGFmZmVjdHMgdGhlIGhlaWdodCBvZiBpdHMgZGl2LlwiXG4gIH0sXG4gIFwiaXNab29tZWRJZ25vcmVQcm9ncmFtbWF0aWNab29tXCIgOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiZmFsc2VcIixcbiAgICBcImxhYmVsc1wiOiBbXCJab29taW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIldoZW4gdGhpcyBvcHRpb24gaXMgcGFzc2VkIHRvIHVwZGF0ZU9wdGlvbnMoKSBhbG9uZyB3aXRoIGVpdGhlciB0aGUgPGNvZGU+ZGF0ZVdpbmRvdzwvY29kZT4gb3IgPGNvZGU+dmFsdWVSYW5nZTwvY29kZT4gb3B0aW9ucywgdGhlIHpvb20gZmxhZ3MgYXJlIG5vdCBjaGFuZ2VkIHRvIHJlZmxlY3QgYSB6b29tZWQgc3RhdGUuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3Igd2hlbiB0aGUgZGlzcGxheSBhcmVhIG9mIGEgY2hhcnQgaXMgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBhbHNvIHdoZXJlIG1hbnVhbCB6b29taW5nIGlzIGFsbG93ZWQgYW5kIHVzZSBpcyBtYWRlIG9mIHRoZSA8Y29kZT5pc1pvb21lZDwvY29kZT4gbWV0aG9kIHRvIGRldGVybWluZSB0aGlzLlwiXG4gIH0sXG4gIFwiZHJhd0dyaWRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWUgZm9yIHggYW5kIHksIGZhbHNlIGZvciB5MlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2hldGhlciB0byBkaXNwbGF5IGdyaWRsaW5lcyBpbiB0aGUgY2hhcnQuIFRoaXMgbWF5IGJlIHNldCBvbiBhIHBlci1heGlzIGJhc2lzIHRvIGRlZmluZSB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoIGF4aXMnIGdyaWQgc2VwYXJhdGVseS5cIlxuICB9LFxuICBcImluZGVwZW5kZW50VGlja3NcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcInRydWUgZm9yIHksIGZhbHNlIGZvciB5MlwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkF4aXMgZGlzcGxheVwiLCBcIkdyaWRcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiT25seSB2YWxpZCBmb3IgeSBhbmQgeTIsIGhhcyBubyBlZmZlY3Qgb24geDogVGhpcyBvcHRpb24gZGVmaW5lcyB3aGV0aGVyIHRoZSB5IGF4ZXMgc2hvdWxkIGFsaWduIHRoZWlyIHRpY2tzIG9yIGlmIHRoZXkgc2hvdWxkIGJlIGluZGVwZW5kZW50LiBQb3NzaWJsZSBjb21iaW5hdGlvbnM6IDEuKSB5PXRydWUsIHkyPWZhbHNlIChkZWZhdWx0KTogeSBpcyB0aGUgcHJpbWFyeSBheGlzIGFuZCB0aGUgeTIgdGlja3MgYXJlIGFsaWduZWQgdG8gdGhlIHRoZSBvbmVzIG9mIHkuIChvbmx5IDEgZ3JpZCkgMi4pIHk9ZmFsc2UsIHkyPXRydWU6IHkyIGlzIHRoZSBwcmltYXJ5IGF4aXMgYW5kIHRoZSB5IHRpY2tzIGFyZSBhbGlnbmVkIHRvIHRoZSB0aGUgb25lcyBvZiB5Mi4gKG9ubHkgMSBncmlkKSAzLikgeT10cnVlLCB5Mj10cnVlOiBCb3RoIGF4aXMgYXJlIGluZGVwZW5kZW50IGFuZCBoYXZlIHRoZWlyIG93biB0aWNrcy4gKDIgZ3JpZHMpIDQuKSB5PWZhbHNlLCB5Mj1mYWxzZTogSW52YWxpZCBjb25maWd1cmF0aW9uIGNhdXNlcyBhbiBlcnJvci5cIlxuICB9LFxuICBcImRyYXdBeGlzXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ0cnVlIGZvciB4IGFuZCB5LCBmYWxzZSBmb3IgeTJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2hldGhlciB0byBkcmF3IHRoZSBzcGVjaWZpZWQgYXhpcy4gVGhpcyBtYXkgYmUgc2V0IG9uIGEgcGVyLWF4aXMgYmFzaXMgdG8gZGVmaW5lIHRoZSB2aXNpYmlsaXR5IG9mIGVhY2ggYXhpcyBzZXBhcmF0ZWx5LiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgYWxzbyBwcmV2ZW50cyBheGlzIHRpY2tzIGZyb20gYmVpbmcgZHJhd24gYW5kIHJlY2xhaW1zIHRoZSBzcGFjZSBmb3IgdGhlIGNoYXJ0IGdyaWQvbGluZXMuXCJcbiAgfSxcbiAgXCJncmlkTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjNcIixcbiAgICBcImxhYmVsc1wiOiBbXCJHcmlkXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJUaGlja25lc3MgKGluIHBpeGVscykgb2YgdGhlIGdyaWRsaW5lcyBkcmF3biB1bmRlciB0aGUgY2hhcnQuIFRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsIGdyaWRsaW5lcyBjYW4gYmUgdHVybmVkIG9mZiBlbnRpcmVseSBieSB1c2luZyB0aGUgZHJhd0dyaWQgb3B0aW9uLiBUaGlzIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcyB0byBkZWZpbmUgZWFjaCBheGlzJyBncmlkIHNlcGFyYXRlbHkuXCJcbiAgfSxcbiAgXCJheGlzTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIwLjNcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCIgOiBcIlRoaWNrbmVzcyAoaW4gcGl4ZWxzKSBvZiB0aGUgeC0gYW5kIHktYXhpcyBsaW5lcy5cIlxuICB9LFxuICBcImF4aXNMaW5lQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImJsYWNrXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiQ29sb3Igb2YgdGhlIHgtIGFuZCB5LWF4aXMgbGluZXMuIEFjY2VwdHMgYW55IHZhbHVlIHdoaWNoIHRoZSBIVE1MIGNhbnZhcyBzdHJva2VTdHlsZSBhdHRyaWJ1dGUgdW5kZXJzdGFuZHMsIGUuZy4gJ2JsYWNrJyBvciAncmdiKDAsIDEwMCwgMjU1KScuXCJcbiAgfSxcbiAgXCJmaWxsQWxwaGFcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjAuMTVcIixcbiAgICBcImxhYmVsc1wiOiBbXCJFcnJvciBCYXJzXCIsIFwiRGF0YSBTZXJpZXMgQ29sb3JzXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0ICgwLjAgLSAxLjApXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiIDogXCJFcnJvciBiYXJzIChvciBjdXN0b20gYmFycykgZm9yIGVhY2ggc2VyaWVzIGFyZSBkcmF3biBpbiB0aGUgc2FtZSBjb2xvciBhcyB0aGUgc2VyaWVzLCBidXQgd2l0aCBwYXJ0aWFsIHRyYW5zcGFyZW5jeS4gVGhpcyBzZXRzIHRoZSB0cmFuc3BhcmVuY3kuIEEgdmFsdWUgb2YgMC4wIG1lYW5zIHRoYXQgdGhlIGVycm9yIGJhcnMgd2lsbCBub3QgYmUgZHJhd24sIHdoZXJlYXMgYSB2YWx1ZSBvZiAxLjAgbWVhbnMgdGhhdCB0aGUgZXJyb3IgYmFycyB3aWxsIGJlIGFzIGRhcmsgYXMgdGhlIGxpbmUgZm9yIHRoZSBzZXJpZXMgaXRzZWxmLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHByb2R1Y2UgY2hhcnQgbGluZXMgd2hvc2UgdGhpY2tuZXNzIHZhcmllcyBhdCBlYWNoIHBvaW50LlwiXG4gIH0sXG4gIFwiYXhpc0xhYmVsQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImJsYWNrXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiQXhpcyBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiQ29sb3IgZm9yIHgtIGFuZCB5LWF4aXMgbGFiZWxzLiBUaGlzIGlzIGEgQ1NTIGNvbG9yIHN0cmluZy5cIlxuICB9LFxuICBcImF4aXNMYWJlbFdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCI1MCAoeS1heGlzKSwgNjAgKHgtYXhpcylcIixcbiAgICBcImxhYmVsc1wiOiBbXCJBeGlzIGRpc3BsYXlcIiwgXCJDaGFydCBsYWJlbHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIiA6IFwiV2lkdGggKGluIHBpeGVscykgb2YgdGhlIGNvbnRhaW5pbmcgZGl2cyBmb3IgeC0gYW5kIHktYXhpcyBsYWJlbHMuIEZvciB0aGUgeS1heGlzLCB0aGlzIGFsc28gY29udHJvbHMgdGhlIHdpZHRoIG9mIHRoZSB5LWF4aXMuIE5vdGUgdGhhdCBmb3IgdGhlIHgtYXhpcywgdGhpcyBpcyBpbmRlcGVuZGVudCBmcm9tIHBpeGVsc1BlckxhYmVsLCB3aGljaCBjb250cm9scyB0aGUgc3BhY2luZyBiZXR3ZWVuIGxhYmVscy5cIlxuICB9LFxuICBcInNpZ0ZpZ3NcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQnkgZGVmYXVsdCwgZHlncmFwaHMgZGlzcGxheXMgbnVtYmVycyB3aXRoIGEgZml4ZWQgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gSWYgeW91J2QgcHJlZmVyIHRvIGhhdmUgYSBmaXhlZCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlcywgc2V0IHRoaXMgb3B0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHNpZyBmaWdzLiBBIHZhbHVlIG9mIDIsIGZvciBpbnN0YW5jZSwgd291bGQgY2F1c2UgMSB0byBiZSBkaXNwbGF5IGFzIDEuMCBhbmQgMTIzNCB0byBiZSBkaXNwbGF5ZWQgYXMgMS4yM2UrMy5cIlxuICB9LFxuICBcImRpZ2l0c0FmdGVyRGVjaW1hbFwiIDoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJWYWx1ZSBkaXNwbGF5L2Zvcm1hdHRpbmdcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJVbmxlc3MgaXQncyBydW4gaW4gc2NpZW50aWZpYyBtb2RlIChzZWUgdGhlIDxjb2RlPnNpZ0ZpZ3M8L2NvZGU+IG9wdGlvbiksIGR5Z3JhcGhzIGRpc3BsYXlzIG51bWJlcnMgd2l0aCA8Y29kZT5kaWdpdHNBZnRlckRlY2ltYWw8L2NvZGU+IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gVHJhaWxpbmcgemVyb3MgYXJlIG5vdCBkaXNwbGF5ZWQsIHNvIHdpdGggYSB2YWx1ZSBvZiAyIHlvdSdsbCBnZXQgJzAnLCAnMC4xJywgJzAuMTInLCAnMTIzLjQ1JyBidXQgbm90ICcxMjMuNDU2JyAoaXQgd2lsbCBiZSByb3VuZGVkIHRvICcxMjMuNDYnKS4gTnVtYmVycyB3aXRoIGFic29sdXRlIHZhbHVlIGxlc3MgdGhhbiAwLjFeZGlnaXRzQWZ0ZXJEZWNpbWFsIChpLmUuIHRob3NlIHdoaWNoIHdvdWxkIHNob3cgdXAgYXMgJzAuMDAnKSB3aWxsIGJlIGRpc3BsYXllZCBpbiBzY2llbnRpZmljIG5vdGF0aW9uLlwiXG4gIH0sXG4gIFwibWF4TnVtYmVyV2lkdGhcIiA6IHtcbiAgICBcImRlZmF1bHRcIjogXCI2XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiVmFsdWUgZGlzcGxheS9mb3JtYXR0aW5nXCJdLFxuICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2hlbiBkaXNwbGF5aW5nIG51bWJlcnMgaW4gbm9ybWFsIChub3Qgc2NpZW50aWZpYykgbW9kZSwgbGFyZ2UgbnVtYmVycyB3aWxsIGJlIGRpc3BsYXllZCB3aXRoIG1hbnkgdHJhaWxpbmcgemVyb3MgKGUuZy4gMTAwMDAwMDAwIGluc3RlYWQgb2YgMWU5KS4gVGhpcyBjYW4gbGVhZCB0byB1bndpZWxkeSB5LWF4aXMgbGFiZWxzLiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDxjb2RlPm1heE51bWJlcldpZHRoPC9jb2RlPiBkaWdpdHMgdG8gdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgaW4gYSBudW1iZXIsIGR5Z3JhcGhzIHdpbGwgc3dpdGNoIHRvIHNjaWVudGlmaWMgbm90YXRpb24sIGV2ZW4gd2hlbiBub3Qgb3BlcmF0aW5nIGluIHNjaWVudGlmaWMgbW9kZS4gSWYgeW91J2QgbGlrZSB0byBzZWUgYWxsIHRob3NlIGRpZ2l0cywgc2V0IHRoaXMgdG8gc29tZXRoaW5nIGxhcmdlLCBsaWtlIDIwIG9yIDMwLlwiXG4gIH0sXG4gIFwiZmlsZVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKHNldCB3aGVuIGNvbnN0cnVjdGVkKVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGFcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nIChVUkwgb2YgQ1NWIG9yIENTViksIEdWaXogRGF0YVRhYmxlIG9yIDJEIEFycmF5XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldHMgdGhlIGRhdGEgYmVpbmcgZGlzcGxheWVkIGluIHRoZSBjaGFydC4gVGhpcyBjYW4gb25seSBiZSBzZXQgd2hlbiBjYWxsaW5nIHVwZGF0ZU9wdGlvbnM7IGl0IGNhbm5vdCBiZSBzZXQgZnJvbSB0aGUgY29uc3RydWN0b3IuIEZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdmFsaWQgZGF0YSBmb3JtYXRzLCBzZWUgdGhlIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vZGF0YS5odG1sJz5EYXRhIEZvcm1hdHM8L2E+IHBhZ2UuXCJcbiAgfSxcbiAgXCJ0aW1pbmdOYW1lXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogWyBcIkRlYnVnZ2luZ1wiIF0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldCB0aGlzIG9wdGlvbiB0byBsb2cgdGltaW5nIGluZm9ybWF0aW9uLiBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiB3aWxsIGJlIGxvZ2dlZCBhbG9uZyB3aXRoIHRoZSB0aW1pbWcsIHNvIHRoYXQgeW91IGNhbiBkaXN0aW5ndWlzaCBtdWx0aXBsZSBkeWdyYXBocyBvbiB0aGUgc2FtZSBwYWdlLlwiXG4gIH0sXG4gIFwic2hvd1JhbmdlU2VsZWN0b3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTaG93IG9yIGhpZGUgdGhlIHJhbmdlIHNlbGVjdG9yIHdpZGdldC5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JIZWlnaHRcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjQwXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJIZWlnaHQsIGluIHBpeGVscywgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIHdpZGdldC4gVGhpcyBvcHRpb24gY2FuIG9ubHkgYmUgc3BlY2lmaWVkIGF0IER5Z3JhcGggY3JlYXRpb24gdGltZS5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JQbG90U3Ryb2tlQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIiM4MDhGQUJcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBzdHJva2UgY29sb3IuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IG51bGwgb3IgXFxcIlxcXCIgdG8gdHVybiBvZmYgc3Ryb2tlLlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3JcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIiNBN0IxQzRcIixcbiAgICBcImxhYmVsc1wiOiBbXCJSYW5nZSBTZWxlY3RvclwiXSxcbiAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdCBmaWxsIGNvbG9yLiBUaGlzIGNhbiBiZSBvZiB0aGUgZm9ybSBcXFwiI0FBQkJDQ1xcXCIgb3IgXFxcInJnYigyNTUsMTAwLDIwMClcXFwiIG9yIFxcXCJ5ZWxsb3dcXFwiLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBudWxsIG9yIFxcXCJcXFwiIHRvIHR1cm4gb2ZmIGZpbGwuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJ3aGl0ZVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgdG9wIGNvbG9yIGZvciB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90IGZpbGwgY29sb3IgZ3JhZGllbnQuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInJnYmEoMjU1LDEwMCwyMDAsNDIpXFxcIiBvciBcXFwieWVsbG93XFxcIi4gWW91IGNhbiBhbHNvIHNwZWNpZnkgbnVsbCBvciBcXFwiXFxcIiB0byBkaXNhYmxlIHRoZSBncmFkaWVudCBhbmQgZmlsbCB3aXRoIG9uZSBzaW5nbGUgY29sb3IuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJncmF5XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjb2xvciBvZiB0aGUgbGluZXMgYmVsb3cgYW5kIG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC4gVGhpcyBjYW4gYmUgb2YgdGhlIGZvcm0gXFxcIiNBQUJCQ0NcXFwiIG9yIFxcXCJyZ2IoMjU1LDEwMCwyMDApXFxcIiBvciBcXFwieWVsbG93XFxcIi5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCIxXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBiZWxvdyBhbmQgb24gYm90aCBzaWRlcyBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90LlwiXG4gIH0sXG4gIFwicmFuZ2VTZWxlY3RvclBsb3RMaW5lV2lkdGhcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIjEuNVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgbWluaSBwbG90IGxpbmUuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJibGFja1wiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29sb3Igb2YgdGhlIGxpbmVzIGluIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IuIFRoaXMgY2FuIGJlIG9mIHRoZSBmb3JtIFxcXCIjQUFCQkNDXFxcIiBvciBcXFwicmdiKDI1NSwxMDAsMjAwKVxcXCIgb3IgXFxcInllbGxvd1xcXCIuXCJcbiAgfSxcbiAgXCJyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZExpbmVXaWR0aFwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIlJhbmdlIFNlbGVjdG9yXCJdLFxuICAgIFwidHlwZVwiOiBcImZsb2F0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3aWR0aCB0aGUgbGluZXMgaW4gdGhlIGludGVyYWN0aXZlIGxheWVyIG9mIHRoZSByYW5nZSBzZWxlY3Rvci5cIlxuICB9LFxuICBcInJhbmdlU2VsZWN0b3JBbHBoYVwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiMC42XCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiZmxvYXQgKDAuMCAtIDEuMClcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRyYW5zcGFyZW5jeSBvZiB0aGUgdmVpbCB0aGF0IGlzIGRyYXduIG92ZXIgdGhlIHVuc2VsZWN0ZWQgcG9ydGlvbnMgb2YgdGhlIHJhbmdlIHNlbGVjdG9yIG1pbmkgcGxvdC4gQSB2YWx1ZSBvZiAwIHJlcHJlc2VudHMgZnVsbCB0cmFuc3BhcmVuY3kgYW5kIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSBtaW5pIHBsb3Qgd2lsbCBhcHBlYXIgYXMgbm9ybWFsLiBBIHZhbHVlIG9mIDEgcmVwcmVzZW50cyBmdWxsIG9wYWNpdHkgYW5kIHRoZSB1bnNlbGVjdGVkIHBvcnRpb25zIG9mIHRoZSBtaW5pIHBsb3Qgd2lsbCBiZSBoaWRkZW4uXCJcbiAgfSxcbiAgXCJzaG93SW5SYW5nZVNlbGVjdG9yXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJudWxsXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiUmFuZ2UgU2VsZWN0b3JcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJNYXJrIHRoaXMgc2VyaWVzIGZvciBpbmNsdXNpb24gaW4gdGhlIHJhbmdlIHNlbGVjdG9yLiBUaGUgbWluaSBwbG90IGN1cnZlIHdpbGwgYmUgYW4gYXZlcmFnZSBvZiBhbGwgc3VjaCBzZXJpZXMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBmb3IgYW55IHNlcmllcywgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gYXZlcmFnZSBhbGwgdGhlIHNlcmllcy4gU2V0dGluZyBpdCBmb3Igb25lIHNlcmllcyB3aWxsIHJlc3VsdCBpbiB0aGF0IHNlcmllcyBiZWluZyBjaGFydGVkIGFsb25lIGluIHRoZSByYW5nZSBzZWxlY3Rvci5cIlxuICB9LFxuICBcImFuaW1hdGVkWm9vbXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcImZhbHNlXCIsXG4gICAgXCJsYWJlbHNcIjogW1wiSW50ZXJhY3RpdmUgRWxlbWVudHNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJTZXQgdGhpcyBvcHRpb24gdG8gYW5pbWF0ZSB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIHpvb20gd2luZG93cy4gQXBwbGllcyB0byBwcm9ncmFtbWF0aWMgYW5kIGludGVyYWN0aXZlIHpvb21zLiBOb3RlIHRoYXQgaWYgeW91IGFsc28gc2V0IGEgZHJhd0NhbGxiYWNrLCBpdCB3aWxsIGJlIGNhbGxlZCBzZXZlcmFsIHRpbWVzIG9uIGVhY2ggem9vbS4gSWYgeW91IHNldCBhIHpvb21DYWxsYmFjaywgaXQgd2lsbCBvbmx5IGJlIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlwiXG4gIH0sXG4gIFwicGxvdHRlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiW0R5Z3JhcGhDYW52YXNSZW5kZXJlci5QbG90dGVycy5maWxsUGxvdHRlciwgRHlncmFwaENhbnZhc1JlbmRlcmVyLlBsb3R0ZXJzLmVycm9yUGxvdHRlciwgRHlncmFwaENhbnZhc1JlbmRlcmVyLlBsb3R0ZXJzLmxpbmVQbG90dGVyXVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkRhdGEgTGluZSBkaXNwbGF5XCJdLFxuICAgIFwidHlwZVwiOiBcImFycmF5IG9yIGZ1bmN0aW9uXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgZnVuY3Rpb24gKG9yIGFycmF5IG9mIGZ1bmN0aW9ucykgd2hpY2ggcGxvdCBlYWNoIGRhdGEgc2VyaWVzIG9uIHRoZSBjaGFydC4gVE9ETyhkYW52ayk6IG1vcmUgZGV0YWlscyEgTWF5IGJlIHNldCBwZXItc2VyaWVzLlwiXG4gIH0sXG4gIFwiYXhlc1wiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwibnVsbFwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNvbmZpZ3VyYXRpb25cIl0sXG4gICAgXCJ0eXBlXCI6IFwiT2JqZWN0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlZmluZXMgcGVyLWF4aXMgb3B0aW9ucy4gVmFsaWQga2V5cyBhcmUgJ3gnLCAneScgYW5kICd5MicuIE9ubHkgc29tZSBvcHRpb25zIG1heSBiZSBzZXQgb24gYSBwZXItYXhpcyBiYXNpcy4gSWYgYW4gb3B0aW9uIG1heSBiZSBzZXQgaW4gdGhpcyB3YXksIGl0IHdpbGwgYmUgbm90ZWQgb24gdGhpcyBwYWdlLiBTZWUgYWxzbyBkb2N1bWVudGF0aW9uIG9uIDxhIGhyZWY9J2h0dHA6Ly9keWdyYXBocy5jb20vcGVyLWF4aXMuaHRtbCc+cGVyLXNlcmllcyBhbmQgcGVyLWF4aXMgb3B0aW9uczwvYT4uXCJcbiAgfSxcbiAgXCJzZXJpZXNcIjoge1xuICAgIFwiZGVmYXVsdFwiOiBcIm51bGxcIixcbiAgICBcImxhYmVsc1wiOiBbXCJTZXJpZXNcIl0sXG4gICAgXCJ0eXBlXCI6IFwiT2JqZWN0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlZmluZXMgcGVyLXNlcmllcyBvcHRpb25zLiBJdHMga2V5cyBtYXRjaCB0aGUgeS1heGlzIGxhYmVsIG5hbWVzLCBhbmQgdGhlIHZhbHVlcyBhcmUgZGljdGlvbmFyaWVzIHRoZW1zZWx2ZXMgdGhhdCBjb250YWluIG9wdGlvbnMgc3BlY2lmaWMgdG8gdGhhdCBzZXJpZXMuXCJcbiAgfSxcbiAgXCJwbHVnaW5zXCI6IHtcbiAgICBcImRlZmF1bHRcIjogXCJbXVwiLFxuICAgIFwibGFiZWxzXCI6IFtcIkNvbmZpZ3VyYXRpb25cIl0sXG4gICAgXCJ0eXBlXCI6IFwiQXJyYXk8cGx1Z2luPlwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZWZpbmVzIHBlci1ncmFwaCBwbHVnaW5zLiBVc2VmdWwgZm9yIHBlci1ncmFwaCBjdXN0b21pemF0aW9uXCJcbiAgfSxcbiAgXCJkYXRhSGFuZGxlclwiOiB7XG4gICAgXCJkZWZhdWx0XCI6IFwiKGRlcGVuZHMgb24gZGF0YSlcIixcbiAgICBcImxhYmVsc1wiOiBbXCJEYXRhXCJdLFxuICAgIFwidHlwZVwiOiBcIkR5Z3JhcGguRGF0YUhhbmRsZXJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQ3VzdG9tIERhdGFIYW5kbGVyLiBUaGlzIGlzIGFuIGFkdmFuY2VkIGN1c3RvbWl6YXRpb24uIFNlZSBodHRwOi8vYml0Lmx5LzE1MUU3QXEuXCJcbiAgfVxufVxuOyAgLy8gPC9KU09OPlxuLy8gTk9URTogaW4gYWRkaXRpb24gdG8gcGFyc2luZyBhcyBKUywgdGhpcyBzbmlwcGV0IGlzIGV4cGVjdGVkIHRvIGJlIHZhbGlkXG4vLyBKU09OLiBUaGlzIGFzc3VtcHRpb24gY2Fubm90IGJlIGNoZWNrZWQgaW4gSlMsIGJ1dCBpdCB3aWxsIGJlIGNoZWNrZWQgd2hlblxuLy8gZG9jdW1lbnRhdGlvbiBpcyBnZW5lcmF0ZWQgYnkgdGhlIGdlbmVyYXRlLWRvY3VtZW50YXRpb24ucHkgc2NyaXB0LiBGb3IgdGhlXG4vLyBtb3N0IHBhcnQsIHRoaXMganVzdCBtZWFucyB0aGF0IHlvdSBzaG91bGQgYWx3YXlzIHVzZSBkb3VibGUgcXVvdGVzLlxuXG4vLyBEbyBhIHF1aWNrIHNhbml0eSBjaGVjayBvbiB0aGUgb3B0aW9ucyByZWZlcmVuY2UuXG52YXIgd2FybiA9IGZ1bmN0aW9uKG1zZykgeyBpZiAod2luZG93LmNvbnNvbGUpIHdpbmRvdy5jb25zb2xlLndhcm4obXNnKTsgfTtcbnZhciBmbGRzID0gWyd0eXBlJywgJ2RlZmF1bHQnLCAnZGVzY3JpcHRpb24nXTtcbnZhciB2YWxpZF9jYXRzID0gW1xuICdBbm5vdGF0aW9ucycsXG4gJ0F4aXMgZGlzcGxheScsXG4gJ0NoYXJ0IGxhYmVscycsXG4gJ0NTViBwYXJzaW5nJyxcbiAnQ2FsbGJhY2tzJyxcbiAnRGF0YScsXG4gJ0RhdGEgTGluZSBkaXNwbGF5JyxcbiAnRGF0YSBTZXJpZXMgQ29sb3JzJyxcbiAnRXJyb3IgQmFycycsXG4gJ0dyaWQnLFxuICdJbnRlcmFjdGl2ZSBFbGVtZW50cycsXG4gJ1JhbmdlIFNlbGVjdG9yJyxcbiAnTGVnZW5kJyxcbiAnT3ZlcmFsbCBkaXNwbGF5JyxcbiAnUm9sbGluZyBBdmVyYWdlcycsXG4gJ1NlcmllcycsXG4gJ1ZhbHVlIGRpc3BsYXkvZm9ybWF0dGluZycsXG4gJ1pvb21pbmcnLFxuICdEZWJ1Z2dpbmcnLFxuICdDb25maWd1cmF0aW9uJyxcbiAnRGVwcmVjYXRlZCdcbl07XG52YXIgaTtcbnZhciBjYXRzID0ge307XG5mb3IgKGkgPSAwOyBpIDwgdmFsaWRfY2F0cy5sZW5ndGg7IGkrKykgY2F0c1t2YWxpZF9jYXRzW2ldXSA9IHRydWU7XG5cbmZvciAodmFyIGsgaW4gT1BUSU9OU19SRUZFUkVOQ0UpIHtcbiAgaWYgKCFPUFRJT05TX1JFRkVSRU5DRS5oYXNPd25Qcm9wZXJ0eShrKSkgY29udGludWU7XG4gIHZhciBvcCA9IE9QVElPTlNfUkVGRVJFTkNFW2tdO1xuICBmb3IgKGkgPSAwOyBpIDwgZmxkcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoZmxkc1tpXSkpIHtcbiAgICAgIHdhcm4oJ09wdGlvbiAnICsgayArICcgbWlzc2luZyBcIicgKyBmbGRzW2ldICsgJ1wiIHByb3BlcnR5Jyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yob3BbZmxkc1tpXV0pICE9ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuKGsgKyAnLicgKyBmbGRzW2ldICsgJyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nJyk7XG4gICAgfVxuICB9XG4gIHZhciBsYWJlbHMgPSBvcC5sYWJlbHM7XG4gIGlmICh0eXBlb2YobGFiZWxzKSAhPT0gJ29iamVjdCcpIHtcbiAgICB3YXJuKCdPcHRpb24gXCInICsgayArICdcIiBpcyBtaXNzaW5nIGEgXCJsYWJlbHNcIjogWy4uLl0gb3B0aW9uJyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYXRzLmhhc093blByb3BlcnR5KGxhYmVsc1tpXSkpIHtcbiAgICAgICAgd2FybignT3B0aW9uIFwiJyArIGsgKyAnXCIgaGFzIGxhYmVsIFwiJyArIGxhYmVsc1tpXSArXG4gICAgICAgICAgICAgJ1wiLCB3aGljaCBpcyBpbnZhbGlkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE9QVElPTlNfUkVGRVJFTkNFO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTEgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRHlncmFwaE9wdGlvbnMgaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgYW5kIHJldHVybmluZ1xuICogaW5mb3JtYXRpb24gYWJvdXQgb3B0aW9ucy5cbiAqL1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBqc2hpbnQgZGlyZWN0aXZlICYgZml4IHRoZSB3YXJuaW5ncy5cbi8qanNoaW50IHN1Yjp0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcbmltcG9ydCBERUZBVUxUX0FUVFJTIGZyb20gJy4vZHlncmFwaC1kZWZhdWx0LWF0dHJzJztcbmltcG9ydCBPUFRJT05TX1JFRkVSRU5DRSBmcm9tICcuL2R5Z3JhcGgtb3B0aW9ucy1yZWZlcmVuY2UnO1xuXG4vKlxuICogSW50ZXJlc3RpbmcgbWVtYmVyIHZhcmlhYmxlczogKFJFTU9WSU5HIFRISVMgTElTVCBBUyBJIENMT1NVUklaRSlcbiAqIGdsb2JhbF8gLSBnbG9iYWwgYXR0cmlidXRlcyAoY29tbW9uIGFtb25nIGFsbCBncmFwaHMsIEFJVUkpXG4gKiB1c2VyIC0gYXR0cmlidXRlcyBzZXQgYnkgdGhlIHVzZXJcbiAqIHNlcmllc18gLSB7IHNlcmllc05hbWUgLT4geyBpZHgsIHlBeGlzLCBvcHRpb25zIH19XG4gKi9cblxuLyoqXG4gKiBUaGlzIHBhcnNlcyBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGVhc2lseSBxdWVyaWVkLlxuICpcbiAqIEl0IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IGFsbCBvcHRpb25zIGFyZSBhdmFpbGFibGUsIHNwZWNpZmljYWxseVxuICogaWYgbGFiZWxzIGFyZSBub3QgeWV0IGF2YWlsYWJsZSwgc2luY2UgdGhvc2UgZHJpdmUgZGV0YWlscyBvZiB0aGUgcGVyLXNlcmllc1xuICogYW5kIHBlci1heGlzIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtEeWdyYXBofSBkeWdyYXBoIFRoZSBjaGFydCB0byB3aGljaCB0aGVzZSBvcHRpb25zIGJlbG9uZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRHlncmFwaE9wdGlvbnMgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIC8qKlxuICAgKiBUaGUgZHlncmFwaC5cbiAgICogQHR5cGUgeyFEeWdyYXBofVxuICAgKi9cbiAgdGhpcy5keWdyYXBoXyA9IGR5Z3JhcGg7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGF4aXMgaW5kZXggdG8geyBzZXJpZXMgOiBbIHNlcmllcyBuYW1lcyBdICwgb3B0aW9ucyA6IHsgYXhpcy1zcGVjaWZpYyBvcHRpb25zLiB9XG4gICAqIEB0eXBlIHtBcnJheS48e3NlcmllcyA6IEFycmF5LjxzdHJpbmc+LCBvcHRpb25zIDogT2JqZWN0fT59IEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnlBeGVzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyB4LWF4aXMgc3BlY2lmaWMgb3B0aW9ucywgd2hpY2ggYXJlIHN0b3JlZCBpbiB0aGUgb3B0aW9ucyBrZXkuXG4gICAqIFRoaXMgbWF0Y2hlcyB0aGUgeUF4ZXNfIG9iamVjdCBzdHJ1Y3R1cmUgKGJ5IGJlaW5nIGEgZGljdGlvbmFyeSB3aXRoIGFuXG4gICAqIG9wdGlvbnMgZWxlbWVudCkgYWxsb3dpbmcgZm9yIHNoYXJlZCBjb2RlLlxuICAgKiBAdHlwZSB7b3B0aW9uczogT2JqZWN0fSBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy54QXhpc18gPSB7fTtcbiAgdGhpcy5zZXJpZXNfID0ge307XG5cbiAgLy8gT25jZSB0aGVzZSB0d28gb2JqZWN0cyBhcmUgaW5pdGlhbGl6ZWQsIHlvdSBjYW4gY2FsbCBnZXQoKTtcbiAgdGhpcy5nbG9iYWxfID0gdGhpcy5keWdyYXBoXy5hdHRyc187XG4gIHRoaXMudXNlcl8gPSB0aGlzLmR5Z3JhcGhfLnVzZXJfYXR0cnNfIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Ygc2VyaWVzIGluIGNvbHVtbmFyIG9yZGVyLlxuICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAqL1xuICB0aGlzLmxhYmVsc18gPSBbXTtcblxuICB0aGlzLmhpZ2hsaWdodFNlcmllc18gPSB0aGlzLmdldChcImhpZ2hsaWdodFNlcmllc09wdHNcIikgfHwge307XG4gIHRoaXMucmVwYXJzZVNlcmllcygpO1xufTtcblxuLyoqXG4gKiBOb3Qgb3B0aW1hbCwgYnV0IGRvZXMgdGhlIHRyaWNrIHdoZW4geW91J3JlIG9ubHkgdXNpbmcgdHdvIGF4ZXMuXG4gKiBJZiB3ZSBtb3ZlIHRvIG1vcmUgYXhlcywgdGhpcyBjYW4ganVzdCBiZWNvbWUgYSBmdW5jdGlvbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0LjxudW1iZXI+fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaE9wdGlvbnMuQVhJU19TVFJJTkdfTUFQUElOR1NfID0ge1xuICAneScgOiAwLFxuICAnWScgOiAwLFxuICAneTEnIDogMCxcbiAgJ1kxJyA6IDAsXG4gICd5MicgOiAxLFxuICAnWTInIDogMVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGF4aXNcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGhPcHRpb25zLmF4aXNUb0luZGV4XyA9IGZ1bmN0aW9uKGF4aXMpIHtcbiAgaWYgKHR5cGVvZihheGlzKSA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKER5Z3JhcGhPcHRpb25zLkFYSVNfU1RSSU5HX01BUFBJTkdTXy5oYXNPd25Qcm9wZXJ0eShheGlzKSkge1xuICAgICAgcmV0dXJuIER5Z3JhcGhPcHRpb25zLkFYSVNfU1RSSU5HX01BUFBJTkdTX1theGlzXTtcbiAgICB9XG4gICAgdGhyb3cgXCJVbmtub3duIGF4aXMgOiBcIiArIGF4aXM7XG4gIH1cbiAgaWYgKHR5cGVvZihheGlzKSA9PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGF4aXMgPT09IDAgfHwgYXhpcyA9PT0gMSkge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICAgIHRocm93IFwiRHlncmFwaHMgb25seSBzdXBwb3J0cyB0d28geS1heGVzLCBpbmRleGVkIGZyb20gMC0xLlwiO1xuICB9XG4gIGlmIChheGlzKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIGF4aXMgOiBcIiArIGF4aXM7XG4gIH1cbiAgLy8gTm8gYXhpcyBzcGVjaWZpY2F0aW9uIG1lYW5zIGF4aXMgMC5cbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIFJlcGFyc2VzIG9wdGlvbnMgdGhhdCBhcmUgYWxsIHJlbGF0ZWQgdG8gc2VyaWVzLiBUaGlzIHR5cGljYWxseSBvY2N1cnMgd2hlblxuICogb3B0aW9ucyBhcmUgZWl0aGVyIHVwZGF0ZWQsIG9yIHNvdXJjZSBkYXRhIGhhcyBiZWVuIG1hZGUgYXZhaWxhYmxlLlxuICpcbiAqIFRPRE8oa29uaWdzYmVyZyk6IFRoZSBtZXRob2QgbmFtZSBpcyBraW5kIG9mIHdlYWs7IGZpeC5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnJlcGFyc2VTZXJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhYmVscyA9IHRoaXMuZ2V0KFwibGFiZWxzXCIpO1xuICBpZiAoIWxhYmVscykge1xuICAgIHJldHVybjsgLy8gLS0gY2FuJ3QgZG8gbW9yZSBmb3Igbm93LCB3aWxsIHBhcnNlIGFmdGVyIGdldHRpbmcgdGhlIGxhYmVscy5cbiAgfVxuXG4gIHRoaXMubGFiZWxzXyA9IGxhYmVscy5zbGljZSgxKTtcblxuICB0aGlzLnlBeGVzXyA9IFsgeyBzZXJpZXMgOiBbXSwgb3B0aW9ucyA6IHt9fSBdOyAvLyBBbHdheXMgb25lIGF4aXMgYXQgbGVhc3QuXG4gIHRoaXMueEF4aXNfID0geyBvcHRpb25zIDoge30gfTtcbiAgdGhpcy5zZXJpZXNfID0ge307XG5cbiAgLy8gU2VyaWVzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIHNlcmllcyBlbGVtZW50OlxuICAvL1xuICAvLyB7XG4gIC8vICAgbGFiZWxzOiBbIFwiWFwiLCBcImZvb1wiLCBcImJhclwiIF0sXG4gIC8vICAgcG9pbnRTaXplOiAzLFxuICAvLyAgIHNlcmllcyA6IHtcbiAgLy8gICAgIGZvbyA6IHt9LCAvLyBvcHRpb25zIGZvciBmb29cbiAgLy8gICAgIGJhciA6IHt9IC8vIG9wdGlvbnMgZm9yIGJhclxuICAvLyAgIH1cbiAgLy8gfVxuICAvL1xuICAvLyBTbywgaWYgc2VyaWVzIGlzIGZvdW5kLCBpdCdzIGV4cGVjdGVkIHRvIGNvbnRhaW4gcGVyLXNlcmllcyBkYXRhLCBvdGhlcndpc2Ugc2V0IGFcbiAgLy8gZGVmYXVsdC5cbiAgdmFyIHNlcmllc0RpY3QgPSB0aGlzLnVzZXJfLnNlcmllcyB8fCB7fTtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sYWJlbHNfLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMubGFiZWxzX1tpZHhdO1xuICAgIHZhciBvcHRpb25zRm9yU2VyaWVzID0gc2VyaWVzRGljdFtzZXJpZXNOYW1lXSB8fCB7fTtcbiAgICB2YXIgeUF4aXMgPSBEeWdyYXBoT3B0aW9ucy5heGlzVG9JbmRleF8ob3B0aW9uc0ZvclNlcmllc1tcImF4aXNcIl0pO1xuXG4gICAgdGhpcy5zZXJpZXNfW3Nlcmllc05hbWVdID0ge1xuICAgICAgaWR4OiBpZHgsXG4gICAgICB5QXhpczogeUF4aXMsXG4gICAgICBvcHRpb25zIDogb3B0aW9uc0ZvclNlcmllcyB9O1xuXG4gICAgaWYgKCF0aGlzLnlBeGVzX1t5QXhpc10pIHtcbiAgICAgIHRoaXMueUF4ZXNfW3lBeGlzXSA9ICB7IHNlcmllcyA6IFsgc2VyaWVzTmFtZSBdLCBvcHRpb25zIDoge30gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55QXhlc19beUF4aXNdLnNlcmllcy5wdXNoKHNlcmllc05hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBheGlzX29wdHMgPSB0aGlzLnVzZXJfW1wiYXhlc1wiXSB8fCB7fTtcbiAgdXRpbHMudXBkYXRlKHRoaXMueUF4ZXNfWzBdLm9wdGlvbnMsIGF4aXNfb3B0c1tcInlcIl0gfHwge30pO1xuICBpZiAodGhpcy55QXhlc18ubGVuZ3RoID4gMSkge1xuICAgIHV0aWxzLnVwZGF0ZSh0aGlzLnlBeGVzX1sxXS5vcHRpb25zLCBheGlzX29wdHNbXCJ5MlwiXSB8fCB7fSk7XG4gIH1cbiAgdXRpbHMudXBkYXRlKHRoaXMueEF4aXNfLm9wdGlvbnMsIGF4aXNfb3B0c1tcInhcIl0gfHwge30pO1xuXG4gIC8vIEZvciBcInByb2R1Y3Rpb25cIiBjb2RlLCB0aGlzIGdldHMgcmVtb3ZlZCBieSB1Z2xpZnlqcy5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMudmFsaWRhdGVPcHRpb25zXygpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxVc2VyXyhuYW1lKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsVXNlcl8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLnVzZXJfLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlcl9bbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuZ2V0R2xvYmFsRGVmYXVsdF8gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLmdsb2JhbF8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxfW25hbWVdO1xuICB9XG4gIGlmIChERUZBVUxUX0FUVFJTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfQVRUUlNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIGF4aXMuIElmIHRoZXJlIGlzIG5vIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgYXhpcyxcbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXhpcyB0aGUgYXhpcyB0byBzZWFyY2guIENhbiBiZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ5XCIsIFwieTJcIikgb3IgdGhlIGF4aXMgbnVtYmVyICgwLCAxKS5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLmdldEZvckF4aXMgPSBmdW5jdGlvbihuYW1lLCBheGlzKSB7XG4gIHZhciBheGlzSWR4O1xuICB2YXIgYXhpc1N0cmluZztcblxuICAvLyBTaW5jZSBheGlzIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZywgc3RyYWlnaHRlbiBldmVyeXRoaW5nIG91dCBoZXJlLlxuICBpZiAodHlwZW9mKGF4aXMpID09ICdudW1iZXInKSB7XG4gICAgYXhpc0lkeCA9IGF4aXM7XG4gICAgYXhpc1N0cmluZyA9IGF4aXNJZHggPT09IDAgPyBcInlcIiA6IFwieTJcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXhpcyA9PSBcInkxXCIpIHsgYXhpcyA9IFwieVwiOyB9IC8vIFN0YW5kYXJkaXplIG9uICd5Jy4gSXMgdGhpcyBiYWQ/IEkgdGhpbmsgc28uXG4gICAgaWYgKGF4aXMgPT0gXCJ5XCIpIHtcbiAgICAgIGF4aXNJZHggPSAwO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInkyXCIpIHtcbiAgICAgIGF4aXNJZHggPSAxO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PSBcInhcIikge1xuICAgICAgYXhpc0lkeCA9IC0xOyAvLyBzaW1wbHkgYSBwbGFjZWhvbGRlciBmb3IgYmVsb3cuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVW5rbm93biBheGlzIFwiICsgYXhpcztcbiAgICB9XG4gICAgYXhpc1N0cmluZyA9IGF4aXM7XG4gIH1cblxuICB2YXIgdXNlckF4aXMgPSAoYXhpc0lkeCA9PSAtMSkgPyB0aGlzLnhBeGlzXyA6IHRoaXMueUF4ZXNfW2F4aXNJZHhdO1xuXG4gIC8vIFNlYXJjaCB0aGUgdXNlci1zcGVjaWZpZWQgYXhpcyBvcHRpb24gZmlyc3QuXG4gIGlmICh1c2VyQXhpcykgeyAvLyBUaGlzIGNvbmRpdGlvbiBjb3VsZCBiZSByZW1vdmVkIGlmIHdlIGFsd2F5cyBzZXQgdXAgdGhpcy55QXhlc18gZm9yIHkyLlxuICAgIHZhciBheGlzT3B0aW9ucyA9IHVzZXJBeGlzLm9wdGlvbnM7XG4gICAgaWYgKGF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1zcGVjaWZpZWQgZ2xvYmFsIG9wdGlvbnMgc2Vjb25kLlxuICAvLyBCdXQsIGhhY2ssIGlnbm9yZSBnbG9iYWxseS1zcGVjaWZpZWQgJ2xvZ3NjYWxlJyBmb3IgJ3gnIGF4aXMgZGVjbGFyYXRpb24uXG4gIGlmICghKGF4aXMgPT09ICd4JyAmJiBuYW1lID09PSAnbG9nc2NhbGUnKSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEdsb2JhbFVzZXJfKG5hbWUpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIERlZmF1bHQgYXhpcyBvcHRpb25zIHRoaXJkLlxuICB2YXIgZGVmYXVsdEF4aXNPcHRpb25zID0gREVGQVVMVF9BVFRSUy5heGVzW2F4aXNTdHJpbmddO1xuICBpZiAoZGVmYXVsdEF4aXNPcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRBeGlzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgZ2xvYmFsIG9wdGlvbnMgbGFzdC5cbiAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRGVmYXVsdF8obmFtZSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHZhbHVlIGZvciBhIHNwZWNpZmljIHNlcmllcy4gSWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBzZXJpZXMsXG4gKiB0aGUgdmFsdWUgZm9yIHRoZSBheGlzIGlzIHJldHVybmVkIChhbmQgYWZ0ZXJ3YXJkcywgdGhlIGdsb2JhbCB2YWx1ZS4pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJpZXMgdGhlIHNlcmllcyB0byBzZWFyY2guXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5nZXRGb3JTZXJpZXMgPSBmdW5jdGlvbihuYW1lLCBzZXJpZXMpIHtcbiAgLy8gSG9ub3JzIGluZGV4ZXMgYXMgc2VyaWVzLlxuICBpZiAoc2VyaWVzID09PSB0aGlzLmR5Z3JhcGhfLmdldEhpZ2hsaWdodFNlcmllcygpKSB7XG4gICAgaWYgKHRoaXMuaGlnaGxpZ2h0U2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2VyaWVzX1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuc2VyaWVzXy5oYXNPd25Qcm9wZXJ0eShzZXJpZXMpKSB7XG4gICAgdGhyb3cgXCJVbmtub3duIHNlcmllczogXCIgKyBzZXJpZXM7XG4gIH1cblxuICB2YXIgc2VyaWVzT2JqID0gdGhpcy5zZXJpZXNfW3Nlcmllc107XG4gIHZhciBzZXJpZXNPcHRpb25zID0gc2VyaWVzT2JqW1wib3B0aW9uc1wiXTtcbiAgaWYgKHNlcmllc09wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gc2VyaWVzT3B0aW9uc1tuYW1lXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmdldEZvckF4aXMobmFtZSwgc2VyaWVzT2JqW1wieUF4aXNcIl0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgeS1heGVzIG9uIHRoZSBjaGFydC5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBheGVzLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55QXhlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHktYXhpcyBmb3IgYSBnaXZlbiBzZXJpZXMsIHNwZWNpZmllZCBieSBuYW1lLlxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUuYXhpc0ZvclNlcmllcyA9IGZ1bmN0aW9uKHNlcmllcykge1xuICByZXR1cm4gdGhpcy5zZXJpZXNfW3Nlcmllc10ueUF4aXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzcGVjaWZpZWQgYXhpcy5cbiAqL1xuLy8gVE9ETyhrb25pZ3NiZXJnKTogdGhpcyBpcyB5LWF4aXMgc3BlY2lmaWMuIFN1cHBvcnQgdGhlIHggYXhpcy5cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5heGlzT3B0aW9ucyA9IGZ1bmN0aW9uKHlBeGlzKSB7XG4gIHJldHVybiB0aGlzLnlBeGVzX1t5QXhpc10ub3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzZXJpZXMgYXNzb2NpYXRlZCB3aXRoIGFuIGF4aXMuXG4gKi9cbkR5Z3JhcGhPcHRpb25zLnByb3RvdHlwZS5zZXJpZXNGb3JBeGlzID0gZnVuY3Rpb24oeUF4aXMpIHtcbiAgcmV0dXJuIHRoaXMueUF4ZXNfW3lBeGlzXS5zZXJpZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2VyaWVzLCBpbiB0aGVpciBjb2x1bW5hciBvcmRlci5cbiAqL1xuRHlncmFwaE9wdGlvbnMucHJvdG90eXBlLnNlcmllc05hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxhYmVsc187XG59O1xuXG4vLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT0gJ3Byb2R1Y3Rpb24nKSB7XG5cbi8qKlxuICogVmFsaWRhdGUgYWxsIG9wdGlvbnMuXG4gKiBUaGlzIHJlcXVpcmVzIE9QVElPTlNfUkVGRVJFTkNFLCB3aGljaCBpcyBvbmx5IGF2YWlsYWJsZSBpbiBkZWJ1ZyBidWlsZHMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUudmFsaWRhdGVPcHRpb25zXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIE9QVElPTlNfUkVGRVJFTkNFID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93ICdDYWxsZWQgdmFsaWRhdGVPcHRpb25zXyBpbiBwcm9kIGJ1aWxkLic7XG4gIH1cblxuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciB2YWxpZGF0ZU9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICBpZiAoIU9QVElPTlNfUkVGRVJFTkNFW29wdGlvbk5hbWVdKSB7XG4gICAgICB0aGF0Lndhcm5JbnZhbGlkT3B0aW9uXyhvcHRpb25OYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9wdGlvbnNEaWN0cyA9IFt0aGlzLnhBeGlzXy5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMueUF4ZXNfWzBdLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy55QXhlc19bMV0gJiYgdGhpcy55QXhlc19bMV0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbF8sXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyXyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFNlcmllc19dO1xuICB2YXIgbmFtZXMgPSB0aGlzLnNlcmllc05hbWVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgIGlmICh0aGlzLnNlcmllc18uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIG9wdGlvbnNEaWN0cy5wdXNoKHRoaXMuc2VyaWVzX1tuYW1lXS5vcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zRGljdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGljdCA9IG9wdGlvbnNEaWN0c1tpXTtcbiAgICBpZiAoIWRpY3QpIGNvbnRpbnVlO1xuICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gZGljdCkge1xuICAgICAgaWYgKGRpY3QuaGFzT3duUHJvcGVydHkob3B0aW9uTmFtZSkpIHtcbiAgICAgICAgdmFsaWRhdGVPcHRpb24ob3B0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgV0FSTklOR1MgPSB7fTsgIC8vIE9ubHkgc2hvdyBhbnkgcGFydGljdWxhciB3YXJuaW5nIG9uY2UuXG5cbi8qKlxuICogTG9ncyBhIHdhcm5pbmcgYWJvdXQgaW52YWxpZCBvcHRpb25zLlxuICogVE9ETzogbWFrZSB0aGlzIHRocm93IGZvciB0ZXN0aW5nXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoT3B0aW9ucy5wcm90b3R5cGUud2FybkludmFsaWRPcHRpb25fID0gZnVuY3Rpb24ob3B0aW9uTmFtZSkge1xuICBpZiAoIVdBUk5JTkdTW29wdGlvbk5hbWVdKSB7XG4gICAgV0FSTklOR1Nbb3B0aW9uTmFtZV0gPSB0cnVlO1xuICAgIHZhciBpc1NlcmllcyA9ICh0aGlzLmxhYmVsc18uaW5kZXhPZihvcHRpb25OYW1lKSA+PSAwKTtcbiAgICBpZiAoaXNTZXJpZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignVXNlIG5ldy1zdHlsZSBwZXItc2VyaWVzIG9wdGlvbnMgKHNhdyAnICsgb3B0aW9uTmFtZSArICcgYXMgdG9wLWxldmVsIG9wdGlvbnMga2V5KS4gU2VlIGh0dHA6Ly9iaXQubHkvMXRjZWFKcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vua25vd24gb3B0aW9uICcgKyBvcHRpb25OYW1lICsgJyAoZnVsbCBsaXN0IG9mIG9wdGlvbnMgYXQgZHlncmFwaHMuY29tL29wdGlvbnMuaHRtbCcpO1xuICAgICAgdGhyb3cgXCJpbnZhbGlkIG9wdGlvbiBcIiArIG9wdGlvbk5hbWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZXNldCBsaXN0IG9mIHByZXZpb3VzbHktc2hvd24gd2FybmluZ3MuIFVzZWQgZm9yIHRlc3RpbmcuXG5EeWdyYXBoT3B0aW9ucy5yZXNldFdhcm5pbmdzXyA9IGZ1bmN0aW9uKCkge1xuICBXQVJOSU5HUyA9IHt9O1xufTtcblxufVxuXG5leHBvcnQgZGVmYXVsdCBEeWdyYXBoT3B0aW9ucztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDExIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERlc2NyaXB0aW9uIG9mIHRoaXMgZmlsZS5cbiAqIEBhdXRob3IgZGFudmtAZ29vZ2xlLmNvbSAoRGFuIFZhbmRlcmthbSlcbiAqXG4gKiBBIHRpY2tlciBpcyBhIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmZhY2U6XG4gKlxuICogZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRpb25zX3ZpZXcsIGR5Z3JhcGgsIGZvcmNlZF92YWx1ZXMpO1xuICogLT4gWyB7IHY6IHRpY2sxX3YsIGxhYmVsOiB0aWNrMV9sYWJlbFssIGxhYmVsX3Y6IGxhYmVsX3YxXSB9LFxuICogICAgICB7IHY6IHRpY2syX3YsIGxhYmVsOiB0aWNrMl9sYWJlbFssIGxhYmVsX3Y6IGxhYmVsX3YyXSB9LFxuICogICAgICAuLi5cbiAqICAgIF1cbiAqXG4gKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgY2FsbGVkIGEgXCJ0aWNrIGxpc3RcIi5cbiAqXG4gKiBBcmd1bWVudHNcbiAqIC0tLS0tLS0tLVxuICpcbiAqIFthLCBiXSBpcyB0aGUgcmFuZ2Ugb2YgdGhlIGF4aXMgZm9yIHdoaWNoIHRpY2tzIGFyZSBiZWluZyBnZW5lcmF0ZWQuIEZvciBhXG4gKiBudW1lcmljIGF4aXMsIHRoZXNlIHdpbGwgc2ltcGx5IGJlIG51bWJlcnMuIEZvciBhIGRhdGUgYXhpcywgdGhlc2Ugd2lsbCBiZVxuICogbWlsbGlzIHNpbmNlIGVwb2NoIChjb252ZXJ0YWJsZSB0byBEYXRlIG9iamVjdHMgdXNpbmcgXCJuZXcgRGF0ZShhKVwiIGFuZCBcIm5ld1xuICogRGF0ZShiKVwiKS5cbiAqXG4gKiBvcHRzIHByb3ZpZGVzIGFjY2VzcyB0byBjaGFydC0gYW5kIGF4aXMtc3BlY2lmaWMgb3B0aW9ucy4gSXQgY2FuIGJlIHVzZWQgdG9cbiAqIGFjY2VzcyBudW1iZXIvZGF0ZSBmb3JtYXR0aW5nIGNvZGUvb3B0aW9ucywgY2hlY2sgZm9yIGEgbG9nIHNjYWxlLCBldGMuXG4gKlxuICogcGl4ZWxzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGF4aXMgaW4gcGl4ZWxzLiBvcHRzKCdwaXhlbHNQZXJMYWJlbCcpIGlzIHRoZVxuICogbWluaW11bSBhbW91bnQgb2Ygc3BhY2UgdG8gYmUgYWxsb3R0ZWQgdG8gZWFjaCBsYWJlbC4gRm9yIGluc3RhbmNlLCBpZlxuICogcGl4ZWxzPTQwMCBhbmQgb3B0cygncGl4ZWxzUGVyTGFiZWwnKT00MCB0aGVuIHRoZSB0aWNrZXIgc2hvdWxkIHJldHVyblxuICogYmV0d2VlbiB6ZXJvIGFuZCB0ZW4gKDQwMC80MCkgdGlja3MuXG4gKlxuICogZHlncmFwaCBpcyB0aGUgRHlncmFwaCBvYmplY3QgZm9yIHdoaWNoIGFuIGF4aXMgaXMgYmVpbmcgY29uc3RydWN0ZWQuXG4gKlxuICogZm9yY2VkX3ZhbHVlcyBpcyB1c2VkIGZvciBzZWNvbmRhcnkgeS1heGVzLiBUaGUgdGljayBwb3NpdGlvbnMgYXJlIHR5cGljYWxseVxuICogc2V0IGJ5IHRoZSBwcmltYXJ5IHktYXhpcywgc28gdGhlIHNlY29uZGFyeSB5LWF4aXMgaGFzIG5vIGNob2ljZSBpbiB3aGVyZSB0b1xuICogcHV0IHRoZXNlLiBJdCBzaW1wbHkgaGFzIHRvIGdlbmVyYXRlIGxhYmVscyBmb3IgdGhlc2UgZGF0YSB2YWx1ZXMuXG4gKlxuICogVGljayBsaXN0c1xuICogLS0tLS0tLS0tLVxuICogVHlwaWNhbGx5IGEgdGljayB3aWxsIGhhdmUgYm90aCBhIGdyaWQvdGljayBsaW5lIGFuZCBhIGxhYmVsIGF0IG9uZSBlbmQgb2ZcbiAqIHRoYXQgbGluZSAoYXQgdGhlIGJvdHRvbSBmb3IgYW4geC1heGlzLCBhdCBsZWZ0IG9yIHJpZ2h0IGZvciB0aGUgeS1heGlzKS5cbiAqXG4gKiBBIHRpY2sgbWF5IGJlIG1pc3Npbmcgb25lIG9mIHRoZXNlIHR3byBjb21wb25lbnRzOlxuICogLSBJZiBcImxhYmVsX3ZcIiBpcyBzcGVjaWZpZWQgaW5zdGVhZCBvZiBcInZcIiwgdGhlbiB0aGVyZSB3aWxsIGJlIG5vIHRpY2sgb3JcbiAqICAgZ3JpZGxpbmUsIGp1c3QgYSBsYWJlbC5cbiAqIC0gU2ltaWxhcmx5LCBpZiBcImxhYmVsXCIgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB0aGVyZSB3aWxsIGJlIGEgZ3JpZGxpbmVcbiAqICAgd2l0aG91dCBhIGxhYmVsLlxuICpcbiAqIFRoaXMgZmxleGliaWxpdHkgaXMgdXNlZnVsIGluIGEgZmV3IHNpdHVhdGlvbnM6XG4gKiAtIEZvciBsb2cgc2NhbGVzLCBzb21lIG9mIHRoZSB0aWNrIGxpbmVzIG1heSBiZSB0b28gY2xvc2UgdG8gYWxsIGhhdmUgbGFiZWxzLlxuICogLSBGb3IgZGF0ZSBzY2FsZXMgd2hlcmUgeWVhcnMgYXJlIGJlaW5nIGRpc3BsYXllZCwgaXQgaXMgZGVzaXJhYmxlIHRvIGRpc3BsYXlcbiAqICAgdGljayBtYXJrcyBhdCB0aGUgYmVnaW5uaW5ncyBvZiB5ZWFycyBidXQgbGFiZWxzIChlLmcuIFwiMjAwNlwiKSBpbiB0aGVcbiAqICAgbWlkZGxlIG9mIHRoZSB5ZWFycy5cbiAqL1xuXG4vKmpzaGludCBzdWI6dHJ1ZSAqL1xuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPHt2Om51bWJlciwgbGFiZWw6c3RyaW5nLCBsYWJlbF92OihzdHJpbmd8dW5kZWZpbmVkKX0+fSAqL1xudmFyIFRpY2tMaXN0ID0gdW5kZWZpbmVkOyAgLy8gdGhlICcgPSB1bmRlZmluZWQnIGtlZXBzIGpzaGludCBoYXBweS5cblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbihcbiAqICAgIG51bWJlcixcbiAqICAgIG51bWJlcixcbiAqICAgIG51bWJlcixcbiAqICAgIGZ1bmN0aW9uKHN0cmluZyk6KixcbiAqICAgIER5Z3JhcGg9LFxuICogICAgQXJyYXkuPG51bWJlcj49XG4gKiAgKTogVGlja0xpc3R9XG4gKi9cbnZhciBUaWNrZXIgPSB1bmRlZmluZWQ7ICAvLyB0aGUgJyA9IHVuZGVmaW5lZCcga2VlcHMganNoaW50IGhhcHB5LlxuXG4vKiogQHR5cGUge1RpY2tlcn0gKi9cbmV4cG9ydCB2YXIgbnVtZXJpY0xpbmVhclRpY2tzID0gZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRzLCBkeWdyYXBoLCB2YWxzKSB7XG4gIHZhciBub25Mb2dzY2FsZU9wdHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgICBpZiAob3B0ID09PSAnbG9nc2NhbGUnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9wdHMob3B0KTtcbiAgfTtcbiAgcmV0dXJuIG51bWVyaWNUaWNrcyhhLCBiLCBwaXhlbHMsIG5vbkxvZ3NjYWxlT3B0cywgZHlncmFwaCwgdmFscyk7XG59O1xuXG4vKiogQHR5cGUge1RpY2tlcn0gKi9cbmV4cG9ydCB2YXIgbnVtZXJpY1RpY2tzID0gZnVuY3Rpb24oYSwgYiwgcGl4ZWxzLCBvcHRzLCBkeWdyYXBoLCB2YWxzKSB7XG4gIHZhciBwaXhlbHNfcGVyX3RpY2sgPSAvKiogQHR5cGV7bnVtYmVyfSAqLyhvcHRzKCdwaXhlbHNQZXJMYWJlbCcpKTtcbiAgdmFyIHRpY2tzID0gW107XG4gIHZhciBpLCBqLCB0aWNrViwgblRpY2tzO1xuICBpZiAodmFscykge1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2OiB2YWxzW2ldfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8oZGFudmspOiBmYWN0b3IgdGhpcyBsb2ctc2NhbGUgYmxvY2sgb3V0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cbiAgICBpZiAob3B0cyhcImxvZ3NjYWxlXCIpKSB7XG4gICAgICBuVGlja3MgID0gTWF0aC5mbG9vcihwaXhlbHMgLyBwaXhlbHNfcGVyX3RpY2spO1xuICAgICAgdmFyIG1pbklkeCA9IHV0aWxzLmJpbmFyeVNlYXJjaChhLCBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTLCAxKTtcbiAgICAgIHZhciBtYXhJZHggPSB1dGlscy5iaW5hcnlTZWFyY2goYiwgUFJFRkVSUkVEX0xPR19USUNLX1ZBTFVFUywgLTEpO1xuICAgICAgaWYgKG1pbklkeCA9PSAtMSkge1xuICAgICAgICBtaW5JZHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG1heElkeCA9PSAtMSkge1xuICAgICAgICBtYXhJZHggPSBQUkVGRVJSRURfTE9HX1RJQ0tfVkFMVUVTLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpY2sgdmFsdWVzIHdvdWxkIGFwcGVhciwgaWYgd2UgY2FuIGdldCBhdCBsZWFzdFxuICAgICAgLy8gblRpY2tzIC8gNCBhY2NlcHQgdGhlbS5cbiAgICAgIHZhciBsYXN0RGlzcGxheWVkID0gbnVsbDtcbiAgICAgIGlmIChtYXhJZHggLSBtaW5JZHggPj0gblRpY2tzIC8gNCkge1xuICAgICAgICBmb3IgKHZhciBpZHggPSBtYXhJZHg7IGlkeCA+PSBtaW5JZHg7IGlkeC0tKSB7XG4gICAgICAgICAgdmFyIHRpY2tWYWx1ZSA9IFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVNbaWR4XTtcbiAgICAgICAgICB2YXIgcGl4ZWxfY29vcmQgPSBNYXRoLmxvZyh0aWNrVmFsdWUgLyBhKSAvIE1hdGgubG9nKGIgLyBhKSAqIHBpeGVscztcbiAgICAgICAgICB2YXIgdGljayA9IHsgdjogdGlja1ZhbHVlIH07XG4gICAgICAgICAgaWYgKGxhc3REaXNwbGF5ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3REaXNwbGF5ZWQgPSB7XG4gICAgICAgICAgICAgIHRpY2tWYWx1ZSA6IHRpY2tWYWx1ZSxcbiAgICAgICAgICAgICAgcGl4ZWxfY29vcmQgOiBwaXhlbF9jb29yZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBpeGVsX2Nvb3JkIC0gbGFzdERpc3BsYXllZC5waXhlbF9jb29yZCkgPj0gcGl4ZWxzX3Blcl90aWNrKSB7XG4gICAgICAgICAgICAgIGxhc3REaXNwbGF5ZWQgPSB7XG4gICAgICAgICAgICAgICAgdGlja1ZhbHVlIDogdGlja1ZhbHVlLFxuICAgICAgICAgICAgICAgIHBpeGVsX2Nvb3JkIDogcGl4ZWxfY29vcmRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRpY2subGFiZWwgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aWNrcy5wdXNoKHRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlIHdlbnQgaW4gYmFja3dhcmRzIG9yZGVyLlxuICAgICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGlja3MubGVuZ3RoIHdvbid0IGJlIDAgaWYgdGhlIGxvZyBzY2FsZSBmdW5jdGlvbiBmaW5kcyB2YWx1ZXMgdG8gaW5zZXJ0LlxuICAgIGlmICh0aWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEJhc2ljIGlkZWE6XG4gICAgICAvLyBUcnkgbGFiZWxzIGV2ZXJ5IDEsIDIsIDUsIDEwLCAyMCwgNTAsIDEwMCwgZXRjLlxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZXN1bHRpbmcgdGljayBzcGFjaW5nIChpLmUuIHRoaXMuaGVpZ2h0XyAvIG5UaWNrcykuXG4gICAgICAvLyBUaGUgZmlyc3Qgc3BhY2luZyBncmVhdGVyIHRoYW4gcGl4ZWxzUGVyWUxhYmVsIGlzIHdoYXQgd2UgdXNlLlxuICAgICAgLy8gVE9ETyhkYW52ayk6IHZlcnNpb24gdGhhdCB3b3JrcyBvbiBhIGxvZyBzY2FsZS5cbiAgICAgIHZhciBrbWcyID0gb3B0cyhcImxhYmVsc0tNRzJcIik7XG4gICAgICB2YXIgbXVsdHMsIGJhc2U7XG4gICAgICBpZiAoa21nMikge1xuICAgICAgICBtdWx0cyA9IFsxLCAyLCA0LCA4LCAxNiwgMzIsIDY0LCAxMjgsIDI1Nl07XG4gICAgICAgIGJhc2UgPSAxNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRzID0gWzEsIDIsIDUsIDEwLCAyMCwgNTAsIDEwMF07XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBwZXJtaXR0ZWQgdGlja3MgYmFzZWQgb24gdGhlXG4gICAgICAvLyBncmFwaCdzIHBpeGVsIHNpemUgYW5kIHBpeGVsc19wZXJfdGljayBzZXR0aW5nLlxuICAgICAgdmFyIG1heF90aWNrcyA9IE1hdGguY2VpbChwaXhlbHMgLyBwaXhlbHNfcGVyX3RpY2spO1xuXG4gICAgICAvLyBOb3cgY2FsY3VsYXRlIHRoZSBkYXRhIHVuaXQgZXF1aXZhbGVudCBvZiB0aGlzIHRpY2sgc3BhY2luZy5cbiAgICAgIC8vIFVzZSBhYnMoKSBzaW5jZSBncmFwaHMgbWF5IGhhdmUgYSByZXZlcnNlZCBZIGF4aXMuXG4gICAgICB2YXIgdW5pdHNfcGVyX3RpY2sgPSBNYXRoLmFicyhiIC0gYSkgLyBtYXhfdGlja3M7XG5cbiAgICAgIC8vIEJhc2VkIG9uIHRoaXMsIGdldCBhIHN0YXJ0aW5nIHNjYWxlIHdoaWNoIGlzIHRoZSBsYXJnZXN0XG4gICAgICAvLyBpbnRlZ2VyIHBvd2VyIG9mIHRoZSBjaG9zZW4gYmFzZSAoMTAgb3IgMTYpIHRoYXQgc3RpbGwgcmVtYWluc1xuICAgICAgLy8gYmVsb3cgdGhlIHJlcXVlc3RlZCBwaXhlbHNfcGVyX3RpY2sgc3BhY2luZy5cbiAgICAgIHZhciBiYXNlX3Bvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyh1bml0c19wZXJfdGljaykgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgYmFzZV9zY2FsZSA9IE1hdGgucG93KGJhc2UsIGJhc2VfcG93ZXIpO1xuXG4gICAgICAvLyBOb3cgdHJ5IG11bHRpcGxlcyBvZiB0aGUgc3RhcnRpbmcgc2NhbGUgdW50aWwgd2UgZmluZCBvbmVcbiAgICAgIC8vIHRoYXQgcmVzdWx0cyBpbiB0aWNrIG1hcmtzIHNwYWNlZCBzdWZmaWNpZW50bHkgZmFyIGFwYXJ0LlxuICAgICAgLy8gVGhlIFwibXVsdHNcIiBhcnJheSBzaG91bGQgY292ZXIgdGhlIHJhbmdlIDEgLi4gYmFzZV4yIHRvXG4gICAgICAvLyBhZGp1c3QgZm9yIHJvdW5kaW5nIGFuZCBlZGdlIGVmZmVjdHMuXG4gICAgICB2YXIgc2NhbGUsIGxvd192YWwsIGhpZ2hfdmFsLCBzcGFjaW5nO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG11bHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNjYWxlID0gYmFzZV9zY2FsZSAqIG11bHRzW2pdO1xuICAgICAgICBsb3dfdmFsID0gTWF0aC5mbG9vcihhIC8gc2NhbGUpICogc2NhbGU7XG4gICAgICAgIGhpZ2hfdmFsID0gTWF0aC5jZWlsKGIgLyBzY2FsZSkgKiBzY2FsZTtcbiAgICAgICAgblRpY2tzID0gTWF0aC5hYnMoaGlnaF92YWwgLSBsb3dfdmFsKSAvIHNjYWxlO1xuICAgICAgICBzcGFjaW5nID0gcGl4ZWxzIC8gblRpY2tzO1xuICAgICAgICBpZiAoc3BhY2luZyA+IHBpeGVsc19wZXJfdGljaykgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgc2V0IG9mIHRpY2tzLlxuICAgICAgLy8gQWxsb3cgcmV2ZXJzZSB5LWF4aXMgaWYgaXQncyBleHBsaWNpdGx5IHJlcXVlc3RlZC5cbiAgICAgIGlmIChsb3dfdmFsID4gaGlnaF92YWwpIHNjYWxlICo9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8PSBuVGlja3M7IGkrKykge1xuICAgICAgICB0aWNrViA9IGxvd192YWwgKyBpICogc2NhbGU7XG4gICAgICAgIHRpY2tzLnB1c2goIHt2OiB0aWNrVn0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZm9ybWF0dGVyID0gLyoqQHR5cGV7QXhpc0xhYmVsRm9ybWF0dGVyfSovKG9wdHMoJ2F4aXNMYWJlbEZvcm1hdHRlcicpKTtcblxuICAvLyBBZGQgbGFiZWxzIHRvIHRoZSB0aWNrcy5cbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLmxhYmVsICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAgLy8gVXNlIGN1cnJlbnQgbGFiZWwuXG4gICAgLy8gVE9ETyhkYW52ayk6IHNldCBncmFudWxhcml0eSB0byBzb21ldGhpbmcgYXBwcm9wcmlhdGUgaGVyZS5cbiAgICB0aWNrc1tpXS5sYWJlbCA9IGZvcm1hdHRlci5jYWxsKGR5Z3JhcGgsIHRpY2tzW2ldLnYsIDAsIG9wdHMsIGR5Z3JhcGgpO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufTtcblxuXG4vKiogQHR5cGUge1RpY2tlcn0gKi9cbmV4cG9ydCB2YXIgZGF0ZVRpY2tlciA9IGZ1bmN0aW9uKGEsIGIsIHBpeGVscywgb3B0cywgZHlncmFwaCwgdmFscykge1xuICB2YXIgY2hvc2VuID0gcGlja0RhdGVUaWNrR3JhbnVsYXJpdHkoYSwgYiwgcGl4ZWxzLCBvcHRzKTtcblxuICBpZiAoY2hvc2VuID49IDApIHtcbiAgICByZXR1cm4gZ2V0RGF0ZUF4aXMoYSwgYiwgY2hvc2VuLCBvcHRzLCBkeWdyYXBoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgc2VsZi53aWR0aF8gaXMgemVyby5cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8vIFRpbWUgZ3JhbnVsYXJpdHkgZW51bWVyYXRpb25cbmV4cG9ydCB2YXIgR3JhbnVsYXJpdHkgPSB7XG4gIFNFQ09ORExZOiAwLFxuICBUV09fU0VDT05ETFk6IDEsXG4gIEZJVkVfU0VDT05ETFk6IDIsXG4gIFRFTl9TRUNPTkRMWTogMyxcbiAgVEhJUlRZX1NFQ09ORExZIDogNCxcbiAgTUlOVVRFTFk6IDUsXG4gIFRXT19NSU5VVEVMWTogNixcbiAgRklWRV9NSU5VVEVMWTogNyxcbiAgVEVOX01JTlVURUxZOiA4LFxuICBUSElSVFlfTUlOVVRFTFk6IDksXG4gIEhPVVJMWTogMTAsXG4gIFRXT19IT1VSTFk6IDExLFxuICBTSVhfSE9VUkxZOiAxMixcbiAgREFJTFk6IDEzLFxuICBUV09fREFJTFk6IDE0LFxuICBXRUVLTFk6IDE1LFxuICBNT05USExZOiAxNixcbiAgUVVBUlRFUkxZOiAxNyxcbiAgQklBTk5VQUw6IDE4LFxuICBBTk5VQUw6IDE5LFxuICBERUNBREFMOiAyMCxcbiAgQ0VOVEVOTklBTDogMjEsXG4gIE5VTV9HUkFOVUxBUklUSUVTOiAyMlxufVxuXG4vLyBEYXRlIGNvbXBvbmVudHMgZW51bWVyYXRpb24gKGluIHRoZSBvcmRlciBvZiB0aGUgYXJndW1lbnRzIGluIERhdGUpXG4vLyBUT0RPOiBtYWtlIHRoaXMgYW4gQGVudW1cbnZhciBEYXRlRmllbGQgPSB7XG4gIERBVEVGSUVMRF9ZOiAwLFxuICBEQVRFRklFTERfTTogMSxcbiAgREFURUZJRUxEX0Q6IDIsXG4gIERBVEVGSUVMRF9ISDogMyxcbiAgREFURUZJRUxEX01NOiA0LFxuICBEQVRFRklFTERfU1M6IDUsXG4gIERBVEVGSUVMRF9NUzogNixcbiAgTlVNX0RBVEVGSUVMRFM6IDdcbn07XG5cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgZGF0ZWZpZWxkIHdpbGwgc3RhcnQgYXQgYW4gZXZlbiBtdWx0aXBsZSBvZiBcInN0ZXBcIiwgaS5lLlxuICogICBpZiBkYXRlZmllbGQ9U1MgYW5kIHN0ZXA9NSB0aGVuIHRoZSBmaXJzdCB0aWNrIHdpbGwgYmUgb24gYSBtdWx0aXBsZSBvZiA1cy5cbiAqXG4gKiBGb3IgZ3JhbnVsYXJpdGllcyA8PSBIT1VSTFksIHRpY2tzIGFyZSBnZW5lcmF0ZWQgZXZlcnkgYHNwYWNpbmdgIG1zLlxuICpcbiAqIEF0IGNvYXJzZXIgZ3JhbnVsYXJpdGllcywgdGlja3MgYXJlIGdlbmVyYXRlZCBieSBpbmNyZW1lbnRpbmcgYGRhdGVmaWVsZGAgYnlcbiAqICAgYHN0ZXBgLiBJbiB0aGlzIGNhc2UsIHRoZSBgc3BhY2luZ2AgdmFsdWUgaXMgb25seSB1c2VkIHRvIGVzdGltYXRlIHRoZVxuICogICBudW1iZXIgb2YgdGlja3MuIEl0IHNob3VsZCByb3VnaGx5IGNvcnJlc3BvbmQgdG8gdGhlIHNwYWNpbmcgYmV0d2VlblxuICogICBhZGphY2VudCB0aWNrcy5cbiAqXG4gKiBAdHlwZSB7QXJyYXkuPHtkYXRlZmllbGQ6bnVtYmVyLCBzdGVwOm51bWJlciwgc3BhY2luZzpudW1iZXJ9Pn1cbiAqL1xudmFyIFRJQ0tfUExBQ0VNRU5UID0gW107XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5TRUNPTkRMWV0gICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogMX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fU0VDT05ETFldICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogMn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5GSVZFX1NFQ09ORExZXSAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogICA1LCBzcGFjaW5nOiAxMDAwICogNX07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5URU5fU0VDT05ETFldICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9TUywgc3RlcDogIDEwLCBzcGFjaW5nOiAxMDAwICogMTB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVEhJUlRZX1NFQ09ORExZXSA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfU1MsIHN0ZXA6ICAzMCwgc3BhY2luZzogMTAwMCAqIDMwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5Lk1JTlVURUxZXSAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA2MH07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5UV09fTUlOVVRFTFldICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTSwgc3RlcDogICAyLCBzcGFjaW5nOiAxMDAwICogNjAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkZJVkVfTUlOVVRFTFldICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX01NLCBzdGVwOiAgIDUsIHNwYWNpbmc6IDEwMDAgKiA2MCAqIDV9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVEVOX01JTlVURUxZXSAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAxMCwgc3BhY2luZzogMTAwMCAqIDYwICogMTB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVEhJUlRZX01JTlVURUxZXSA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTU0sIHN0ZXA6ICAzMCwgc3BhY2luZzogMTAwMCAqIDYwICogMzB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuSE9VUkxZXSAgICAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfSEgsIHN0ZXA6ICAgMSwgc3BhY2luZzogMTAwMCAqIDM2MDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVFdPX0hPVVJMWV0gICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfSEgsIHN0ZXA6ICAgMiwgc3BhY2luZzogMTAwMCAqIDM2MDAgKiAyfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LlNJWF9IT1VSTFldICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX0hILCBzdGVwOiAgIDYsIHNwYWNpbmc6IDEwMDAgKiAzNjAwICogNn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5EQUlMWV0gICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ELCAgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogODY0MDB9O1xuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuVFdPX0RBSUxZXSAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfRCwgIHN0ZXA6ICAgMiwgc3BhY2luZzogMTAwMCAqIDg2NDAwICogMn07XG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5XRUVLTFldICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ELCAgc3RlcDogICA3LCBzcGFjaW5nOiAxMDAwICogNjA0ODAwfTtcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5Lk1PTlRITFldICAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX00sICBzdGVwOiAgIDEsIHNwYWNpbmc6IDEwMDAgKiA3MjAwICAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgLyAxMlxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuUVVBUlRFUkxZXSAgICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfTSwgIHN0ZXA6ICAgMywgc3BhY2luZzogMTAwMCAqIDIxNjAwICogMzY1LjI1MjR9OyAvLyAxZTMgKiA2MCAqIDYwICogMjQgKiAzNjUuMjUyNCAvIDRcblRJQ0tfUExBQ0VNRU5UW0dyYW51bGFyaXR5LkJJQU5OVUFMXSAgICAgICAgPSB7ZGF0ZWZpZWxkOiBEYXRlRmllbGQuREFURUZJRUxEX00sICBzdGVwOiAgIDYsIHNwYWNpbmc6IDEwMDAgKiA0MzIwMCAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgLyAyXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5BTk5VQUxdICAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZLCAgc3RlcDogICAxLCBzcGFjaW5nOiAxMDAwICogODY0MDAgICAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgKiAxXG5USUNLX1BMQUNFTUVOVFtHcmFudWxhcml0eS5ERUNBREFMXSAgICAgICAgID0ge2RhdGVmaWVsZDogRGF0ZUZpZWxkLkRBVEVGSUVMRF9ZLCAgc3RlcDogIDEwLCBzcGFjaW5nOiAxMDAwICogODY0MDAwICAqIDM2NS4yNTI0fTsgLy8gMWUzICogNjAgKiA2MCAqIDI0ICogMzY1LjI1MjQgKiAxMFxuVElDS19QTEFDRU1FTlRbR3JhbnVsYXJpdHkuQ0VOVEVOTklBTF0gICAgICA9IHtkYXRlZmllbGQ6IERhdGVGaWVsZC5EQVRFRklFTERfWSwgIHN0ZXA6IDEwMCwgc3BhY2luZzogMTAwMCAqIDg2NDAwMDAgKiAzNjUuMjUyNH07IC8vIDFlMyAqIDYwICogNjAgKiAyNCAqIDM2NS4yNTI0ICogMTAwXG5cblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBodW1hbi1mcmllbmRseSB2YWx1ZXMgYXQgd2hpY2ggdG8gc2hvdyB0aWNrIG1hcmtzIG9uIGEgbG9nXG4gKiBzY2FsZS4gSXQgaXMgayAqIDEwXm4sIHdoZXJlIGs9MS4uOSBhbmQgbj0tMzkuLiszOSwgc286XG4gKiAuLi4sIDEsIDIsIDMsIDQsIDUsIC4uLiwgOSwgMTAsIDIwLCAzMCwgLi4uLCA5MCwgMTAwLCAyMDAsIDMwMCwgLi4uXG4gKiBOT1RFOiB0aGlzIGFzc3VtZXMgdGhhdCB1dGlscy5MT0dfU0NBTEUgPSAxMC5cbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqL1xudmFyIFBSRUZFUlJFRF9MT0dfVElDS19WQUxVRVMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB2YWxzID0gW107XG4gIGZvciAodmFyIHBvd2VyID0gLTM5OyBwb3dlciA8PSAzOTsgcG93ZXIrKykge1xuICAgIHZhciByYW5nZSA9IE1hdGgucG93KDEwLCBwb3dlcik7XG4gICAgZm9yICh2YXIgbXVsdCA9IDE7IG11bHQgPD0gOTsgbXVsdCsrKSB7XG4gICAgICB2YXIgdmFsID0gcmFuZ2UgKiBtdWx0O1xuICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxzO1xufSkoKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgZ3JhbnVsYXJpdHkgb2YgdGlja3Mgb24gYSBkYXRlIGF4aXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgTGVmdCBlZGdlIG9mIHRoZSBjaGFydCAobXMpXG4gKiBAcGFyYW0ge251bWJlcn0gYiBSaWdodCBlZGdlIG9mIHRoZSBjaGFydCAobXMpXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxzIFNpemUgb2YgdGhlIGNoYXJ0IGluIHRoZSByZWxldmFudCBkaW1lbnNpb24gKHdpZHRoKS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKToqfSBvcHRzIEZ1bmN0aW9uIG1hcHBpbmcgZnJvbSBvcHRpb24gbmFtZSAtJmd0OyB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFwcHJvcHJpYXRlIGF4aXMgZ3JhbnVsYXJpdHkgZm9yIHRoaXMgY2hhcnQuIFNlZSB0aGVcbiAqICAgICBlbnVtZXJhdGlvbiBvZiBwb3NzaWJsZSB2YWx1ZXMgaW4gZHlncmFwaC10aWNrZXJzLmpzLlxuICovXG52YXIgcGlja0RhdGVUaWNrR3JhbnVsYXJpdHkgPSBmdW5jdGlvbihhLCBiLCBwaXhlbHMsIG9wdHMpIHtcbiAgdmFyIHBpeGVsc19wZXJfdGljayA9IC8qKiBAdHlwZXtudW1iZXJ9ICovKG9wdHMoJ3BpeGVsc1BlckxhYmVsJykpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IEdyYW51bGFyaXR5Lk5VTV9HUkFOVUxBUklUSUVTOyBpKyspIHtcbiAgICB2YXIgbnVtX3RpY2tzID0gbnVtRGF0ZVRpY2tzKGEsIGIsIGkpO1xuICAgIGlmIChwaXhlbHMgLyBudW1fdGlja3MgPj0gcGl4ZWxzX3Blcl90aWNrKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBudW1iZXIgb2YgdGlja3Mgb24gYSBkYXRlIGF4aXMgZm9yIGEgZ2l2ZW4gZ3JhbnVsYXJpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZF90aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZ3JhbnVsYXJpdHkgKG9uZSBvZiB0aGUgZ3JhbnVsYXJpdGllcyBlbnVtZXJhdGVkIGFib3ZlKVxuICogQHJldHVybiB7bnVtYmVyfSAoQXBwcm94aW1hdGUpIG51bWJlciBvZiB0aWNrcyB0aGF0IHdvdWxkIHJlc3VsdC5cbiAqL1xudmFyIG51bURhdGVUaWNrcyA9IGZ1bmN0aW9uKHN0YXJ0X3RpbWUsIGVuZF90aW1lLCBncmFudWxhcml0eSkge1xuICB2YXIgc3BhY2luZyA9IFRJQ0tfUExBQ0VNRU5UW2dyYW51bGFyaXR5XS5zcGFjaW5nO1xuICByZXR1cm4gTWF0aC5yb3VuZCgxLjAgKiAoZW5kX3RpbWUgLSBzdGFydF90aW1lKSAvIHNwYWNpbmcpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwb3NpdGlvbnMgYW5kIGxhYmVscyBvZiB0aWNrcyBvbiBhIGRhdGUgYXhpcyBmb3IgYSBnaXZlbiBncmFudWxhcml0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydF90aW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kX3RpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBncmFudWxhcml0eSAob25lIG9mIHRoZSBncmFudWxhcml0aWVzIGVudW1lcmF0ZWQgYWJvdmUpXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6Kn0gb3B0cyBGdW5jdGlvbiBtYXBwaW5nIGZyb20gb3B0aW9uIG5hbWUgLSZndDsgdmFsdWUuXG4gKiBAcGFyYW0ge0R5Z3JhcGg9fSBkZ1xuICogQHJldHVybiB7IVRpY2tMaXN0fVxuICovXG5leHBvcnQgdmFyIGdldERhdGVBeGlzID0gZnVuY3Rpb24oc3RhcnRfdGltZSwgZW5kX3RpbWUsIGdyYW51bGFyaXR5LCBvcHRzLCBkZykge1xuICB2YXIgZm9ybWF0dGVyID0gLyoqIEB0eXBle0F4aXNMYWJlbEZvcm1hdHRlcn0gKi8oXG4gICAgICBvcHRzKFwiYXhpc0xhYmVsRm9ybWF0dGVyXCIpKTtcbiAgdmFyIHV0YyA9IG9wdHMoXCJsYWJlbHNVVENcIik7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyB1dGlscy5EYXRlQWNjZXNzb3JzVVRDIDogdXRpbHMuRGF0ZUFjY2Vzc29yc0xvY2FsO1xuXG4gIHZhciBkYXRlZmllbGQgPSBUSUNLX1BMQUNFTUVOVFtncmFudWxhcml0eV0uZGF0ZWZpZWxkO1xuICB2YXIgc3RlcCA9IFRJQ0tfUExBQ0VNRU5UW2dyYW51bGFyaXR5XS5zdGVwO1xuICB2YXIgc3BhY2luZyA9IFRJQ0tfUExBQ0VNRU5UW2dyYW51bGFyaXR5XS5zcGFjaW5nO1xuXG4gIC8vIENob29zZSBhIG5pY2UgdGljayBwb3NpdGlvbiBiZWZvcmUgdGhlIGluaXRpYWwgaW5zdGFudC5cbiAgLy8gQ3VycmVudGx5LCB0aGlzIGNvZGUgZGVhbHMgcHJvcGVybHkgd2l0aCB0aGUgZXhpc3RlbnQgZGFpbHkgZ3JhbnVsYXJpdGllczpcbiAgLy8gREFJTFkgKHdpdGggc3RlcCBvZiAxKSBhbmQgV0VFS0xZICh3aXRoIHN0ZXAgb2YgNyBidXQgc3BlY2lhbGx5IGhhbmRsZWQpLlxuICAvLyBPdGhlciBkYWlseSBncmFudWxhcml0aWVzIChzYXkgVFdPX0RBSUxZKSBzaG91bGQgYWxzbyBiZSBoYW5kbGVkIHNwZWNpYWxseVxuICAvLyBieSBzZXR0aW5nIHRoZSBzdGFydF9kYXRlX29mZnNldCB0byAwLlxuICB2YXIgc3RhcnRfZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0X3RpbWUpO1xuICB2YXIgZGF0ZV9hcnJheSA9IFtdO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfWV0gID0gYWNjZXNzb3JzLmdldEZ1bGxZZWFyKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfTV0gID0gYWNjZXNzb3JzLmdldE1vbnRoKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfRF0gID0gYWNjZXNzb3JzLmdldERhdGUoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9ISF0gPSBhY2Nlc3NvcnMuZ2V0SG91cnMoc3RhcnRfZGF0ZSk7XG4gIGRhdGVfYXJyYXlbRGF0ZUZpZWxkLkRBVEVGSUVMRF9NTV0gPSBhY2Nlc3NvcnMuZ2V0TWludXRlcyhzdGFydF9kYXRlKTtcbiAgZGF0ZV9hcnJheVtEYXRlRmllbGQuREFURUZJRUxEX1NTXSA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKHN0YXJ0X2RhdGUpO1xuICBkYXRlX2FycmF5W0RhdGVGaWVsZC5EQVRFRklFTERfTVNdID0gYWNjZXNzb3JzLmdldE1pbGxpc2Vjb25kcyhzdGFydF9kYXRlKTtcblxuICB2YXIgc3RhcnRfZGF0ZV9vZmZzZXQgPSBkYXRlX2FycmF5W2RhdGVmaWVsZF0gJSBzdGVwO1xuICBpZiAoZ3JhbnVsYXJpdHkgPT0gR3JhbnVsYXJpdHkuV0VFS0xZKSB7XG4gICAgLy8gVGhpcyB3aWxsIHB1dCB0aGUgdGlja3Mgb24gU3VuZGF5cy5cbiAgICBzdGFydF9kYXRlX29mZnNldCA9IGFjY2Vzc29ycy5nZXREYXkoc3RhcnRfZGF0ZSk7XG4gIH1cbiAgXG4gIGRhdGVfYXJyYXlbZGF0ZWZpZWxkXSAtPSBzdGFydF9kYXRlX29mZnNldDtcbiAgZm9yICh2YXIgZGYgPSBkYXRlZmllbGQgKyAxOyBkZiA8IERhdGVGaWVsZC5OVU1fREFURUZJRUxEUzsgZGYrKykge1xuICAgIC8vIFRoZSBtaW5pbXVtIHZhbHVlIGlzIDEgZm9yIHRoZSBkYXkgb2YgbW9udGgsIGFuZCAwIGZvciBhbGwgb3RoZXIgZmllbGRzLlxuICAgIGRhdGVfYXJyYXlbZGZdID0gKGRmID09PSBEYXRlRmllbGQuREFURUZJRUxEX0QpID8gMSA6IDA7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSB0aGUgdGlja3MuXG4gIC8vIEZvciBncmFudWxhcml0aWVzIG5vdCBjb2Fyc2VyIHRoYW4gSE9VUkxZIHdlIHVzZSB0aGUgZmFjdCB0aGF0OlxuICAvLyAgIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJldHdlZW4gdGlja3MgaXMgY29uc3RhbnRcbiAgLy8gICBhbmQgZXF1YWwgdG8gdGhlIGRlZmluZWQgc3BhY2luZy5cbiAgLy8gT3RoZXJ3aXNlIHdlIHJlbHkgb24gdGhlICdyb2xsIG92ZXInIHByb3BlcnR5IG9mIHRoZSBEYXRlIGZ1bmN0aW9uczpcbiAgLy8gICB3aGVuIHNvbWUgZGF0ZSBmaWVsZCBpcyBzZXQgdG8gYSB2YWx1ZSBvdXRzaWRlIG9mIGl0cyBsb2dpY2FsIHJhbmdlLFxuICAvLyAgIHRoZSBleGNlc3MgJ3JvbGxzIG92ZXInIHRoZSBuZXh0IChtb3JlIHNpZ25pZmljYW50KSBmaWVsZC5cbiAgLy8gSG93ZXZlciwgd2hlbiB1c2luZyBsb2NhbCB0aW1lIHdpdGggRFNUIHRyYW5zaXRpb25zLFxuICAvLyB0aGVyZSBhcmUgZGF0ZXMgdGhhdCBkbyBub3QgcmVwcmVzZW50IGFueSB0aW1lIHZhbHVlIGF0IGFsbFxuICAvLyAodGhvc2UgaW4gdGhlIGhvdXIgc2tpcHBlZCBhdCB0aGUgJ3NwcmluZyBmb3J3YXJkJyksXG4gIC8vIGFuZCB0aGUgSmF2YVNjcmlwdCBlbmdpbmVzIHVzdWFsbHkgcmV0dXJuIGFuIGVxdWl2YWxlbnQgdmFsdWUuXG4gIC8vIEhlbmNlIHdlIGhhdmUgdG8gY2hlY2sgdGhhdCB0aGUgZGF0ZSBpcyBwcm9wZXJseSBpbmNyZWFzZWQgYXQgZWFjaCBzdGVwLFxuICAvLyByZXR1cm5pbmcgYSBkYXRlIGF0IGEgbmljZSB0aWNrIHBvc2l0aW9uLlxuICB2YXIgdGlja3MgPSBbXTtcbiAgdmFyIHRpY2tfZGF0ZSA9IGFjY2Vzc29ycy5tYWtlRGF0ZS5hcHBseShudWxsLCBkYXRlX2FycmF5KTtcbiAgdmFyIHRpY2tfdGltZSA9IHRpY2tfZGF0ZS5nZXRUaW1lKCk7XG4gIGlmIChncmFudWxhcml0eSA8PSBHcmFudWxhcml0eS5IT1VSTFkpIHtcbiAgICBpZiAodGlja190aW1lIDwgc3RhcnRfdGltZSkge1xuICAgICAgdGlja190aW1lICs9IHNwYWNpbmc7XG4gICAgICB0aWNrX2RhdGUgPSBuZXcgRGF0ZSh0aWNrX3RpbWUpO1xuICAgIH1cbiAgICB3aGlsZSAodGlja190aW1lIDw9IGVuZF90aW1lKSB7XG4gICAgICB0aWNrcy5wdXNoKHsgdjogdGlja190aW1lLFxuICAgICAgICAgICAgICAgICAgIGxhYmVsOiBmb3JtYXR0ZXIuY2FsbChkZywgdGlja19kYXRlLCBncmFudWxhcml0eSwgb3B0cywgZGcpXG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgdGlja190aW1lICs9IHNwYWNpbmc7XG4gICAgICB0aWNrX2RhdGUgPSBuZXcgRGF0ZSh0aWNrX3RpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGlja190aW1lIDwgc3RhcnRfdGltZSkge1xuICAgICAgZGF0ZV9hcnJheVtkYXRlZmllbGRdICs9IHN0ZXA7XG4gICAgICB0aWNrX2RhdGUgPSBhY2Nlc3NvcnMubWFrZURhdGUuYXBwbHkobnVsbCwgZGF0ZV9hcnJheSk7XG4gICAgICB0aWNrX3RpbWUgPSB0aWNrX2RhdGUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICB3aGlsZSAodGlja190aW1lIDw9IGVuZF90aW1lKSB7XG4gICAgICBpZiAoZ3JhbnVsYXJpdHkgPj0gR3JhbnVsYXJpdHkuREFJTFkgfHxcbiAgICAgICAgICBhY2Nlc3NvcnMuZ2V0SG91cnModGlja19kYXRlKSAlIHN0ZXAgPT09IDApIHtcbiAgICAgICAgdGlja3MucHVzaCh7IHY6IHRpY2tfdGltZSxcbiAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBmb3JtYXR0ZXIuY2FsbChkZywgdGlja19kYXRlLCBncmFudWxhcml0eSwgb3B0cywgZGcpXG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkYXRlX2FycmF5W2RhdGVmaWVsZF0gKz0gc3RlcDtcbiAgICAgIHRpY2tfZGF0ZSA9IGFjY2Vzc29ycy5tYWtlRGF0ZS5hcHBseShudWxsLCBkYXRlX2FycmF5KTtcbiAgICAgIHRpY2tfdGltZSA9IHRpY2tfZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSBkeWdyYXBocy4gVGhlc2VcbiAqIGFyZSB0eXBpY2FsbHkgc3RhdGljIChpLmUuIG5vdCByZWxhdGVkIHRvIGFueSBwYXJ0aWN1bGFyIGR5Z3JhcGgpLiBFeGFtcGxlc1xuICogaW5jbHVkZSBkYXRlL3RpbWUgZm9ybWF0dGluZyBmdW5jdGlvbnMsIGJhc2ljIGFsZ29yaXRobXMgKGUuZy4gYmluYXJ5XG4gKiBzZWFyY2gpIGFuZCBnZW5lcmljIERPTS1tYW5pcHVsYXRpb24gZnVuY3Rpb25zLlxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UsIE5vZGU6ZmFsc2UgKi9cblwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgKiBhcyBEeWdyYXBoVGlja2VycyBmcm9tICcuL2R5Z3JhcGgtdGlja2Vycyc7XG5cbmV4cG9ydCB2YXIgTE9HX1NDQUxFID0gMTA7XG5leHBvcnQgdmFyIExOX1RFTiA9IE1hdGgubG9nKExPR19TQ0FMRSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nMTAgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAvIExOX1RFTjtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByMFxuICogQHBhcmFtIHtudW1iZXJ9IHIxXG4gKiBAcGFyYW0ge251bWJlcn0gcGN0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgbG9nUmFuZ2VGcmFjdGlvbiA9IGZ1bmN0aW9uKHIwLCByMSwgcGN0KSB7XG4gIC8vIENvbXB1dGluZyB0aGUgaW52ZXJzZSBvZiB0b1BlcmNlbnRYQ29vcmQuIFRoZSBmdW5jdGlvbiB3YXMgYXJyaXZlZCBhdCB3aXRoXG4gIC8vIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gIC8vXG4gIC8vIE9yaWdpbmFsIGNhbGN1YXRpb246XG4gIC8vIHBjdCA9IChsb2coeCkgLSBsb2coeFJhbmdlWzBdKSkgLyAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkpO1xuICAvL1xuICAvLyBNdWx0aXBseSBib3RoIHNpZGVzIGJ5IHRoZSByaWdodC1zaWRlIGRlbW9uaW5hdG9yLlxuICAvLyBwY3QgKiAobG9nKHhSYW5nZVsxXSAtIGxvZyh4UmFuZ2VbMF0pKSkgPSBsb2coeCkgLSBsb2coeFJhbmdlWzBdKVxuICAvL1xuICAvLyBhZGQgbG9nKHhSYW5nZVswXSkgdG8gYm90aCBzaWRlc1xuICAvLyBsb2coeFJhbmdlWzBdKSArIChwY3QgKiAobG9nKHhSYW5nZVsxXSkgLSBsb2coeFJhbmdlWzBdKSkgPSBsb2coeCk7XG4gIC8vXG4gIC8vIFN3YXAgYm90aCBzaWRlcyBvZiB0aGUgZXF1YXRpb24sXG4gIC8vIGxvZyh4KSA9IGxvZyh4UmFuZ2VbMF0pICsgKHBjdCAqIChsb2coeFJhbmdlWzFdKSAtIGxvZyh4UmFuZ2VbMF0pKVxuICAvL1xuICAvLyBVc2UgYm90aCBzaWRlcyBhcyB0aGUgZXhwb25lbnQgaW4gMTBeZXhwIGFuZCB3ZSdyZSBkb25lLlxuICAvLyB4ID0gMTAgXiAobG9nKHhSYW5nZVswXSkgKyAocGN0ICogKGxvZyh4UmFuZ2VbMV0pIC0gbG9nKHhSYW5nZVswXSkpKVxuXG4gIHZhciBsb2dyMCA9IGxvZzEwKHIwKTtcbiAgdmFyIGxvZ3IxID0gbG9nMTAocjEpO1xuICB2YXIgZXhwb25lbnQgPSBsb2dyMCArIChwY3QgKiAobG9ncjEgLSBsb2dyMCkpO1xuICB2YXIgdmFsdWUgPSBNYXRoLnBvdyhMT0dfU0NBTEUsIGV4cG9uZW50KTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqIEEgZG90dGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVFRFRF9MSU5FID0gWzIsIDJdO1xuLyoqIEEgZGFzaGVkIGxpbmUgc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERBU0hFRF9MSU5FID0gWzcsIDNdO1xuLyoqIEEgZG90IGRhc2ggc3Ryb2tlIHBhdHRlcm4uICovXG5leHBvcnQgdmFyIERPVF9EQVNIX0xJTkUgPSBbNywgMiwgMiwgMl07XG5cbi8vIERpcmVjdGlvbnMgZm9yIHBhbm5pbmcgYW5kIHpvb21pbmcuIFVzZSBiaXQgb3BlcmF0aW9ucyB3aGVuIGNvbWJpbmVkXG4vLyB2YWx1ZXMgYXJlIHBvc3NpYmxlLlxuZXhwb3J0IHZhciBIT1JJWk9OVEFMID0gMTtcbmV4cG9ydCB2YXIgVkVSVElDQUwgPSAyO1xuXG4vKipcbiAqIFJldHVybiB0aGUgMmQgY29udGV4dCBmb3IgYSBkeWdyYXBoIGNhbnZhcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGV4cG9zZWQgZm9yIHRoZSBzYWtlIG9mIHJlcGxhY2luZyB0aGUgZnVuY3Rpb24gaW5cbiAqIGF1dG9tYXRlZCB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0geyFIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcmV0dXJuIHshQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIHJldHVybiAvKiogQHR5cGV7IUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0qLyhjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2Vtb3ZlJy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQpOihib29sZWFufHVuZGVmaW5lZCl9IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgb24gdGhlIGV2ZW50LiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlcjogdGhlIGV2ZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbiBhZGRFdmVudChlbGVtLCB0eXBlLCBmbikge1xuICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgZXZlbnQgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW1vdmUnLlxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCk6KGJvb2xlYW58dW5kZWZpbmVkKX0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAqICAgICBvbiB0aGUgZXZlbnQuIFRoZSBmdW5jdGlvbiB0YWtlcyBvbmUgcGFyYW1ldGVyOiB0aGUgZXZlbnQgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZm4pIHtcbiAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIENhbmNlbHMgZnVydGhlciBwcm9jZXNzaW5nIG9mIGFuIGV2ZW50LiBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGRlZmF1bHRcbiAqIGJyb3dzZXIgYWN0aW9ucywgZS5nLiBoaWdobGlnaHRpbmcgdGV4dCBvbiBhIGRvdWJsZS1jbGljay5cbiAqIEJhc2VkIG9uIHRoZSBhcnRpY2xlIGF0XG4gKiBodHRwOi8vd3d3LnN3aXRjaG9udGhlY29kZS5jb20vdHV0b3JpYWxzL2phdmFzY3JpcHQtdHV0b3JpYWwtdGhlLXNjcm9sbC13aGVlbFxuICogQHBhcmFtIHshRXZlbnR9IGUgVGhlIGV2ZW50IHdob3NlIG5vcm1hbCBiZWhhdmlvciBzaG91bGQgYmUgY2FuY2VsZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsRXZlbnQoZSkge1xuICBlID0gZSA/IGUgOiB3aW5kb3cuZXZlbnQ7XG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICBlLmNhbmNlbCA9IHRydWU7XG4gIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGhzdiB2YWx1ZXMgdG8gYW4gcmdiKHIsZyxiKSBzdHJpbmcuIFRha2VuIGZyb20gTW9jaGlLaXQuQ29sb3IuIFRoaXNcbiAqIGlzIHVzZWQgdG8gZ2VuZXJhdGUgZGVmYXVsdCBzZXJpZXMgY29sb3JzIHdoaWNoIGFyZSBldmVubHkgc3BhY2VkIG9uIHRoZVxuICogY29sb3Igd2hlZWwuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBodWUgUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHNhdHVyYXRpb24gUmFuZ2UgaXMgMC4wLTEuMC5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHZhbHVlIFJhbmdlIGlzIDAuMC0xLjAuXG4gKiBAcmV0dXJuIHsgc3RyaW5nIH0gXCJyZ2IocixnLGIpXCIgd2hlcmUgciwgZyBhbmQgYiByYW5nZSBmcm9tIDAtMjU1LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhzdlRvUkdCKGh1ZSwgc2F0dXJhdGlvbiwgdmFsdWUpIHtcbiAgdmFyIHJlZDtcbiAgdmFyIGdyZWVuO1xuICB2YXIgYmx1ZTtcbiAgaWYgKHNhdHVyYXRpb24gPT09IDApIHtcbiAgICByZWQgPSB2YWx1ZTtcbiAgICBncmVlbiA9IHZhbHVlO1xuICAgIGJsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoaHVlICogNik7XG4gICAgdmFyIGYgPSAoaHVlICogNikgLSBpO1xuICAgIHZhciBwID0gdmFsdWUgKiAoMSAtIHNhdHVyYXRpb24pO1xuICAgIHZhciBxID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogZikpO1xuICAgIHZhciB0ID0gdmFsdWUgKiAoMSAtIChzYXR1cmF0aW9uICogKDEgLSBmKSkpO1xuICAgIHN3aXRjaCAoaSkge1xuICAgICAgY2FzZSAxOiByZWQgPSBxOyBncmVlbiA9IHZhbHVlOyBibHVlID0gcDsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHJlZCA9IHA7IGdyZWVuID0gdmFsdWU7IGJsdWUgPSB0OyBicmVhaztcbiAgICAgIGNhc2UgMzogcmVkID0gcDsgZ3JlZW4gPSBxOyBibHVlID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSA0OiByZWQgPSB0OyBncmVlbiA9IHA7IGJsdWUgPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDU6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHA7IGJsdWUgPSBxOyBicmVhaztcbiAgICAgIGNhc2UgNjogLy8gZmFsbCB0aHJvdWdoXG4gICAgICBjYXNlIDA6IHJlZCA9IHZhbHVlOyBncmVlbiA9IHQ7IGJsdWUgPSBwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmVkID0gTWF0aC5mbG9vcigyNTUgKiByZWQgKyAwLjUpO1xuICBncmVlbiA9IE1hdGguZmxvb3IoMjU1ICogZ3JlZW4gKyAwLjUpO1xuICBibHVlID0gTWF0aC5mbG9vcigyNTUgKiBibHVlICsgMC41KTtcbiAgcmV0dXJuICdyZ2IoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcpJztcbn07XG5cbi8qKlxuICogRmluZCB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBvZiB0aGUgcGFnZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG9ialxuICogQHJldHVybiB7e3g6bnVtYmVyLHk6bnVtYmVyfX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUG9zKG9iaikge1xuICB2YXIgcCA9IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHcgPSB3aW5kb3csXG4gICAgICBkID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHJldHVybiB7XG4gICAgeDogcC5sZWZ0ICsgKHcucGFnZVhPZmZzZXQgfHwgZC5zY3JvbGxMZWZ0KSxcbiAgICB5OiBwLnRvcCAgKyAody5wYWdlWU9mZnNldCB8fCBkLnNjcm9sbFRvcClcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlcmUgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIHBhZ2UgKG5vdCB0aGUgd2luZG93KSBpcyAoMCwwKS5cbiAqIFRha2VuIGZyb20gTW9jaGlLaXQuU2lnbmFsXG4gKiBAcGFyYW0geyFFdmVudH0gZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VYKGUpIHtcbiAgcmV0dXJuICghZS5wYWdlWCB8fCBlLnBhZ2VYIDwgMCkgPyAwIDogZS5wYWdlWDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBldmVudCBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIHdoZXJlIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBwYWdlIChub3QgdGhlIHdpbmRvdykgaXMgKDAsMCkuXG4gKiBUYWtlbiBmcm9tIE1vY2hpS2l0LlNpZ25hbFxuICogQHBhcmFtIHshRXZlbnR9IGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWdlWShlKSB7XG4gIHJldHVybiAoIWUucGFnZVkgfHwgZS5wYWdlWSA8IDApID8gMCA6IGUucGFnZVk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHBhZ2UgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgdG8gcGl4ZWwgeC1jb29yZGluYXRlcyBvbiB0aGVcbiAqIGNhbnZhcyAoaS5lLiBET00gQ29vcmRzKS5cbiAqIEBwYXJhbSB7IUV2ZW50fSBlIERyYWcgZXZlbnQuXG4gKiBAcGFyYW0geyFEeWdyYXBoSW50ZXJhY3Rpb25Db250ZXh0fSBjb250ZXh0IEludGVyYWN0aW9uIGNvbnRleHQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBkcmFnIGhhcyBtb3ZlZCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmFnR2V0WF8oZSwgY29udGV4dCkge1xuICByZXR1cm4gcGFnZVgoZSkgLSBjb250ZXh0LnB4O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBwYWdlIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IHRvIHBpeGVsIHktY29vcmRpbmF0ZXMgb24gdGhlXG4gKiBjYW52YXMgKGkuZS4gRE9NIENvb3JkcykuXG4gKiBAcGFyYW0geyFFdmVudH0gZSBEcmFnIGV2ZW50LlxuICogQHBhcmFtIHshRHlncmFwaEludGVyYWN0aW9uQ29udGV4dH0gY29udGV4dCBJbnRlcmFjdGlvbiBjb250ZXh0IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZHJhZyBoYXMgbW92ZWQgZG93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYWdHZXRZXyhlLCBjb250ZXh0KSB7XG4gIHJldHVybiBwYWdlWShlKSAtIGNvbnRleHQucHk7XG59O1xuXG4vKipcbiAqIFRoaXMgcmV0dXJucyB0cnVlIHVubGVzcyB0aGUgcGFyYW1ldGVyIGlzIDAsIG51bGwsIHVuZGVmaW5lZCBvciBOYU4uXG4gKiBUT0RPKGRhbnZrKTogcmVuYW1lIHRoaXMgZnVuY3Rpb24gdG8gc29tZXRoaW5nIGxpa2UgJ2lzTm9uWmVyb05hbicuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG51bWJlciB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG51bWJlciBpcyB6ZXJvIG9yIE5hTi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09LKHgpIHtcbiAgcmV0dXJuICEheCAmJiAhaXNOYU4oeCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7e3g6P251bWJlcix5Oj9udW1iZXIseXZhbDo/bnVtYmVyfX0gcCBUaGUgcG9pbnQgdG8gY29uc2lkZXIsIHZhbGlkXG4gKiAgICAgcG9pbnRzIGFyZSB7eCwgeX0gb2JqZWN0c1xuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2FsbG93TmFOWSBUcmVhdCBwb2ludCB3aXRoIHk9TmFOIGFzIHZhbGlkXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb2ludCBoYXMgbnVtZXJpYyB4IGFuZCB5LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQb2ludChwLCBvcHRfYWxsb3dOYU5ZKSB7XG4gIGlmICghcCkgcmV0dXJuIGZhbHNlOyAgLy8gbnVsbCBvciB1bmRlZmluZWQgb2JqZWN0XG4gIGlmIChwLnl2YWwgPT09IG51bGwpIHJldHVybiBmYWxzZTsgIC8vIG1pc3NpbmcgcG9pbnRcbiAgaWYgKHAueCA9PT0gbnVsbCB8fCBwLnggPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocC55ID09PSBudWxsIHx8IHAueSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpc05hTihwLngpIHx8ICghb3B0X2FsbG93TmFOWSAmJiBpc05hTihwLnkpKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogTnVtYmVyIGZvcm1hdHRpbmcgZnVuY3Rpb24gd2hpY2ggbWltaWNrcyB0aGUgYmVoYXZpb3Igb2YgJWcgaW4gcHJpbnRmLCBpLmUuXG4gKiBlaXRoZXIgZXhwb25lbnRpYWwgb3IgZml4ZWQgZm9ybWF0ICh3aXRob3V0IHRyYWlsaW5nIDBzKSBpcyB1c2VkIGRlcGVuZGluZyBvblxuICogdGhlIGxlbmd0aCBvZiB0aGUgZ2VuZXJhdGVkIHN0cmluZy4gIFRoZSBhZHZhbnRhZ2Ugb2YgdGhpcyBmb3JtYXQgaXMgdGhhdFxuICogdGhlcmUgaXMgYSBwcmVkaWN0YWJsZSB1cHBlciBib3VuZCBvbiB0aGUgcmVzdWx0aW5nIHN0cmluZyBsZW5ndGgsXG4gKiBzaWduaWZpY2FudCBmaWd1cmVzIGFyZSBub3QgZHJvcHBlZCwgYW5kIG5vcm1hbCBudW1iZXJzIGFyZSBub3QgZGlzcGxheWVkIGluXG4gKiBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAqXG4gKiBOT1RFOiBKYXZhU2NyaXB0J3MgbmF0aXZlIHRvUHJlY2lzaW9uKCkgaXMgTk9UIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgJWcuXG4gKiBJdCBjcmVhdGVzIHN0cmluZ3Mgd2hpY2ggYXJlIHRvbyBsb25nIGZvciBhYnNvbHV0ZSB2YWx1ZXMgYmV0d2VlbiAxMF4tNCBhbmRcbiAqIDEwXi02LCBlLmcuICcwLjAwMDAxJyBpbnN0ZWFkIG9mICcxZS01Jy4gU2VlIHRlc3RzL251bWJlci1mb3JtYXQuaHRtbCBmb3JcbiAqIG91dHB1dCBleGFtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIHRvIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcHJlY2lzaW9uIFRoZSBwcmVjaXNpb24gdG8gdXNlLCBkZWZhdWx0IDIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIGZvcm1hdHRlZCBsaWtlICVnIGluIHByaW50Zi4gIFRoZSBtYXggZ2VuZXJhdGVkXG4gKiAgICAgICAgICAgICAgICAgIHN0cmluZyBsZW5ndGggc2hvdWxkIGJlIHByZWNpc2lvbiArIDYgKGUuZyAxLjEyM2UrMzAwKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0Rm9ybWF0KHgsIG9wdF9wcmVjaXNpb24pIHtcbiAgLy8gQXZvaWQgaW52YWxpZCBwcmVjaXNpb24gdmFsdWVzOyBbMSwgMjFdIGlzIHRoZSB2YWxpZCByYW5nZS5cbiAgdmFyIHAgPSBNYXRoLm1pbihNYXRoLm1heCgxLCBvcHRfcHJlY2lzaW9uIHx8IDIpLCAyMSk7XG5cbiAgLy8gVGhpcyBpcyBkZWNlcHRpdmVseSBzaW1wbGUuICBUaGUgYWN0dWFsIGFsZ29yaXRobSBjb21lcyBmcm9tOlxuICAvL1xuICAvLyBNYXggYWxsb3dlZCBsZW5ndGggPSBwICsgNFxuICAvLyB3aGVyZSA0IGNvbWVzIGZyb20gJ2UrbicgYW5kICcuJy5cbiAgLy9cbiAgLy8gTGVuZ3RoIG9mIGZpeGVkIGZvcm1hdCA9IDIgKyB5ICsgcFxuICAvLyB3aGVyZSAyIGNvbWVzIGZyb20gJzAuJyBhbmQgeSA9ICMgb2YgbGVhZGluZyB6ZXJvZXMuXG4gIC8vXG4gIC8vIEVxdWF0aW5nIHRoZSB0d28gYW5kIHNvbHZpbmcgZm9yIHkgeWllbGRzIHkgPSAyLCBvciAwLjAweHh4eCB3aGljaCBpc1xuICAvLyAxLjBlLTMuXG4gIC8vXG4gIC8vIFNpbmNlIHRoZSBiZWhhdmlvciBvZiB0b1ByZWNpc2lvbigpIGlzIGlkZW50aWNhbCBmb3IgbGFyZ2VyIG51bWJlcnMsIHdlXG4gIC8vIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhlIG90aGVyIGJvdW5kLlxuICAvL1xuICAvLyBGaW5hbGx5LCB0aGUgYXJndW1lbnQgZm9yIHRvRXhwb25lbnRpYWwoKSBpcyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIGRpZ2l0cyxcbiAgLy8gc28gd2UgdGFrZSBvZmYgMSBmb3IgdGhlIHZhbHVlIGJlZm9yZSB0aGUgJy4nLlxuICByZXR1cm4gKE1hdGguYWJzKHgpIDwgMS4wZS0zICYmIHggIT09IDAuMCkgP1xuICAgICAgeC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9QcmVjaXNpb24ocCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzICc5JyB0byAnMDknICh1c2VmdWwgZm9yIGRhdGVzKVxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvcGFkKHgpIHtcbiAgaWYgKHggPCAxMCkgcmV0dXJuIFwiMFwiICsgeDsgZWxzZSByZXR1cm4gXCJcIiArIHg7XG59O1xuXG4vKipcbiAqIERhdGUgYWNjZXNzb3JzIHRvIGdldCB0aGUgcGFydHMgb2YgYSBjYWxlbmRhciBkYXRlICh5ZWFyLCBtb250aCxcbiAqIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQgYW5kIG1pbGxpc2Vjb25kKSBhY2NvcmRpbmcgdG8gbG9jYWwgdGltZSxcbiAqIGFuZCBmYWN0b3J5IG1ldGhvZCB0byBjYWxsIHRoZSBEYXRlIGNvbnN0cnVjdG9yIHdpdGggYW4gYXJyYXkgb2YgYXJndW1lbnRzLlxuICovXG5leHBvcnQgdmFyIERhdGVBY2Nlc3NvcnNMb2NhbCA9IHtcbiAgZ2V0RnVsbFllYXI6ICAgICBkID0+IGQuZ2V0RnVsbFllYXIoKSxcbiAgZ2V0TW9udGg6ICAgICAgICBkID0+IGQuZ2V0TW9udGgoKSxcbiAgZ2V0RGF0ZTogICAgICAgICBkID0+IGQuZ2V0RGF0ZSgpLFxuICBnZXRIb3VyczogICAgICAgIGQgPT4gZC5nZXRIb3VycygpLFxuICBnZXRNaW51dGVzOiAgICAgIGQgPT4gZC5nZXRNaW51dGVzKCksXG4gIGdldFNlY29uZHM6ICAgICAgZCA9PiBkLmdldFNlY29uZHMoKSxcbiAgZ2V0TWlsbGlzZWNvbmRzOiBkID0+IGQuZ2V0TWlsbGlzZWNvbmRzKCksXG4gIGdldERheTogICAgICAgICAgZCA9PiBkLmdldERheSgpLFxuICBtYWtlRGF0ZTogICAgICAgIGZ1bmN0aW9uKHksIG0sIGQsIGhoLCBtbSwgc3MsIG1zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQsIGhoLCBtbSwgc3MsIG1zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEYXRlIGFjY2Vzc29ycyB0byBnZXQgdGhlIHBhcnRzIG9mIGEgY2FsZW5kYXIgZGF0ZSAoeWVhciwgbW9udGgsXG4gKiBkYXkgb2YgbW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIGFuZCBtaWxsaXNlY29uZCkgYWNjb3JkaW5nIHRvIFVUQyB0aW1lLFxuICogYW5kIGZhY3RvcnkgbWV0aG9kIHRvIGNhbGwgdGhlIERhdGUgY29uc3RydWN0b3Igd2l0aCBhbiBhcnJheSBvZiBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCB2YXIgRGF0ZUFjY2Vzc29yc1VUQyA9IHtcbiAgZ2V0RnVsbFllYXI6ICAgICBkID0+IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgZ2V0TW9udGg6ICAgICAgICBkID0+IGQuZ2V0VVRDTW9udGgoKSxcbiAgZ2V0RGF0ZTogICAgICAgICBkID0+IGQuZ2V0VVRDRGF0ZSgpLFxuICBnZXRIb3VyczogICAgICAgIGQgPT4gZC5nZXRVVENIb3VycygpLFxuICBnZXRNaW51dGVzOiAgICAgIGQgPT4gZC5nZXRVVENNaW51dGVzKCksXG4gIGdldFNlY29uZHM6ICAgICAgZCA9PiBkLmdldFVUQ1NlY29uZHMoKSxcbiAgZ2V0TWlsbGlzZWNvbmRzOiBkID0+IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIGdldERheTogICAgICAgICAgZCA9PiBkLmdldFVUQ0RheSgpLFxuICBtYWtlRGF0ZTogICAgICAgIGZ1bmN0aW9uKHksIG0sIGQsIGhoLCBtbSwgc3MsIG1zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHksIG0sIGQsIGhoLCBtbSwgc3MsIG1zKSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIHZlcnNpb24gb2YgdGhlIGhvdXJzLCBtaW51dGVzIGFuZCBzZWNvbmRzIHBvcnRpb24gb2YgYSBkYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGhoIFRoZSBob3VycyAoZnJvbSAwLTIzKVxuICogQHBhcmFtIHtudW1iZXJ9IG1tIFRoZSBtaW51dGVzIChmcm9tIDAtNTkpXG4gKiBAcGFyYW0ge251bWJlcn0gc3MgVGhlIHNlY29uZHMgKGZyb20gMC01OSlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSB0aW1lIG9mIHRoZSBmb3JtIFwiSEg6TU1cIiBvciBcIkhIOk1NOlNTXCJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBobXNTdHJpbmdfKGhoLCBtbSwgc3MpIHtcbiAgdmFyIHJldCA9IHplcm9wYWQoaGgpICsgXCI6XCIgKyB6ZXJvcGFkKG1tKTtcbiAgaWYgKHNzKSB7XG4gICAgcmV0ICs9IFwiOlwiICsgemVyb3BhZChzcyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIEpTIGRhdGUgKG1pbGxpcyBzaW5jZSBlcG9jaCkgdG8gYSBmb3JtYXR0ZWQgc3RyaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIEphdmFTY3JpcHQgdGltZSB2YWx1ZSAobXMgc2luY2UgZXBvY2gpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHV0YyBXZXRoZXIgb3V0cHV0IFVUQyBvciBsb2NhbCB0aW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgZGF0ZSBvZiBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gKiAgICAgXCJZWVlZL01NL0REXCIsIFwiWVlZWS9NTS9ERCBISDpNTVwiIG9yIFwiWVlZWS9NTS9ERCBISDpNTTpTU1wiXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVN0cmluZ18odGltZSwgdXRjKSB7XG4gIHZhciBhY2Nlc3NvcnMgPSB1dGMgPyBEYXRlQWNjZXNzb3JzVVRDIDogRGF0ZUFjY2Vzc29yc0xvY2FsO1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICB2YXIgeSA9IGFjY2Vzc29ycy5nZXRGdWxsWWVhcihkYXRlKTtcbiAgdmFyIG0gPSBhY2Nlc3NvcnMuZ2V0TW9udGgoZGF0ZSk7XG4gIHZhciBkID0gYWNjZXNzb3JzLmdldERhdGUoZGF0ZSk7XG4gIHZhciBoaCA9IGFjY2Vzc29ycy5nZXRIb3VycyhkYXRlKTtcbiAgdmFyIG1tID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoZGF0ZSk7XG4gIHZhciBzcyA9IGFjY2Vzc29ycy5nZXRTZWNvbmRzKGRhdGUpO1xuICAvLyBHZXQgYSB5ZWFyIHN0cmluZzpcbiAgdmFyIHllYXIgPSBcIlwiICsgeTtcbiAgLy8gR2V0IGEgMCBwYWRkZWQgbW9udGggc3RyaW5nXG4gIHZhciBtb250aCA9IHplcm9wYWQobSArIDEpOyAgLy9tb250aHMgYXJlIDAtb2Zmc2V0LCBzaWdoXG4gIC8vIEdldCBhIDAgcGFkZGVkIGRheSBzdHJpbmdcbiAgdmFyIGRheSA9IHplcm9wYWQoZCk7XG4gIHZhciBmcmFjID0gaGggKiAzNjAwICsgbW0gKiA2MCArIHNzO1xuICB2YXIgcmV0ID0geWVhciArIFwiL1wiICsgbW9udGggKyBcIi9cIiArIGRheTtcbiAgaWYgKGZyYWMpIHtcbiAgICByZXQgKz0gXCIgXCIgKyBobXNTdHJpbmdfKGhoLCBtbSwgc3MpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJvdW5kIGEgbnVtYmVyIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRpZ2l0cyBwYXN0IHRoZSBkZWNpbWFsIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gcGxhY2VzIFRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdG8gd2hpY2ggdG8gcm91bmRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRfKG51bSwgcGxhY2VzKSB7XG4gIHZhciBzaGlmdCA9IE1hdGgucG93KDEwLCBwbGFjZXMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBzaGlmdCkvc2hpZnQ7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggb3ZlciBhbiBhcnJheS5cbiAqIEN1cnJlbnRseSBkb2VzIG5vdCB3b3JrIHdoZW4gdmFsIGlzIG91dHNpZGUgdGhlIHJhbmdlIG9mIGFycnkncyB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIHRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJ5IGlzIHRoZSB2YWx1ZSBvdmVyIHdoaWNoIHRvIHNlYXJjaFxuICogQHBhcmFtIHtudW1iZXJ9IGFicyBJZiBhYnMgPiAwLCBmaW5kIHRoZSBsb3dlc3QgZW50cnkgZ3JlYXRlciB0aGFuIHZhbFxuICogICAgIElmIGFicyA8IDAsIGZpbmQgdGhlIGhpZ2hlc3QgZW50cnkgbGVzcyB0aGFuIHZhbC5cbiAqICAgICBJZiBhYnMgPT0gMCwgZmluZCB0aGUgZW50cnkgdGhhdCBlcXVhbHMgdmFsLlxuICogQHBhcmFtIHtudW1iZXI9fSBsb3cgVGhlIGZpcnN0IGluZGV4IGluIGFycnkgdG8gY29uc2lkZXIgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtudW1iZXI9fSBoaWdoIFRoZSBsYXN0IGluZGV4IGluIGFycnkgdG8gY29uc2lkZXIgKG9wdGlvbmFsKVxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleCBvZiB0aGUgZWxlbWVudCwgb3IgLTEgaWYgaXQgaXNuJ3QgZm91bmQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKHZhbCwgYXJyeSwgYWJzLCBsb3csIGhpZ2gpIHtcbiAgaWYgKGxvdyA9PT0gbnVsbCB8fCBsb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaGlnaCA9PT0gbnVsbCB8fCBoaWdoID09PSB1bmRlZmluZWQpIHtcbiAgICBsb3cgPSAwO1xuICAgIGhpZ2ggPSBhcnJ5Lmxlbmd0aCAtIDE7XG4gIH1cbiAgaWYgKGxvdyA+IGhpZ2gpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGFicyA9PT0gbnVsbCB8fCBhYnMgPT09IHVuZGVmaW5lZCkge1xuICAgIGFicyA9IDA7XG4gIH1cbiAgdmFyIHZhbGlkSW5kZXggPSBmdW5jdGlvbihpZHgpIHtcbiAgICByZXR1cm4gaWR4ID49IDAgJiYgaWR4IDwgYXJyeS5sZW5ndGg7XG4gIH07XG4gIHZhciBtaWQgPSBwYXJzZUludCgobG93ICsgaGlnaCkgLyAyLCAxMCk7XG4gIHZhciBlbGVtZW50ID0gYXJyeVttaWRdO1xuICB2YXIgaWR4O1xuICBpZiAoZWxlbWVudCA9PSB2YWwpIHtcbiAgICByZXR1cm4gbWlkO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQgPiB2YWwpIHtcbiAgICBpZiAoYWJzID4gMCkge1xuICAgICAgLy8gQWNjZXB0IGlmIGVsZW1lbnQgPiB2YWwsIGJ1dCBhbHNvIGlmIHByaW9yIGVsZW1lbnQgPCB2YWwuXG4gICAgICBpZHggPSBtaWQgLSAxO1xuICAgICAgaWYgKHZhbGlkSW5kZXgoaWR4KSAmJiBhcnJ5W2lkeF0gPCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaCh2YWwsIGFycnksIGFicywgbG93LCBtaWQgLSAxKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50IDwgdmFsKSB7XG4gICAgaWYgKGFicyA8IDApIHtcbiAgICAgIC8vIEFjY2VwdCBpZiBlbGVtZW50IDwgdmFsLCBidXQgYWxzbyBpZiBwcmlvciBlbGVtZW50ID4gdmFsLlxuICAgICAgaWR4ID0gbWlkICsgMTtcbiAgICAgIGlmICh2YWxpZEluZGV4KGlkeCkgJiYgYXJyeVtpZHhdID4gdmFsKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTZWFyY2godmFsLCBhcnJ5LCBhYnMsIG1pZCArIDEsIGhpZ2gpO1xuICB9XG4gIHJldHVybiAtMTsgIC8vIGNhbid0IGFjdHVhbGx5IGhhcHBlbiwgYnV0IG1ha2VzIGNsb3N1cmUgY29tcGlsZXIgaGFwcHlcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgZGF0ZSwgcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLiBUaGlzIGNhbiBiZVxuICogcGFzc2VkIGluIGFzIGFuIHhWYWx1ZVBhcnNlciBpbiB0aGUgRHlncmFwaCBjb25zdHJ1Y3Rvci5cbiAqIFRPRE8oZGFudmspOiBlbnVtZXJhdGUgZm9ybWF0cyB0aGF0IHRoaXMgdW5kZXJzdGFuZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGVTdHIgQSBkYXRlIGluIGEgdmFyaWV0eSBvZiBwb3NzaWJsZSBzdHJpbmcgZm9ybWF0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVQYXJzZXIoZGF0ZVN0cikge1xuICB2YXIgZGF0ZVN0clNsYXNoZWQ7XG4gIHZhciBkO1xuXG4gIC8vIExldCB0aGUgc3lzdGVtIHRyeSB0aGUgZm9ybWF0IGZpcnN0LCB3aXRoIG9uZSBjYXZlYXQ6XG4gIC8vIFlZWVktTU0tRERbIEhIOk1NOlNTXSBpcyBpbnRlcnByZXRlZCBhcyBVVEMgYnkgYSB2YXJpZXR5IG9mIGJyb3dzZXJzLlxuICAvLyBkeWdyYXBocyBkaXNwbGF5cyBkYXRlcyBpbiBsb2NhbCB0aW1lLCBzbyB0aGlzIHdpbGwgcmVzdWx0IGluIHN1cnByaXNpbmdcbiAgLy8gaW5jb25zaXN0ZW5jaWVzLiBCdXQgaWYgeW91IHNwZWNpZnkgXCJUXCIgb3IgXCJaXCIgKGkuZS4gWVlZWS1NTS1ERFRISDpNTTpTUyksXG4gIC8vIHRoZW4geW91IHByb2JhYmx5IGtub3cgd2hhdCB5b3UncmUgZG9pbmcsIHNvIHdlJ2xsIGxldCB5b3UgZ28gYWhlYWQuXG4gIC8vIElzc3VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZHlncmFwaHMvaXNzdWVzL2RldGFpbD9pZD0yNTVcbiAgaWYgKGRhdGVTdHIuc2VhcmNoKFwiLVwiKSA9PSAtMSB8fFxuICAgICAgZGF0ZVN0ci5zZWFyY2goXCJUXCIpICE9IC0xIHx8IGRhdGVTdHIuc2VhcmNoKFwiWlwiKSAhPSAtMSkge1xuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0cik7XG4gICAgaWYgKGQgJiYgIWlzTmFOKGQpKSByZXR1cm4gZDtcbiAgfVxuXG4gIGlmIChkYXRlU3RyLnNlYXJjaChcIi1cIikgIT0gLTEpIHsgIC8vIGUuZy4gJzIwMDktNy0xMicgb3IgJzIwMDktMDctMTInXG4gICAgZGF0ZVN0clNsYXNoZWQgPSBkYXRlU3RyLnJlcGxhY2UoXCItXCIsIFwiL1wiLCBcImdcIik7XG4gICAgd2hpbGUgKGRhdGVTdHJTbGFzaGVkLnNlYXJjaChcIi1cIikgIT0gLTEpIHtcbiAgICAgIGRhdGVTdHJTbGFzaGVkID0gZGF0ZVN0clNsYXNoZWQucmVwbGFjZShcIi1cIiwgXCIvXCIpO1xuICAgIH1cbiAgICBkID0gZGF0ZVN0clRvTWlsbGlzKGRhdGVTdHJTbGFzaGVkKTtcbiAgfSBlbHNlIGlmIChkYXRlU3RyLmxlbmd0aCA9PSA4KSB7ICAvLyBlLmcuICcyMDA5MDcxMidcbiAgICAvLyBUT0RPKGRhbnZrKTogcmVtb3ZlIHN1cHBvcnQgZm9yIHRoaXMgZm9ybWF0LiBJdCdzIGNvbmZ1c2luZy5cbiAgICBkYXRlU3RyU2xhc2hlZCA9IGRhdGVTdHIuc3Vic3RyKDAsNCkgKyBcIi9cIiArIGRhdGVTdHIuc3Vic3RyKDQsMikgKyBcIi9cIiArXG4gICAgICAgIGRhdGVTdHIuc3Vic3RyKDYsMik7XG4gICAgZCA9IGRhdGVTdHJUb01pbGxpcyhkYXRlU3RyU2xhc2hlZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQW55IGZvcm1hdCB0aGF0IERhdGUucGFyc2Ugd2lsbCBhY2NlcHQsIGUuZy4gXCIyMDA5LzA3LzEyXCIgb3JcbiAgICAvLyBcIjIwMDkvMDcvMTIgMTI6MzQ6NTZcIlxuICAgIGQgPSBkYXRlU3RyVG9NaWxsaXMoZGF0ZVN0cik7XG4gIH1cblxuICBpZiAoIWQgfHwgaXNOYU4oZCkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgcGFyc2UgXCIgKyBkYXRlU3RyICsgXCIgYXMgYSBkYXRlXCIpO1xuICB9XG4gIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gRGF0ZS5wYXJzZSgpIG1ldGhvZCwgZXhjZXB0IHRoYXRcbiAqIGl0IGRvZXNuJ3QgZ2V0IHJlcGxhY2VkIHdpdGggYW4gaW5jb21wYXRpYmxlIG1ldGhvZCBieSBhZ2dyZXNzaXZlIEpTXG4gKiBsaWJyYXJpZXMgbGlrZSBNb29Ub29scyBvciBKb29tbGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBkYXRlIHN0cmluZywgZS5nLiBcIjIwMTEvMDUvMDZcIlxuICogQHJldHVybiB7bnVtYmVyfSBtaWxsaXMgc2luY2UgZXBvY2hcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlU3RyVG9NaWxsaXMoc3RyKSB7XG4gIHJldHVybiBuZXcgRGF0ZShzdHIpLmdldFRpbWUoKTtcbn07XG5cbi8vIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxsIGJhc2VkIG9uIE1vY2hpS2l0LlxuLyoqXG4gKiBDb3BpZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gbyB0byBzZWxmLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gc2VsZlxuICogQHBhcmFtIHshT2JqZWN0fSBvXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlKHNlbGYsIG8pIHtcbiAgaWYgKHR5cGVvZihvKSAhPSAndW5kZWZpbmVkJyAmJiBvICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBzZWxmW2tdID0gb1trXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIENvcGllcyBhbGwgdGhlIHByb3BlcnRpZXMgZnJvbSBvIHRvIHNlbGYuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBzZWxmXG4gKiBAcGFyYW0geyFPYmplY3R9IG9cbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRGVlcChzZWxmLCBvKSB7XG4gIC8vIFRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODQyODYvamF2YXNjcmlwdC1pc2RvbS1ob3ctZG8teW91LWNoZWNrLWlmLWEtamF2YXNjcmlwdC1vYmplY3QtaXMtYS1kb20tb2JqZWN0XG4gIGZ1bmN0aW9uIGlzTm9kZShvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBOb2RlID09PSBcIm9iamVjdFwiID8gbyBpbnN0YW5jZW9mIE5vZGUgOlxuICAgICAgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG8ubm9kZVR5cGUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG8ubm9kZU5hbWU9PT1cInN0cmluZ1wiXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YobykgIT0gJ3VuZGVmaW5lZCcgJiYgbyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgaWYgKG9ba10gPT09IG51bGwpIHtcbiAgICAgICAgICBzZWxmW2tdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShvW2tdKSkge1xuICAgICAgICAgIHNlbGZba10gPSBvW2tdLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKG9ba10pKSB7XG4gICAgICAgICAgLy8gRE9NIG9iamVjdHMgYXJlIHNoYWxsb3dseS1jb3BpZWQuXG4gICAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKG9ba10pID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZihzZWxmW2tdKSAhPSAnb2JqZWN0JyB8fCBzZWxmW2tdID09PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmW2tdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZURlZXAoc2VsZltrXSwgb1trXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZltrXSA9IG9ba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGlrZShvKSB7XG4gIHZhciB0eXAgPSB0eXBlb2Yobyk7XG4gIGlmIChcbiAgICAgICh0eXAgIT0gJ29iamVjdCcgJiYgISh0eXAgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2Yoby5pdGVtKSA9PSAnZnVuY3Rpb24nKSkgfHxcbiAgICAgIG8gPT09IG51bGwgfHxcbiAgICAgIHR5cGVvZihvLmxlbmd0aCkgIT0gJ251bWJlcicgfHxcbiAgICAgIG8ubm9kZVR5cGUgPT09IDNcbiAgICAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVMaWtlKG8pIHtcbiAgaWYgKHR5cGVvZihvKSAhPSBcIm9iamVjdFwiIHx8IG8gPT09IG51bGwgfHxcbiAgICAgIHR5cGVvZihvLmdldFRpbWUpICE9ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE5vdGU6IHRoaXMgb25seSBzZWVtcyB0byB3b3JrIGZvciBhcnJheXMuXG4gKiBAcGFyYW0geyFBcnJheX0gb1xuICogQHJldHVybiB7IUFycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKG8pIHtcbiAgLy8gVE9ETyhkYW52ayk6IGZpZ3VyZSBvdXQgaG93IE1vY2hpS2l0J3MgdmVyc2lvbiB3b3Jrc1xuICB2YXIgciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNBcnJheUxpa2Uob1tpXSkpIHtcbiAgICAgIHIucHVzaChjbG9uZShvW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucHVzaChvW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjYW52YXMgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHshSFRNTENhbnZhc0VsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQncyBwaXhlbCByYXRpbywgd2hpY2ggaXMgdGhlIHJhdGlvIGJldHdlZW4gdGhlIGRldmljZVxuICogcGl4ZWwgcmF0aW8gYW5kIHRoZSBiYWNraW5nIHN0b3JlIHJhdGlvLiBUeXBpY2FsbHkgdGhpcyBpcyAxIGZvciBjb252ZW50aW9uYWxcbiAqIGRpc3BsYXlzLCBhbmQgPiAxIGZvciBIaURQSSBkaXNwbGF5cyAoc3VjaCBhcyB0aGUgUmV0aW5hIE1CUCkuXG4gKiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2hpZHBpLyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSB7IUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY2FudmFzJ3MgMmQgY29udGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJhdGlvIG9mIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8gYW5kIHRoZSBiYWNraW5nIHN0b3JlXG4gKiByYXRpbyBmb3IgdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dFBpeGVsUmF0aW8oY29udGV4dCkge1xuICB0cnkge1xuICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZGV2aWNlUGl4ZWxSYXRpbyBtdXN0IGJlIGRlZmluZWQgZm9yIHRoaXMgcmF0aW8gdG8gbWFrZSBzZW5zZS5cbiAgICAgIC8vIFdlIGRlZmF1bHQgYmFja2luZ1N0b3JlUmF0aW8gdG8gMTogdGhpcyBkb2VzIG5vdCBleGlzdCBvbiBzb21lIGJyb3dzZXJzXG4gICAgICAvLyAoaS5lLiBkZXNrdG9wIENocm9tZSkuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBpcyBvbiBhbiBBbmRyb2lkIGJyb3dzZXIuXG4gKiBBbmRyb2lkIGRvZXMgbm90IGZ1bGx5IHN1cHBvcnQgdGhlIDxjYW52YXM+IHRhZywgZS5nLiB3L3IvdC8gY2xpcHBpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgcmV0dXJuICgvQW5kcm9pZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuXG5cbi8qKlxuICogVE9ETyhkYW52ayk6IHVzZSBAdGVtcGxhdGUgaGVyZSB3aGVuIGl0J3MgYmV0dGVyIHN1cHBvcnRlZCBmb3IgY2xhc3Nlcy5cbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFBcnJheSw/KTpib29sZWFuPX0gcHJlZGljYXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBwcmVkaWNhdGUpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZW5ndGggPSBsZW5ndGggfHwgYXJyYXkubGVuZ3RoO1xuICB0aGlzLmhhc05leHQgPSB0cnVlOyAvLyBVc2UgdG8gaWRlbnRpZnkgaWYgdGhlcmUncyBhbm90aGVyIGVsZW1lbnQuXG4gIHRoaXMucGVlayA9IG51bGw7IC8vIFVzZSBmb3IgbG9vay1haGVhZFxuICB0aGlzLnN0YXJ0XyA9IHN0YXJ0O1xuICB0aGlzLmFycmF5XyA9IGFycmF5O1xuICB0aGlzLnByZWRpY2F0ZV8gPSBwcmVkaWNhdGU7XG4gIHRoaXMuZW5kXyA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgc3RhcnQgKyBsZW5ndGgpO1xuICB0aGlzLm5leHRJZHhfID0gc3RhcnQgLSAxOyAvLyB1c2UgLTEgc28gaW5pdGlhbCBhZHZhbmNlIHdvcmtzLlxuICB0aGlzLm5leHQoKTsgLy8gaWdub3JpbmcgcmVzdWx0LlxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5oYXNOZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG9iaiA9IHRoaXMucGVlaztcblxuICB2YXIgbmV4dElkeCA9IHRoaXMubmV4dElkeF8gKyAxO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgd2hpbGUgKG5leHRJZHggPCB0aGlzLmVuZF8pIHtcbiAgICBpZiAoIXRoaXMucHJlZGljYXRlXyB8fCB0aGlzLnByZWRpY2F0ZV8odGhpcy5hcnJheV8sIG5leHRJZHgpKSB7XG4gICAgICB0aGlzLnBlZWsgPSB0aGlzLmFycmF5X1tuZXh0SWR4XTtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuZXh0SWR4Kys7XG4gIH1cbiAgdGhpcy5uZXh0SWR4XyA9IG5leHRJZHg7XG4gIGlmICghZm91bmQpIHtcbiAgICB0aGlzLmhhc05leHQgPSBmYWxzZTtcbiAgICB0aGlzLnBlZWsgPSBudWxsO1xuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgaXRlcmF0b3Igb3ZlciBhcnJheSwgYmV0d2VlbiBpbmRleGVzIHN0YXJ0IGFuZFxuICogc3RhcnQgKyBsZW5ndGgsIGFuZCBvbmx5IHJldHVybnMgZW50cmllcyB0aGF0IHBhc3MgdGhlIGFjY2VwdCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7IUFycmF5fSBhcnJheSB0aGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHRoZSBmaXJzdCBpbmRleCB0byBpdGVyYXRlIG92ZXIsIDAgaWYgYWJzZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiAgICAgVGhpcywgYWxvbmcgd2l0aCBzdGFydCwgZGVmaW5lcyBhIHNsaWNlIG9mIHRoZSBhcnJheSwgYW5kIHNvIGxlbmd0aFxuICogICAgIGRvZXNuJ3QgaW1wbHkgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmF0b3Igd2hlbiBhY2NlcHQgZG9lc24ndFxuICogICAgIGFsd2F5cyBhY2NlcHQgYWxsIHZhbHVlcy4gYXJyYXkubGVuZ3RoIHdoZW4gYWJzZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbig/KTpib29sZWFuPX0gb3B0X3ByZWRpY2F0ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqICAgICBwYXJhbWV0ZXJzIGFycmF5IGFuZCBpZHgsIHdoaWNoIHJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlbGVtZW50IHNob3VsZCBiZVxuICogICAgIHJldHVybmVkLiAgSWYgb21pdHRlZCwgYWxsIGVsZW1lbnRzIGFyZSBhY2NlcHRlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihhcnJheSwgc3RhcnQsIGxlbmd0aCwgb3B0X3ByZWRpY2F0ZSkge1xuICByZXR1cm4gbmV3IEl0ZXJhdG9yKGFycmF5LCBzdGFydCwgbGVuZ3RoLCBvcHRfcHJlZGljYXRlKTtcbn07XG5cbi8vIFNoaW0gbGF5ZXIgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrLlxuLy8gRnJvbTogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIFNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgd2luZG93IGNvbnRleHQ6XG4vLyAgIER5Z3JhcGgucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7fSlcbmV4cG9ydCB2YXIgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gYXQgbW9zdCBtYXhGcmFtZXMgdGltZXMgYXQgYW4gYXR0ZW1wdGVkIGludGVydmFsIG9mXG4gKiBmcmFtZVBlcmlvZEluTWlsbGlzLCB0aGVuIGNhbGwgYSBjbGVhbnVwIGZ1bmN0aW9uIG9uY2UuIHJlcGVhdEZuIGlzIGNhbGxlZFxuICogb25jZSBpbW1lZGlhdGVseSwgdGhlbiBhdCBtb3N0IChtYXhGcmFtZXMgLSAxKSB0aW1lcyBhc3luY2hyb25vdXNseS4gSWZcbiAqIG1heEZyYW1lcz09MSwgdGhlbiBjbGVhbnVwX2ZuKCkgaXMgYWxzbyBjYWxsZWQgc3luY2hyb25vdXNseS4gIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gc2VxdWVuY2UgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpfSByZXBlYXRGbiBDYWxsZWQgcmVwZWF0ZWRseSAtLSB0YWtlcyB0aGUgZnJhbWVcbiAqICAgICBudW1iZXIgKGZyb20gMCB0byBtYXhGcmFtZXMtMSkgYXMgYW4gYXJndW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RnJhbWVzIFRoZSBtYXggbnVtYmVyIG9mIHRpbWVzIHRvIGNhbGwgcmVwZWF0Rm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZVBlcmlvZEluTWlsbGlzIE1heCByZXF1ZXN0ZWQgdGltZSBiZXR3ZWVuIGZyYW1lcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2xlYW51cEZuIEEgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBhbGwgcmVwZWF0Rm4gY2FsbHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwZWF0QW5kQ2xlYW51cChyZXBlYXRGbiwgbWF4RnJhbWVzLCBmcmFtZVBlcmlvZEluTWlsbGlzLFxuICAgIGNsZWFudXBGbikge1xuICB2YXIgZnJhbWVOdW1iZXIgPSAwO1xuICB2YXIgcHJldmlvdXNGcmFtZU51bWJlcjtcbiAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gIGlmIChtYXhGcmFtZXMgPT0gMSkge1xuICAgIGNsZWFudXBGbigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF4RnJhbWVBcmcgPSBtYXhGcmFtZXMgLSAxO1xuXG4gIChmdW5jdGlvbiBsb29wKCkge1xuICAgIGlmIChmcmFtZU51bWJlciA+PSBtYXhGcmFtZXMpIHJldHVybjtcbiAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFtZSB0byBkcmF3IGJhc2VkIG9uIHRoZSBkZWxheSBzbyBmYXIuICBXaWxsIHNraXBcbiAgICAgIC8vIGZyYW1lcyBpZiBuZWNlc3NhcnkuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBkZWxheUluTWlsbGlzID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBwcmV2aW91c0ZyYW1lTnVtYmVyID0gZnJhbWVOdW1iZXI7XG4gICAgICBmcmFtZU51bWJlciA9IE1hdGguZmxvb3IoZGVsYXlJbk1pbGxpcyAvIGZyYW1lUGVyaW9kSW5NaWxsaXMpO1xuICAgICAgdmFyIGZyYW1lRGVsdGEgPSBmcmFtZU51bWJlciAtIHByZXZpb3VzRnJhbWVOdW1iZXI7XG4gICAgICAvLyBJZiB3ZSBwcmVkaWN0IHRoYXQgdGhlIHN1YnNlcXVlbnQgcmVwZWF0Rm4gY2FsbCB3aWxsIG92ZXJzaG9vdCBvdXJcbiAgICAgIC8vIHRvdGFsIGZyYW1lIHRhcmdldCwgc28gb3VyIGxhc3QgY2FsbCB3aWxsIGNhdXNlIGEgc3R1dHRlciwgdGhlbiBqdW1wIHRvXG4gICAgICAvLyB0aGUgbGFzdCBjYWxsIGltbWVkaWF0ZWx5LiAgSWYgd2UncmUgZ29pbmcgdG8gY2F1c2UgYSBzdHV0dGVyLCBiZXR0ZXJcbiAgICAgIC8vIHRvIGRvIGl0IGZhc3RlciB0aGFuIHNsb3dlci5cbiAgICAgIHZhciBwcmVkaWN0T3ZlcnNob290U3R1dHRlciA9IChmcmFtZU51bWJlciArIGZyYW1lRGVsdGEpID4gbWF4RnJhbWVBcmc7XG4gICAgICBpZiAocHJlZGljdE92ZXJzaG9vdFN0dXR0ZXIgfHwgKGZyYW1lTnVtYmVyID49IG1heEZyYW1lQXJnKSkge1xuICAgICAgICByZXBlYXRGbihtYXhGcmFtZUFyZyk7ICAvLyBFbnN1cmUgZmluYWwgY2FsbCB3aXRoIG1heEZyYW1lQXJnLlxuICAgICAgICBjbGVhbnVwRm4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmcmFtZURlbHRhICE9PSAwKSB7ICAvLyBEb24ndCBjYWxsIHJlcGVhdEZuIHdpdGggZHVwbGljYXRlIGZyYW1lcy5cbiAgICAgICAgICByZXBlYXRGbihmcmFtZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9vcCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSgpO1xufTtcblxuLy8gQSB3aGl0ZWxpc3Qgb2Ygb3B0aW9ucyB0aGF0IGRvIG5vdCBjaGFuZ2UgcGl4ZWwgcG9zaXRpb25zLlxudmFyIHBpeGVsU2FmZU9wdGlvbnMgPSB7XG4gICdhbm5vdGF0aW9uQ2xpY2tIYW5kbGVyJzogdHJ1ZSxcbiAgJ2Fubm90YXRpb25EYmxDbGlja0hhbmRsZXInOiB0cnVlLFxuICAnYW5ub3RhdGlvbk1vdXNlT3V0SGFuZGxlcic6IHRydWUsXG4gICdhbm5vdGF0aW9uTW91c2VPdmVySGFuZGxlcic6IHRydWUsXG4gICdheGlzTGFiZWxDb2xvcic6IHRydWUsXG4gICdheGlzTGluZUNvbG9yJzogdHJ1ZSxcbiAgJ2F4aXNMaW5lV2lkdGgnOiB0cnVlLFxuICAnY2xpY2tDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd0hpZ2hsaWdodFBvaW50Q2FsbGJhY2snOiB0cnVlLFxuICAnZHJhd1BvaW50cyc6IHRydWUsXG4gICdkcmF3UG9pbnRDYWxsYmFjayc6IHRydWUsXG4gICdkcmF3R3JpZCc6IHRydWUsXG4gICdmaWxsQWxwaGEnOiB0cnVlLFxuICAnZ3JpZExpbmVDb2xvcic6IHRydWUsXG4gICdncmlkTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ2hpZGVPdmVybGF5T25Nb3VzZU91dCc6IHRydWUsXG4gICdoaWdobGlnaHRDYWxsYmFjayc6IHRydWUsXG4gICdoaWdobGlnaHRDaXJjbGVTaXplJzogdHJ1ZSxcbiAgJ2ludGVyYWN0aW9uTW9kZWwnOiB0cnVlLFxuICAnaXNab29tZWRJZ25vcmVQcm9ncmFtbWF0aWNab29tJzogdHJ1ZSxcbiAgJ2xhYmVsc0Rpdic6IHRydWUsXG4gICdsYWJlbHNEaXZTdHlsZXMnOiB0cnVlLFxuICAnbGFiZWxzRGl2V2lkdGgnOiB0cnVlLFxuICAnbGFiZWxzS01CJzogdHJ1ZSxcbiAgJ2xhYmVsc0tNRzInOiB0cnVlLFxuICAnbGFiZWxzU2VwYXJhdGVMaW5lcyc6IHRydWUsXG4gICdsYWJlbHNTaG93WmVyb1ZhbHVlcyc6IHRydWUsXG4gICdsZWdlbmQnOiB0cnVlLFxuICAncGFuRWRnZUZyYWN0aW9uJzogdHJ1ZSxcbiAgJ3BpeGVsc1BlcllMYWJlbCc6IHRydWUsXG4gICdwb2ludENsaWNrQ2FsbGJhY2snOiB0cnVlLFxuICAncG9pbnRTaXplJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90RmlsbENvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90RmlsbEdyYWRpZW50Q29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcic6IHRydWUsXG4gICdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZFN0cm9rZUNvbG9yJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kTGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JQbG90TGluZVdpZHRoJzogdHJ1ZSxcbiAgJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kU3Ryb2tlQ29sb3InOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckZvcmVncm91bmRMaW5lV2lkdGgnOiB0cnVlLFxuICAncmFuZ2VTZWxlY3RvckFscGhhJzogdHJ1ZSxcbiAgJ3Nob3dMYWJlbHNPbkhpZ2hsaWdodCc6IHRydWUsXG4gICdzaG93Um9sbGVyJzogdHJ1ZSxcbiAgJ3N0cm9rZVdpZHRoJzogdHJ1ZSxcbiAgJ3VuZGVybGF5Q2FsbGJhY2snOiB0cnVlLFxuICAndW5oaWdobGlnaHRDYWxsYmFjayc6IHRydWUsXG4gICd6b29tQ2FsbGJhY2snOiB0cnVlXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBzY2FuIHRoZSBvcHRpb24gbGlzdCBhbmQgZGV0ZXJtaW5lIGlmIHRoZXlcbiAqIHJlcXVpcmUgdXMgdG8gcmVjYWxjdWxhdGUgdGhlIHBpeGVsIHBvc2l0aW9ucyBvZiBlYWNoIHBvaW50LlxuICogVE9ETzogbW92ZSB0aGlzIGludG8gZHlncmFwaC1vcHRpb25zLmpzXG4gKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gbGFiZWxzIGEgbGlzdCBvZiBvcHRpb25zIHRvIGNoZWNrLlxuICogQHBhcmFtIHshT2JqZWN0fSBhdHRyc1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ3JhcGggbmVlZHMgbmV3IHBvaW50cyBlbHNlIGZhbHNlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QobGFiZWxzLCBhdHRycykge1xuICAvLyBBc3N1bWUgdGhhdCB3ZSBkbyBub3QgcmVxdWlyZSBuZXcgcG9pbnRzLlxuICAvLyBUaGlzIHdpbGwgY2hhbmdlIHRvIHRydWUgaWYgd2UgYWN0dWFsbHkgZG8gbmVlZCBuZXcgcG9pbnRzLlxuXG4gIC8vIENyZWF0ZSBhIGRpY3Rpb25hcnkgb2Ygc2VyaWVzIG5hbWVzIGZvciBmYXN0ZXIgbG9va3VwLlxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbGFiZWxzLCB0aGVuIHRoZSBkaWN0aW9uYXJ5IHN0YXlzIGVtcHR5LlxuICB2YXIgc2VyaWVzTmFtZXNEaWN0aW9uYXJ5ID0geyB9O1xuICBpZiAobGFiZWxzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlcmllc05hbWVzRGljdGlvbmFyeVtsYWJlbHNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBTY2FuIHRocm91Z2ggYSBmbGF0IChpLmUuIG5vbi1uZXN0ZWQpIG9iamVjdCBvZiBvcHRpb25zLlxuICAvLyBSZXR1cm5zIHRydWUvZmFsc2UgZGVwZW5kaW5nIG9uIHdoZXRoZXIgbmV3IHBvaW50cyBhcmUgbmVlZGVkLlxuICB2YXIgc2NhbkZsYXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxuICAgICAgICAgICFwaXhlbFNhZmVPcHRpb25zW3Byb3BlcnR5XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVkIG9wdGlvbnMuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluZCBvdXQgb2YgdGhpcyBmaWVsZCBpcyBhY3R1YWxseSBhIHNlcmllcyBzcGVjaWZpYyBvcHRpb25zIGxpc3QuXG4gICAgaWYgKHByb3BlcnR5ID09ICdoaWdobGlnaHRTZXJpZXNPcHRzJyB8fFxuICAgICAgICAoc2VyaWVzTmFtZXNEaWN0aW9uYXJ5W3Byb3BlcnR5XSAmJiAhYXR0cnMuc2VyaWVzKSkge1xuICAgICAgLy8gVGhpcyBwcm9wZXJ0eSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb3B0aW9ucyBmb3IgdGhpcyBzZXJpZXMuXG4gICAgICBpZiAoc2NhbkZsYXRPcHRpb25zKGF0dHJzW3Byb3BlcnR5XSkpIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT0gJ3NlcmllcycgfHwgcHJvcGVydHkgPT0gJ2F4ZXMnKSB7XG4gICAgICAvLyBUaGlzIGlzIHR3aWNlLW5lc3RlZCBvcHRpb25zIGxpc3QuXG4gICAgICB2YXIgcGVyU2VyaWVzID0gYXR0cnNbcHJvcGVydHldO1xuICAgICAgZm9yICh2YXIgc2VyaWVzIGluIHBlclNlcmllcykge1xuICAgICAgICBpZiAocGVyU2VyaWVzLmhhc093blByb3BlcnR5KHNlcmllcykgJiZcbiAgICAgICAgICAgIHNjYW5GbGF0T3B0aW9ucyhwZXJTZXJpZXNbc2VyaWVzXSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBub3QgYSBzZXJpZXMgc3BlY2lmaWMgb3B0aW9uIGxpc3QsIGNoZWNrIGlmIGl0J3MgYSBwaXhlbFxuICAgICAgLy8gY2hhbmdpbmcgcHJvcGVydHkuXG4gICAgICBpZiAoIXBpeGVsU2FmZU9wdGlvbnNbcHJvcGVydHldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgdmFyIENpcmNsZXMgPSB7XG4gIERFRkFVTFQgOiBmdW5jdGlvbihnLCBuYW1lLCBjdHgsIGNhbnZhc3gsIGNhbnZhc3ksIGNvbG9yLCByYWRpdXMpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5hcmMoY2FudmFzeCwgY2FudmFzeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gRm9yIG1vcmUgc2hhcGVzLCBpbmNsdWRlIGV4dHJhcy9zaGFwZXMuanNcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgfGRhdGF8IGlzIGRlbGltaXRlZCBieSBDUiwgQ1JMRiwgTEYsIExGQ1IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybiB7P3N0cmluZ30gdGhlIGRlbGltaXRlciB0aGF0IHdhcyBkZXRlY3RlZCAob3IgbnVsbCBvbiBmYWlsdXJlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdExpbmVEZWxpbWl0ZXIoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29kZSA9IGRhdGEuY2hhckF0KGkpO1xuICAgIGlmIChjb2RlID09PSAnXFxyJykge1xuICAgICAgLy8gTWlnaHQgYWN0dWFsbHkgYmUgXCJcXHJcXG5cIi5cbiAgICAgIGlmICgoKGkgKyAxKSA8IGRhdGEubGVuZ3RoKSAmJiAoZGF0YS5jaGFyQXQoaSArIDEpID09PSAnXFxuJykpIHtcbiAgICAgICAgcmV0dXJuICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAnXFxuJykge1xuICAgICAgLy8gTWlnaHQgYWN0dWFsbHkgYmUgXCJcXG5cXHJcIi5cbiAgICAgIGlmICgoKGkgKyAxKSA8IGRhdGEubGVuZ3RoKSAmJiAoZGF0YS5jaGFyQXQoaSArIDEpID09PSAnXFxyJykpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXHInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIElzIG9uZSBub2RlIGNvbnRhaW5lZCBieSBhbm90aGVyP1xuICogQHBhcmFtIHtOb2RlfSBjb250YWluZWUgVGhlIGNvbnRhaW5lZCBub2RlLlxuICogQHBhcmFtIHtOb2RlfSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBjb250YWluZWUgaXMgaW5zaWRlIChvciBlcXVhbCB0bykgY29udGFpbmVyLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUNvbnRhaW5lZEJ5KGNvbnRhaW5lZSwgY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjb250YWluZWVOb2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoY29udGFpbmVlKTtcbiAgd2hpbGUgKGNvbnRhaW5lZU5vZGUgJiYgY29udGFpbmVlTm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVlTm9kZSA9IGNvbnRhaW5lZU5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gKGNvbnRhaW5lZU5vZGUgPT09IGNvbnRhaW5lcik7XG59O1xuXG4vLyBUaGlzIG1hc2tzIHNvbWUgbnVtZXJpYyBpc3N1ZXMgaW4gb2xkZXIgdmVyc2lvbnMgb2YgRmlyZWZveCxcbi8vIHdoZXJlIDEuMC9NYXRoLnBvdygxMCwyKSAhPSBNYXRoLnBvdygxMCwtMikuXG4vKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpOm51bWJlcn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3coYmFzZSwgZXhwKSB7XG4gIGlmIChleHAgPCAwKSB7XG4gICAgcmV0dXJuIDEuMCAvIE1hdGgucG93KGJhc2UsIC1leHApO1xuICB9XG4gIHJldHVybiBNYXRoLnBvdyhiYXNlLCBleHApO1xufTtcblxudmFyIFJHQkFfUkUgPSAvXnJnYmE/XFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSg/OixcXHMqKFswMV0oPzpcXC5cXGQrKT8pKT9cXCkkLztcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRvUkdCXyB3aGljaCBwYXJzZXMgc3RyaW5ncyBvZiB0aGUgZm9ybTpcbiAqIHJnYigxMjMsIDQ1LCA2NylcbiAqIHJnYmEoMTIzLCA0NSwgNjcsIDAuNSlcbiAqIEByZXR1cm4gcGFyc2VkIHtyLGcsYixhP30gdHVwbGUgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VSR0JBKHJnYlN0cikge1xuICB2YXIgYml0cyA9IFJHQkFfUkUuZXhlYyhyZ2JTdHIpO1xuICBpZiAoIWJpdHMpIHJldHVybiBudWxsO1xuICB2YXIgciA9IHBhcnNlSW50KGJpdHNbMV0sIDEwKSxcbiAgICAgIGcgPSBwYXJzZUludChiaXRzWzJdLCAxMCksXG4gICAgICBiID0gcGFyc2VJbnQoYml0c1szXSwgMTApO1xuICBpZiAoYml0c1s0XSkge1xuICAgIHJldHVybiB7cjogciwgZzogZywgYjogYiwgYTogcGFyc2VGbG9hdChiaXRzWzRdKX07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtyOiByLCBnOiBnLCBiOiBifTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFueSB2YWxpZCBDU1MgY29sb3IgKGhleCwgcmdiKCksIG5hbWVkIGNvbG9yKSB0byBhbiBSR0IgdHVwbGUuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBjb2xvclN0ciBBbnkgdmFsaWQgQ1NTIGNvbG9yIHN0cmluZy5cbiAqIEByZXR1cm4ge3tyOm51bWJlcixnOm51bWJlcixiOm51bWJlcixhOm51bWJlcj99fSBQYXJzZWQgUkdCIHR1cGxlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUkdCXyhjb2xvclN0cikge1xuICAvLyBTdHJhdGVneTogRmlyc3QgdHJ5IHRvIHBhcnNlIGNvbG9yU3RyIGRpcmVjdGx5LiBUaGlzIGlzIGZhc3QgJiBhdm9pZHMgRE9NXG4gIC8vIG1hbmlwdWxhdGlvbi4gIElmIHRoYXQgZmFpbHMgKGUuZy4gZm9yIG5hbWVkIGNvbG9ycyBsaWtlICdyZWQnKSwgdGhlblxuICAvLyBjcmVhdGUgYSBoaWRkZW4gRE9NIGVsZW1lbnQgYW5kIHBhcnNlIGl0cyBjb21wdXRlZCBjb2xvci5cbiAgdmFyIHJnYiA9IHBhcnNlUkdCQShjb2xvclN0cik7XG4gIGlmIChyZ2IpIHJldHVybiByZ2I7XG5cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHI7XG4gIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgdmFyIHJnYlN0ciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdiwgbnVsbCkuYmFja2dyb3VuZENvbG9yO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIHJldHVybiBwYXJzZVJHQkEocmdiU3RyKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlICZsdDtjYW52YXMmZ3Q7IHRhZy5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQ9fSBvcHRfY2FudmFzRWxlbWVudCBQYXNzIGEgY2FudmFzIGVsZW1lbnQgYXMgYW5cbiAqICAgICBvcHRpbWl6YXRpb24gaWYgeW91IGhhdmUgb25lLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbnZhc1N1cHBvcnRlZChvcHRfY2FudmFzRWxlbWVudCkge1xuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSBvcHRfY2FudmFzRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgdmFsdWUgYXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIuIFRoaXMgaXMgbGlrZSB0aGUgcGFyc2VGbG9hdCgpXG4gKiBidWlsdC1pbiwgYnV0IHdpdGggYSBmZXcgZGlmZmVyZW5jZXM6XG4gKiAtIHRoZSBlbXB0eSBzdHJpbmcgaXMgcGFyc2VkIGFzIG51bGwsIHJhdGhlciB0aGFuIE5hTi5cbiAqIC0gaWYgdGhlIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkIGF0IGFsbCwgYW4gZXJyb3IgaXMgbG9nZ2VkLlxuICogSWYgdGhlIHN0cmluZyBjYW4ndCBiZSBwYXJzZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB4IFRoZSBzdHJpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9saW5lX25vIFRoZSBsaW5lIG51bWJlciBmcm9tIHdoaWNoIHRoZSBzdHJpbmcgY29tZXMuXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9saW5lIFRoZSB0ZXh0IG9mIHRoZSBsaW5lIGZyb20gd2hpY2ggdGhlIHN0cmluZyBjb21lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRmxvYXRfKHgsIG9wdF9saW5lX25vLCBvcHRfbGluZSkge1xuICB2YXIgdmFsID0gcGFyc2VGbG9hdCh4KTtcbiAgaWYgKCFpc05hTih2YWwpKSByZXR1cm4gdmFsO1xuXG4gIC8vIFRyeSB0byBmaWd1cmUgb3V0IHdoYXQgaGFwcGVlbmQuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBwYXJzZSBpdCBhcyBudWxsLlxuICBpZiAoL14gKiQvLnRlc3QoeCkpIHJldHVybiBudWxsO1xuXG4gIC8vIElmIGl0IHdhcyBhY3R1YWxseSBcIk5hTlwiLCByZXR1cm4gaXQgYXMgTmFOLlxuICBpZiAoL14gKm5hbiAqJC9pLnRlc3QoeCkpIHJldHVybiBOYU47XG5cbiAgLy8gTG9va3MgbGlrZSBhIHBhcnNpbmcgZXJyb3IuXG4gIHZhciBtc2cgPSBcIlVuYWJsZSB0byBwYXJzZSAnXCIgKyB4ICsgXCInIGFzIGEgbnVtYmVyXCI7XG4gIGlmIChvcHRfbGluZSAhPT0gdW5kZWZpbmVkICYmIG9wdF9saW5lX25vICE9PSB1bmRlZmluZWQpIHtcbiAgICBtc2cgKz0gXCIgb24gbGluZSBcIiArICgxKyhvcHRfbGluZV9ub3x8MCkpICsgXCIgKCdcIiArIG9wdF9saW5lICsgXCInKSBvZiBDU1YuXCI7XG4gIH1cbiAgY29uc29sZS5lcnJvcihtc2cpO1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vLyBMYWJlbCBjb25zdGFudHMgZm9yIHRoZSBsYWJlbHNLTUIgYW5kIGxhYmVsc0tNRzIgb3B0aW9ucy5cbi8vIChpLmUuICcxMDAwMDAnIC0+ICcxMDBLJylcbnZhciBLTUJfTEFCRUxTID0gWyAnSycsICdNJywgJ0InLCAnVCcsICdRJyBdO1xudmFyIEtNRzJfQklHX0xBQkVMUyA9IFsgJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJywgJ1onLCAnWScgXTtcbnZhciBLTUcyX1NNQUxMX0xBQkVMUyA9IFsgJ20nLCAndScsICduJywgJ3AnLCAnZicsICdhJywgJ3onLCAneScgXTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmV0dXJuIGEgc3RyaW5nIHZlcnNpb24gb2YgYSBudW1iZXIuIFRoaXMgcmVzcGVjdHMgdGhlIGRpZ2l0c0FmdGVyRGVjaW1hbFxuICogYW5kIG1heE51bWJlcldpZHRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgbnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtEeWdyYXBofSBvcHRzIEFuIG9wdGlvbnMgdmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVmFsdWVGb3JtYXR0ZXIoeCwgb3B0cykge1xuICB2YXIgc2lnRmlncyA9IG9wdHMoJ3NpZ0ZpZ3MnKTtcblxuICBpZiAoc2lnRmlncyAhPT0gbnVsbCkge1xuICAgIC8vIFVzZXIgaGFzIG9wdGVkIGZvciBhIGZpeGVkIG51bWJlciBvZiBzaWduaWZpY2FudCBmaWd1cmVzLlxuICAgIHJldHVybiBmbG9hdEZvcm1hdCh4LCBzaWdGaWdzKTtcbiAgfVxuXG4gIHZhciBkaWdpdHMgPSBvcHRzKCdkaWdpdHNBZnRlckRlY2ltYWwnKTtcbiAgdmFyIG1heE51bWJlcldpZHRoID0gb3B0cygnbWF4TnVtYmVyV2lkdGgnKTtcblxuICB2YXIga21iID0gb3B0cygnbGFiZWxzS01CJyk7XG4gIHZhciBrbWcyID0gb3B0cygnbGFiZWxzS01HMicpO1xuXG4gIHZhciBsYWJlbDtcblxuICAvLyBzd2l0Y2ggdG8gc2NpZW50aWZpYyBub3RhdGlvbiBpZiB3ZSB1bmRlcmZsb3cgb3Igb3ZlcmZsb3cgZml4ZWQgZGlzcGxheS5cbiAgaWYgKHggIT09IDAuMCAmJlxuICAgICAgKE1hdGguYWJzKHgpID49IE1hdGgucG93KDEwLCBtYXhOdW1iZXJXaWR0aCkgfHxcbiAgICAgICBNYXRoLmFicyh4KSA8IE1hdGgucG93KDEwLCAtZGlnaXRzKSkpIHtcbiAgICBsYWJlbCA9IHgudG9FeHBvbmVudGlhbChkaWdpdHMpO1xuICB9IGVsc2Uge1xuICAgIGxhYmVsID0gJycgKyByb3VuZF8oeCwgZGlnaXRzKTtcbiAgfVxuXG4gIGlmIChrbWIgfHwga21nMikge1xuICAgIHZhciBrO1xuICAgIHZhciBrX2xhYmVscyA9IFtdO1xuICAgIHZhciBtX2xhYmVscyA9IFtdO1xuICAgIGlmIChrbWIpIHtcbiAgICAgIGsgPSAxMDAwO1xuICAgICAga19sYWJlbHMgPSBLTUJfTEFCRUxTO1xuICAgIH1cbiAgICBpZiAoa21nMikge1xuICAgICAgaWYgKGttYikgY29uc29sZS53YXJuKFwiU2V0dGluZyBib3RoIGxhYmVsc0tNQiBhbmQgbGFiZWxzS01HMi4gUGljayBvbmUhXCIpO1xuICAgICAgayA9IDEwMjQ7XG4gICAgICBrX2xhYmVscyA9IEtNRzJfQklHX0xBQkVMUztcbiAgICAgIG1fbGFiZWxzID0gS01HMl9TTUFMTF9MQUJFTFM7XG4gICAgfVxuXG4gICAgdmFyIGFic3ggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgbiA9IHBvdyhrLCBrX2xhYmVscy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGogPSBrX2xhYmVscy5sZW5ndGggLSAxOyBqID49IDA7IGotLSwgbiAvPSBrKSB7XG4gICAgICBpZiAoYWJzeCA+PSBuKSB7XG4gICAgICAgIGxhYmVsID0gcm91bmRfKHggLyBuLCBkaWdpdHMpICsga19sYWJlbHNbal07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa21nMikge1xuICAgICAgLy8gVE9ETyhkYW52ayk6IGNsZWFuIHVwIHRoaXMgbG9naWMuIFdoeSBzbyBkaWZmZXJlbnQgdGhhbiBrbWI/XG4gICAgICB2YXIgeF9wYXJ0cyA9IFN0cmluZyh4LnRvRXhwb25lbnRpYWwoKSkuc3BsaXQoJ2UtJyk7XG4gICAgICBpZiAoeF9wYXJ0cy5sZW5ndGggPT09IDIgJiYgeF9wYXJ0c1sxXSA+PSAzICYmIHhfcGFydHNbMV0gPD0gMjQpIHtcbiAgICAgICAgaWYgKHhfcGFydHNbMV0gJSAzID4gMCkge1xuICAgICAgICAgIGxhYmVsID0gcm91bmRfKHhfcGFydHNbMF0gL1xuICAgICAgICAgICAgICBwb3coMTAsICh4X3BhcnRzWzFdICUgMykpLFxuICAgICAgICAgICAgICBkaWdpdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsID0gTnVtYmVyKHhfcGFydHNbMF0pLnRvRml4ZWQoMik7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwgKz0gbV9sYWJlbHNbTWF0aC5mbG9vcih4X3BhcnRzWzFdIC8gMykgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG4vKipcbiAqIHZhcmlhbnQgZm9yIHVzZSBhcyBhbiBheGlzTGFiZWxGb3JtYXR0ZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyKHgsIGdyYW51bGFyaXR5LCBvcHRzKSB7XG4gIHJldHVybiBudW1iZXJWYWx1ZUZvcm1hdHRlci5jYWxsKHRoaXMsIHgsIG9wdHMpO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICovXG52YXIgU0hPUlRfTU9OVEhfTkFNRVNfID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG5cbi8qKlxuICogQ29udmVydCBhIEpTIGRhdGUgdG8gYSBzdHJpbmcgYXBwcm9wcmlhdGUgdG8gZGlzcGxheSBvbiBhbiBheGlzIHRoYXRcbiAqIGlzIGRpc3BsYXlpbmcgdmFsdWVzIGF0IHRoZSBzdGF0ZWQgZ3JhbnVsYXJpdHkuIFRoaXMgcmVzcGVjdHMgdGhlXG4gKiBsYWJlbHNVVEMgb3B0aW9uLlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIFRoZSBkYXRlIHRvIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXJ9IGdyYW51bGFyaXR5IE9uZSBvZiB0aGUgRHlncmFwaCBncmFudWxhcml0eSBjb25zdGFudHNcbiAqIEBwYXJhbSB7RHlncmFwaH0gb3B0cyBBbiBvcHRpb25zIHZpZXdcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRhdGUgZm9ybWF0dGVkIGFzIGxvY2FsIHRpbWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlQXhpc0xhYmVsRm9ybWF0dGVyKGRhdGUsIGdyYW51bGFyaXR5LCBvcHRzKSB7XG4gIHZhciB1dGMgPSBvcHRzKCdsYWJlbHNVVEMnKTtcbiAgdmFyIGFjY2Vzc29ycyA9IHV0YyA/IERhdGVBY2Nlc3NvcnNVVEMgOiBEYXRlQWNjZXNzb3JzTG9jYWw7XG5cbiAgdmFyIHllYXIgPSBhY2Nlc3NvcnMuZ2V0RnVsbFllYXIoZGF0ZSksXG4gICAgICBtb250aCA9IGFjY2Vzc29ycy5nZXRNb250aChkYXRlKSxcbiAgICAgIGRheSA9IGFjY2Vzc29ycy5nZXREYXRlKGRhdGUpLFxuICAgICAgaG91cnMgPSBhY2Nlc3NvcnMuZ2V0SG91cnMoZGF0ZSksXG4gICAgICBtaW5zID0gYWNjZXNzb3JzLmdldE1pbnV0ZXMoZGF0ZSksXG4gICAgICBzZWNzID0gYWNjZXNzb3JzLmdldFNlY29uZHMoZGF0ZSksXG4gICAgICBtaWxsaXMgPSBhY2Nlc3NvcnMuZ2V0U2Vjb25kcyhkYXRlKTtcblxuICBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREVDQURBTCkge1xuICAgIHJldHVybiAnJyArIHllYXI7XG4gIH0gZWxzZSBpZiAoZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuTU9OVEhMWSkge1xuICAgIHJldHVybiBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdICsgJyYjMTYwOycgKyB5ZWFyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmcmFjID0gaG91cnMgKiAzNjAwICsgbWlucyAqIDYwICsgc2VjcyArIDFlLTMgKiBtaWxsaXM7XG4gICAgaWYgKGZyYWMgPT09IDAgfHwgZ3JhbnVsYXJpdHkgPj0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHkuREFJTFkpIHtcbiAgICAgIC8vIGUuZy4gJzIxIEphbicgKCVkJWIpXG4gICAgICByZXR1cm4gemVyb3BhZChkYXkpICsgJyYjMTYwOycgKyBTSE9SVF9NT05USF9OQU1FU19bbW9udGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaG1zU3RyaW5nXyhob3VycywgbWlucywgc2Vjcyk7XG4gICAgfVxuICB9XG59O1xuLy8gYWxpYXMgaW4gY2FzZSBhbnlvbmUgaXMgcmVmZXJlbmNpbmcgdGhlIG9sZCBtZXRob2QuXG4vLyBEeWdyYXBoLmRhdGVBeGlzRm9ybWF0dGVyID0gRHlncmFwaC5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyO1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyB2ZXJzaW9uIG9mIGEgSlMgZGF0ZSBmb3IgYSB2YWx1ZSBsYWJlbC4gVGhpcyByZXNwZWN0cyB0aGVcbiAqIGxhYmVsc1VUQyBvcHRpb24uXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgVGhlIGRhdGUgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcGFyYW0ge0R5Z3JhcGh9IG9wdHMgQW4gb3B0aW9ucyB2aWV3XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVZhbHVlRm9ybWF0dGVyKGQsIG9wdHMpIHtcbiAgcmV0dXJuIGRhdGVTdHJpbmdfKGQsIG9wdHMoJ2xhYmVsc1VUQycpKTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAwNiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDcmVhdGVzIGFuIGludGVyYWN0aXZlLCB6b29tYWJsZSBncmFwaCBiYXNlZCBvbiBhIENTViBmaWxlIG9yXG4gKiBzdHJpbmcuIER5Z3JhcGggY2FuIGhhbmRsZSBtdWx0aXBsZSBzZXJpZXMgd2l0aCBvciB3aXRob3V0IGVycm9yIGJhcnMuIFRoZVxuICogZGF0ZS92YWx1ZSByYW5nZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldC4gRHlncmFwaCB1c2VzIHRoZVxuICogJmx0O2NhbnZhcyZndDsgdGFnLCBzbyBpdCBvbmx5IHdvcmtzIGluIEZGMS41Ky5cbiAqIEBhdXRob3IgZGFudmRrQGdtYWlsLmNvbSAoRGFuIFZhbmRlcmthbSlcblxuICBVc2FnZTpcbiAgIDxkaXYgaWQ9XCJncmFwaGRpdlwiIHN0eWxlPVwid2lkdGg6ODAwcHg7IGhlaWdodDo1MDBweDtcIj48L2Rpdj5cbiAgIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPlxuICAgICBuZXcgRHlncmFwaChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyYXBoZGl2XCIpLFxuICAgICAgICAgICAgICAgICBcImRhdGFmaWxlLmNzdlwiLCAgLy8gQ1NWIGZpbGUgd2l0aCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgIHsgfSk7IC8vIG9wdGlvbnNcbiAgIDwvc2NyaXB0PlxuXG4gVGhlIENTViBmaWxlIGlzIG9mIHRoZSBmb3JtXG5cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLFNlcmllc0NcbiAgIFlZWVlNTURELEExLEIxLEMxXG4gICBZWVlZTU1ERCxBMixCMixDMlxuXG4gSWYgdGhlICdlcnJvckJhcnMnIG9wdGlvbiBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgaW5wdXQgc2hvdWxkIGJlIG9mXG4gdGhlIGZvcm1cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLC4uLlxuICAgWVlZWU1NREQsQTEsc2lnbWFBMSxCMSxzaWdtYUIxLC4uLlxuICAgWVlZWU1NREQsQTIsc2lnbWFBMixCMixzaWdtYUIyLC4uLlxuXG4gSWYgdGhlICdmcmFjdGlvbnMnIG9wdGlvbiBpcyBzZXQsIHRoZSBpbnB1dCBzaG91bGQgYmUgb2YgdGhlIGZvcm06XG5cbiAgIERhdGUsU2VyaWVzQSxTZXJpZXNCLC4uLlxuICAgWVlZWU1NREQsQTEvQjEsQTIvQjIsLi4uXG4gICBZWVlZTU1ERCxBMS9CMSxBMi9CMiwuLi5cblxuIEFuZCBlcnJvciBiYXJzIHdpbGwgYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IHVzaW5nIGEgYmlub21pYWwgZGlzdHJpYnV0aW9uLlxuXG4gRm9yIGZ1cnRoZXIgZG9jdW1lbnRhdGlvbiBhbmQgZXhhbXBsZXMsIHNlZSBodHRwOi8vZHlncmFwaHMuY29tL1xuXG4gKi9cblxuaW1wb3J0IER5Z3JhcGhMYXlvdXQgZnJvbSAnLi9keWdyYXBoLWxheW91dCc7XG5pbXBvcnQgRHlncmFwaENhbnZhc1JlbmRlcmVyIGZyb20gJy4vZHlncmFwaC1jYW52YXMnO1xuaW1wb3J0IER5Z3JhcGhPcHRpb25zIGZyb20gJy4vZHlncmFwaC1vcHRpb25zJztcbmltcG9ydCBEeWdyYXBoSW50ZXJhY3Rpb24gZnJvbSAnLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCAqIGFzIER5Z3JhcGhUaWNrZXJzIGZyb20gJy4vZHlncmFwaC10aWNrZXJzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vZHlncmFwaC11dGlscyc7XG5pbXBvcnQgREVGQVVMVF9BVFRSUyBmcm9tICcuL2R5Z3JhcGgtZGVmYXVsdC1hdHRycyc7XG5pbXBvcnQgT1BUSU9OU19SRUZFUkVOQ0UgZnJvbSAnLi9keWdyYXBoLW9wdGlvbnMtcmVmZXJlbmNlJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4vaWZyYW1lLXRhcnAnO1xuXG5pbXBvcnQgRGVmYXVsdEhhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9kZWZhdWx0JztcbmltcG9ydCBFcnJvckJhcnNIYW5kbGVyIGZyb20gJy4vZGF0YWhhbmRsZXIvYmFycy1lcnJvcic7XG5pbXBvcnQgQ3VzdG9tQmFyc0hhbmRsZXIgZnJvbSAnLi9kYXRhaGFuZGxlci9iYXJzLWN1c3RvbSc7XG5pbXBvcnQgRGVmYXVsdEZyYWN0aW9uSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2RlZmF1bHQtZnJhY3Rpb25zJztcbmltcG9ydCBGcmFjdGlvbnNCYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMtZnJhY3Rpb25zJztcbmltcG9ydCBCYXJzSGFuZGxlciBmcm9tICcuL2RhdGFoYW5kbGVyL2JhcnMnO1xuXG5pbXBvcnQgQW5ub3RhdGlvbnNQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2Fubm90YXRpb25zJztcbmltcG9ydCBBeGVzUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9heGVzJztcbmltcG9ydCBDaGFydExhYmVsc1BsdWdpbiBmcm9tICcuL3BsdWdpbnMvY2hhcnQtbGFiZWxzJztcbmltcG9ydCBHcmlkUGx1Z2luIGZyb20gJy4vcGx1Z2lucy9ncmlkJztcbmltcG9ydCBMZWdlbmRQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL2xlZ2VuZCc7XG5pbXBvcnQgUmFuZ2VTZWxlY3RvclBsdWdpbiBmcm9tICcuL3BsdWdpbnMvcmFuZ2Utc2VsZWN0b3InO1xuXG5pbXBvcnQgR1ZpekNoYXJ0IGZyb20gJy4vZHlncmFwaC1ndml6JztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnRlcmFjdGl2ZSwgem9vbWFibGUgY2hhcnQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2RpdiB8IFN0cmluZ30gZGl2IEEgZGl2IG9yIHRoZSBpZCBvZiBhIGRpdiBpbnRvIHdoaWNoIHRvIGNvbnN0cnVjdFxuICogdGhlIGNoYXJ0LlxuICogQHBhcmFtIHtTdHJpbmcgfCBGdW5jdGlvbn0gZmlsZSBBIGZpbGUgY29udGFpbmluZyBDU1YgZGF0YSBvciBhIGZ1bmN0aW9uXG4gKiB0aGF0IHJldHVybnMgdGhpcyBkYXRhLiBUaGUgbW9zdCBiYXNpYyBleHBlY3RlZCBmb3JtYXQgZm9yIGVhY2ggbGluZSBpc1xuICogXCJZWVlZL01NL0RELHZhbDEsdmFsMiwuLi5cIi4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuICogaHR0cDovL2R5Z3JhcGhzLmNvbS9kYXRhLmh0bWwuXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVmFyaW91cyBvdGhlciBhdHRyaWJ1dGVzLCBlLmcuIGVycm9yQmFycyBkZXRlcm1pbmVzXG4gKiB3aGV0aGVyIHRoZSBpbnB1dCBkYXRhIGNvbnRhaW5zIGVycm9yIHJhbmdlcy4gRm9yIGEgY29tcGxldGUgbGlzdCBvZlxuICogb3B0aW9ucywgc2VlIGh0dHA6Ly9keWdyYXBocy5jb20vb3B0aW9ucy5odG1sLlxuICovXG52YXIgRHlncmFwaCA9IGZ1bmN0aW9uKGRpdiwgZGF0YSwgb3B0cykge1xuICB0aGlzLl9faW5pdF9fKGRpdiwgZGF0YSwgb3B0cyk7XG59O1xuXG5EeWdyYXBoLk5BTUUgPSBcIkR5Z3JhcGhcIjtcbkR5Z3JhcGguVkVSU0lPTiA9IFwiMS4xLjBcIjtcblxuLy8gVmFyaW91cyBkZWZhdWx0IHZhbHVlc1xuRHlncmFwaC5ERUZBVUxUX1JPTExfUEVSSU9EID0gMTtcbkR5Z3JhcGguREVGQVVMVF9XSURUSCA9IDQ4MDtcbkR5Z3JhcGguREVGQVVMVF9IRUlHSFQgPSAzMjA7XG5cbi8vIEZvciBtYXggNjAgSHouIGFuaW1hdGlvbjpcbkR5Z3JhcGguQU5JTUFUSU9OX1NURVBTID0gMTI7XG5EeWdyYXBoLkFOSU1BVElPTl9EVVJBVElPTiA9IDIwMDtcblxuLyoqXG4gKiBTdGFuZGFyZCBwbG90dGVycy4gVGhlc2UgbWF5IGJlIHVzZWQgYnkgY2xpZW50cy5cbiAqIEF2YWlsYWJsZSBwbG90dGVycyBhcmU6XG4gKiAtIER5Z3JhcGguUGxvdHRlcnMubGluZVBsb3R0ZXI6IGRyYXdzIGNlbnRyYWwgbGluZXMgKG1vc3QgY29tbW9uKVxuICogLSBEeWdyYXBoLlBsb3R0ZXJzLmVycm9yUGxvdHRlcjogZHJhd3MgZXJyb3IgYmFyc1xuICogLSBEeWdyYXBoLlBsb3R0ZXJzLmZpbGxQbG90dGVyOiBkcmF3cyBmaWxscyB1bmRlciBsaW5lcyAodXNlZCB3aXRoIGZpbGxHcmFwaClcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgcGxvdHRlciBpcyBbZmlsbFBsb3R0ZXIsIGVycm9yUGxvdHRlciwgbGluZVBsb3R0ZXJdLlxuICogVGhpcyBjYXVzZXMgYWxsIHRoZSBsaW5lcyB0byBiZSBkcmF3biBvdmVyIGFsbCB0aGUgZmlsbHMvZXJyb3IgYmFycy5cbiAqL1xuRHlncmFwaC5QbG90dGVycyA9IER5Z3JhcGhDYW52YXNSZW5kZXJlci5fUGxvdHRlcnM7XG5cblxuLy8gVXNlZCBmb3IgaW5pdGlhbGl6aW5nIGFubm90YXRpb24gQ1NTIHJ1bGVzIG9ubHkgb25jZS5cbkR5Z3JhcGguYWRkZWRBbm5vdGF0aW9uQ1NTID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIER5Z3JhcGguIFRoaXMgY3JlYXRlcyBhIG5ldyBESVYgYW5kIGNvbnN0cnVjdHMgdGhlIFBsb3RLaXRcbiAqIGFuZCBjb250ZXh0ICZsdDtjYW52YXMmZ3Q7IGluc2lkZSBvZiBpdC4gU2VlIHRoZSBjb25zdHJ1Y3RvciBmb3IgZGV0YWlscy5cbiAqIG9uIHRoZSBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtFbGVtZW50fSBkaXYgdGhlIEVsZW1lbnQgdG8gcmVuZGVyIHRoZSBncmFwaCBpbnRvLlxuICogQHBhcmFtIHtzdHJpbmcgfCBGdW5jdGlvbn0gZmlsZSBTb3VyY2UgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIE1pc2NlbGxhbmVvdXMgb3RoZXIgb3B0aW9uc1xuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuX19pbml0X18gPSBmdW5jdGlvbihkaXYsIGZpbGUsIGF0dHJzKSB7XG4gIHRoaXMuaXNfaW5pdGlhbF9kcmF3XyA9IHRydWU7XG4gIHRoaXMucmVhZHlGbnNfID0gW107XG5cbiAgLy8gU3VwcG9ydCB0d28tYXJndW1lbnQgY29uc3RydWN0b3JcbiAgaWYgKGF0dHJzID09PSBudWxsIHx8IGF0dHJzID09PSB1bmRlZmluZWQpIHsgYXR0cnMgPSB7fTsgfVxuXG4gIGF0dHJzID0gRHlncmFwaC5jb3B5VXNlckF0dHJzXyhhdHRycyk7XG5cbiAgaWYgKHR5cGVvZihkaXYpID09ICdzdHJpbmcnKSB7XG4gICAgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2KTtcbiAgfVxuXG4gIGlmICghZGl2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RpbmcgZHlncmFwaCB3aXRoIGEgbm9uLWV4aXN0ZW50IGRpdiEnKTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIGltcG9ydGFudCBiaXRzIGludG8gdGhlIG9iamVjdFxuICAvLyBUT0RPKGRhbnZrKTogbW9zdCBvZiB0aGVzZSBzaG91bGQganVzdCBzdGF5IGluIHRoZSBhdHRyc18gZGljdGlvbmFyeS5cbiAgdGhpcy5tYWluZGl2XyA9IGRpdjtcbiAgdGhpcy5maWxlXyA9IGZpbGU7XG4gIHRoaXMucm9sbFBlcmlvZF8gPSBhdHRycy5yb2xsUGVyaW9kIHx8IER5Z3JhcGguREVGQVVMVF9ST0xMX1BFUklPRDtcbiAgdGhpcy5wcmV2aW91c1ZlcnRpY2FsWF8gPSAtMTtcbiAgdGhpcy5mcmFjdGlvbnNfID0gYXR0cnMuZnJhY3Rpb25zIHx8IGZhbHNlO1xuICB0aGlzLmRhdGVXaW5kb3dfID0gYXR0cnMuZGF0ZVdpbmRvdyB8fCBudWxsO1xuXG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG5cbiAgLy8gWm9vbWVkIGluZGljYXRvcnMgLSBUaGVzZSBpbmRpY2F0ZSB3aGVuIHRoZSBncmFwaCBoYXMgYmVlbiB6b29tZWQgYW5kIG9uIHdoYXQgYXhpcy5cbiAgdGhpcy56b29tZWRfeF8gPSBmYWxzZTtcbiAgdGhpcy56b29tZWRfeV8gPSBmYWxzZTtcblxuICAvLyBDbGVhciB0aGUgZGl2LiBUaGlzIGVuc3VyZSB0aGF0LCBpZiBtdWx0aXBsZSBkeWdyYXBocyBhcmUgcGFzc2VkIHRoZSBzYW1lXG4gIC8vIGRpdiwgdGhlbiBvbmx5IG9uZSB3aWxsIGJlIGRyYXduLlxuICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICAvLyBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgJ3dpZHRoJyBhbmQgJ2hlaWdodCcgb3B0aW9ucyB0cnVtcCBhbGwgQ1NTXG4gIC8vIHJ1bGVzIF9leGNlcHRfIGZvciBhbiBleHBsaWNpdCAnd2lkdGgnIG9yICdoZWlnaHQnIG9uIHRoZSBkaXYuXG4gIC8vIEFzIGFuIGFkZGVkIGNvbnZlbmllbmNlLCBpZiB0aGUgZGl2IGhhcyB6ZXJvIGhlaWdodCAobGlrZSA8ZGl2PjwvZGl2PiBkb2VzXG4gIC8vIHdpdGhvdXQgYW55IHN0eWxlcyksIHRoZW4gd2UgdXNlIGEgZGVmYXVsdCBoZWlnaHQvd2lkdGguXG4gIGlmIChkaXYuc3R5bGUud2lkdGggPT09ICcnICYmIGF0dHJzLndpZHRoKSB7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gYXR0cnMud2lkdGggKyBcInB4XCI7XG4gIH1cbiAgaWYgKGRpdi5zdHlsZS5oZWlnaHQgPT09ICcnICYmIGF0dHJzLmhlaWdodCkge1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBhdHRycy5oZWlnaHQgKyBcInB4XCI7XG4gIH1cbiAgaWYgKGRpdi5zdHlsZS5oZWlnaHQgPT09ICcnICYmIGRpdi5jbGllbnRIZWlnaHQgPT09IDApIHtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gRHlncmFwaC5ERUZBVUxUX0hFSUdIVCArIFwicHhcIjtcbiAgICBpZiAoZGl2LnN0eWxlLndpZHRoID09PSAnJykge1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gRHlncmFwaC5ERUZBVUxUX1dJRFRIICsgXCJweFwiO1xuICAgIH1cbiAgfVxuICAvLyBUaGVzZSB3aWxsIGJlIHplcm8gaWYgdGhlIGR5Z3JhcGgncyBkaXYgaXMgaGlkZGVuLiBJbiB0aGF0IGNhc2UsXG4gIC8vIHVzZSB0aGUgdXNlci1zcGVjaWZpZWQgYXR0cmlidXRlcyBpZiBwcmVzZW50LiBJZiBub3QsIHVzZSB6ZXJvXG4gIC8vIGFuZCBhc3N1bWUgdGhlIHVzZXIgd2lsbCBjYWxsIHJlc2l6ZSB0byBmaXggdGhpbmdzIGxhdGVyLlxuICB0aGlzLndpZHRoXyA9IGRpdi5jbGllbnRXaWR0aCB8fCBhdHRycy53aWR0aCB8fCAwO1xuICB0aGlzLmhlaWdodF8gPSBkaXYuY2xpZW50SGVpZ2h0IHx8IGF0dHJzLmhlaWdodCB8fCAwO1xuXG4gIC8vIFRPRE8oZGFudmspOiBzZXQgZmlsbEdyYXBoIHRvIGJlIHBhcnQgb2YgYXR0cnNfIGhlcmUsIG5vdCB1c2VyX2F0dHJzXy5cbiAgaWYgKGF0dHJzLnN0YWNrZWRHcmFwaCkge1xuICAgIGF0dHJzLmZpbGxHcmFwaCA9IHRydWU7XG4gICAgLy8gVE9ETyhuaWtoaWxrKTogQWRkIGFueSBvdGhlciBzdGFja2VkR3JhcGggY2hlY2tzIGhlcmUuXG4gIH1cblxuICAvLyBERVBSRUNBVElPTiBXQVJOSU5HOiBBbGwgb3B0aW9uIHByb2Nlc3Npbmcgc2hvdWxkIGJlIG1vdmVkIGZyb21cbiAgLy8gYXR0cnNfIGFuZCB1c2VyX2F0dHJzXyB0byBvcHRpb25zXywgd2hpY2ggaG9sZHMgYWxsIHRoaXMgaW5mb3JtYXRpb24uXG4gIC8vXG4gIC8vIER5Z3JhcGhzIGhhcyBtYW55IG9wdGlvbnMsIHNvbWUgb2Ygd2hpY2ggaW50ZXJhY3Qgd2l0aCBvbmUgYW5vdGhlci5cbiAgLy8gVG8ga2VlcCB0cmFjayBvZiBldmVyeXRoaW5nLCB3ZSBtYWludGFpbiB0d28gc2V0cyBvZiBvcHRpb25zOlxuICAvL1xuICAvLyAgdGhpcy51c2VyX2F0dHJzXyAgIG9ubHkgb3B0aW9ucyBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlci5cbiAgLy8gIHRoaXMuYXR0cnNfICAgICAgICBkZWZhdWx0cywgb3B0aW9ucyBkZXJpdmVkIGZyb20gdXNlcl9hdHRyc18sIGRhdGEuXG4gIC8vXG4gIC8vIE9wdGlvbnMgYXJlIHRoZW4gYWNjZXNzZWQgdGhpcy5hdHRyXygnYXR0cicpLCB3aGljaCBmaXJzdCBsb29rcyBhdFxuICAvLyB1c2VyX2F0dHJzXyBhbmQgdGhlbiBjb21wdXRlZCBhdHRyc18uIFRoaXMgd2F5IER5Z3JhcGhzIGNhbiBzZXQgaW50ZWxsaWdlbnRcbiAgLy8gZGVmYXVsdHMgd2l0aG91dCBvdmVycmlkaW5nIGJlaGF2aW9yIHRoYXQgdGhlIHVzZXIgc3BlY2lmaWNhbGx5IGFza3MgZm9yLlxuICB0aGlzLnVzZXJfYXR0cnNfID0ge307XG4gIHV0aWxzLnVwZGF0ZSh0aGlzLnVzZXJfYXR0cnNfLCBhdHRycyk7XG5cbiAgLy8gVGhpcyBzZXF1ZW5jZSBlbnN1cmVzIHRoYXQgRHlncmFwaC5ERUZBVUxUX0FUVFJTIGlzIG5ldmVyIG1vZGlmaWVkLlxuICB0aGlzLmF0dHJzXyA9IHt9O1xuICB1dGlscy51cGRhdGVEZWVwKHRoaXMuYXR0cnNfLCBERUZBVUxUX0FUVFJTKTtcblxuICB0aGlzLmJvdW5kYXJ5SWRzXyA9IFtdO1xuICB0aGlzLnNldEluZGV4QnlOYW1lXyA9IHt9O1xuICB0aGlzLmRhdGFzZXRJbmRleF8gPSBbXTtcblxuICB0aGlzLnJlZ2lzdGVyZWRFdmVudHNfID0gW107XG4gIHRoaXMuZXZlbnRMaXN0ZW5lcnNfID0ge307XG5cbiAgdGhpcy5hdHRyaWJ1dGVzXyA9IG5ldyBEeWdyYXBoT3B0aW9ucyh0aGlzKTtcblxuICAvLyBDcmVhdGUgdGhlIGNvbnRhaW5pbmcgRElWIGFuZCBvdGhlciBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuICB0aGlzLmNyZWF0ZUludGVyZmFjZV8oKTtcblxuICAvLyBBY3RpdmF0ZSBwbHVnaW5zLlxuICB0aGlzLnBsdWdpbnNfID0gW107XG4gIHZhciBwbHVnaW5zID0gRHlncmFwaC5QTFVHSU5TLmNvbmNhdCh0aGlzLmdldE9wdGlvbigncGx1Z2lucycpKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gdGhlIHBsdWdpbnMgb3B0aW9uIG1heSBjb250YWluIGVpdGhlciBwbHVnaW4gY2xhc3NlcyBvciBpbnN0YW5jZXMuXG4gICAgLy8gUGx1Z2luIGluc3RhbmNlcyBjb250YWluIGFuIGFjdGl2YXRlIG1ldGhvZC5cbiAgICB2YXIgUGx1Z2luID0gcGx1Z2luc1tpXTsgIC8vIGVpdGhlciBhIGNvbnN0cnVjdG9yIG9yIGFuIGluc3RhbmNlLlxuICAgIHZhciBwbHVnaW5JbnN0YW5jZTtcbiAgICBpZiAodHlwZW9mKFBsdWdpbi5hY3RpdmF0ZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwbHVnaW5JbnN0YW5jZSA9IFBsdWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luSW5zdGFuY2UgPSBuZXcgUGx1Z2luKCk7XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbkRpY3QgPSB7XG4gICAgICBwbHVnaW46IHBsdWdpbkluc3RhbmNlLFxuICAgICAgZXZlbnRzOiB7fSxcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgcGx1Z2luT3B0aW9uczoge31cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZXJzID0gcGx1Z2luSW5zdGFuY2UuYWN0aXZhdGUodGhpcyk7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoIWhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgLy8gVE9ETyhkYW52ayk6IHZhbGlkYXRlIGV2ZW50TmFtZS5cbiAgICAgIHBsdWdpbkRpY3QuZXZlbnRzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIHRoaXMucGx1Z2luc18ucHVzaChwbHVnaW5EaWN0KTtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHBsdWdpbnMgY2FuIG5vIGxvbmdlciByZWdpc3RlciBldmVudCBoYW5kbGVycy5cbiAgLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZXZlbnQgLT4gb3JkZXJlZCBsaXN0IG9mIFtjYWxsYmFjaywgcGx1Z2luXS5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsdWdpbl9kaWN0ID0gdGhpcy5wbHVnaW5zX1tpXTtcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcGx1Z2luX2RpY3QuZXZlbnRzKSB7XG4gICAgICBpZiAoIXBsdWdpbl9kaWN0LmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSBjb250aW51ZTtcbiAgICAgIHZhciBjYWxsYmFjayA9IHBsdWdpbl9kaWN0LmV2ZW50c1tldmVudE5hbWVdO1xuXG4gICAgICB2YXIgcGFpciA9IFtwbHVnaW5fZGljdC5wbHVnaW4sIGNhbGxiYWNrXTtcbiAgICAgIGlmICghKGV2ZW50TmFtZSBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzXykpIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc19bZXZlbnROYW1lXSA9IFtwYWlyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNfW2V2ZW50TmFtZV0ucHVzaChwYWlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmNyZWF0ZURyYWdJbnRlcmZhY2VfKCk7XG5cbiAgdGhpcy5zdGFydF8oKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgYSBjYXNjYWRlIG9mIGV2ZW50cyB0byB0aGUgdmFyaW91cyBwbHVnaW5zIHdoaWNoIGFyZSBpbnRlcmVzdGVkIGluIHRoZW0uXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIFwiZGVmYXVsdCBiZWhhdmlvclwiIHNob3VsZCBiZSBwcmV2ZW50ZWQsIGkuZS4gaWYgb25lXG4gKiBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzIGNhbGxlZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2FzY2FkZUV2ZW50c18gPSBmdW5jdGlvbihuYW1lLCBleHRyYV9wcm9wcykge1xuICBpZiAoIShuYW1lIGluIHRoaXMuZXZlbnRMaXN0ZW5lcnNfKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFFVRVNUSU9OOiBjYW4gd2UgdXNlIG9iamVjdHMgJiBwcm90b3R5cGVzIHRvIHNwZWVkIHRoaXMgdXA/XG4gIHZhciBlID0ge1xuICAgIGR5Z3JhcGg6IHRoaXMsXG4gICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgZGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFlLmNhbmNlbGFibGUpIHRocm93IFwiQ2Fubm90IGNhbGwgcHJldmVudERlZmF1bHQgb24gbm9uLWNhbmNlbGFibGUgZXZlbnQuXCI7XG4gICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgcHJvcGFnYXRpb25TdG9wcGVkOiBmYWxzZSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgZS5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgdXRpbHMudXBkYXRlKGUsIGV4dHJhX3Byb3BzKTtcblxuICB2YXIgY2FsbGJhY2tfcGx1Z2luX3BhaXJzID0gdGhpcy5ldmVudExpc3RlbmVyc19bbmFtZV07XG4gIGlmIChjYWxsYmFja19wbHVnaW5fcGFpcnMpIHtcbiAgICBmb3IgKHZhciBpID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGx1Z2luID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzW2ldWzBdO1xuICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tfcGx1Z2luX3BhaXJzW2ldWzFdO1xuICAgICAgY2FsbGJhY2suY2FsbChwbHVnaW4sIGUpO1xuICAgICAgaWYgKGUucHJvcGFnYXRpb25TdG9wcGVkKSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBwbHVnaW4gaW5zdGFuY2Ugb2YgYSBwYXJ0aWN1bGFyIGNsYXNzLiBPbmx5IGZvciB0ZXN0aW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IUNsYXNzfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBwbHVnaW4uXG4gKiBAcmV0dXJuIHtPYmplY3R9IEluc3RhbmNlIG9mIHRoZSBwbHVnaW4sIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0UGx1Z2luSW5zdGFuY2VfID0gZnVuY3Rpb24odHlwZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGx1Z2luc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHRoaXMucGx1Z2luc19baV07XG4gICAgaWYgKHAucGx1Z2luIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgcmV0dXJuIHAucGx1Z2luO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgem9vbWVkIHN0YXR1cyBvZiB0aGUgY2hhcnQgZm9yIG9uZSBvciBib3RoIGF4ZXMuXG4gKlxuICogQXhpcyBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuIENhbiBiZSBzZXQgdG8gJ3gnIG9yICd5Jy5cbiAqXG4gKiBUaGUgem9vbWVkIHN0YXR1cyBmb3IgYW4gYXhpcyBpcyBzZXQgd2hlbmV2ZXIgYSB1c2VyIHpvb21zIHVzaW5nIHRoZSBtb3VzZVxuICogb3Igd2hlbiB0aGUgZGF0ZVdpbmRvdyBvciB2YWx1ZVJhbmdlIGFyZSB1cGRhdGVkICh1bmxlc3MgdGhlXG4gKiBpc1pvb21lZElnbm9yZVByb2dyYW1tYXRpY1pvb20gb3B0aW9uIGlzIGFsc28gc3BlY2lmaWVkKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuaXNab29tZWQgPSBmdW5jdGlvbihheGlzKSB7XG4gIGlmIChheGlzID09PSBudWxsIHx8IGF4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLnpvb21lZF94XyB8fCB0aGlzLnpvb21lZF95XztcbiAgfVxuICBpZiAoYXhpcyA9PT0gJ3gnKSByZXR1cm4gdGhpcy56b29tZWRfeF87XG4gIGlmIChheGlzID09PSAneScpIHJldHVybiB0aGlzLnpvb21lZF95XztcbiAgdGhyb3cgXCJheGlzIHBhcmFtZXRlciBpcyBbXCIgKyBheGlzICsgXCJdIG11c3QgYmUgbnVsbCwgJ3gnIG9yICd5Jy5cIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgRHlncmFwaCBvYmplY3QsIGluY2x1ZGluZyBpdHMgY29udGFpbmluZyBJRC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1haW5kaXYgPSB0aGlzLm1haW5kaXZfO1xuICB2YXIgaWQgPSAobWFpbmRpdiAmJiBtYWluZGl2LmlkKSA/IG1haW5kaXYuaWQgOiBtYWluZGl2O1xuICByZXR1cm4gXCJbRHlncmFwaCBcIiArIGlkICsgXCJdXCI7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBvcHRpb24uIFRoaXMgbWF5IGJlIHNldCBieSB0aGUgdXNlciAoZWl0aGVyIGluIHRoZVxuICogY29uc3RydWN0b3Igb3IgYnkgY2FsbGluZyB1cGRhdGVPcHRpb25zKSBvciBieSBkeWdyYXBocywgYW5kIG1heSBiZSBzZXQgdG8gYVxuICogcGVyLXNlcmllcyB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24sIGUuZy4gJ3JvbGxQZXJpb2QnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXJpZXNOYW1lXSBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHdoaWNoIHRoZSBvcHRpb25cbiAqIHdpbGwgYmUgYXBwbGllZC4gSWYgbm8gcGVyLXNlcmllcyB2YWx1ZSBvZiB0aGlzIG9wdGlvbiBpcyBhdmFpbGFibGUsIHRoZW5cbiAqIHRoZSBnbG9iYWwgdmFsdWUgaXMgcmV0dXJuZWQuIFRoaXMgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJuIHsgLi4uIH0gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmF0dHJfID0gZnVuY3Rpb24obmFtZSwgc2VyaWVzTmFtZSkge1xuICAvLyBGb3IgXCJwcm9kdWN0aW9uXCIgY29kZSwgdGhpcyBnZXRzIHJlbW92ZWQgYnkgdWdsaWZ5anMuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mKE9QVElPTlNfUkVGRVJFTkNFKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ011c3QgaW5jbHVkZSBvcHRpb25zIHJlZmVyZW5jZSBKUyBmb3IgdGVzdGluZycpO1xuICAgIH0gZWxzZSBpZiAoIU9QVElPTlNfUkVGRVJFTkNFLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEeWdyYXBocyBpcyB1c2luZyBwcm9wZXJ0eSAnICsgbmFtZSArICcsIHdoaWNoIGhhcyBubyAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2VudHJ5IGluIHRoZSBEeWdyYXBocy5PUFRJT05TX1JFRkVSRU5DRSBsaXN0aW5nLicpO1xuICAgICAgLy8gT25seSBsb2cgdGhpcyBlcnJvciBvbmNlLlxuICAgICAgT1BUSU9OU19SRUZFUkVOQ0VbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWVzTmFtZSA/IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yU2VyaWVzKG5hbWUsIHNlcmllc05hbWUpIDogdGhpcy5hdHRyaWJ1dGVzXy5nZXQobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGFuIG9wdGlvbiwgYXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvciBvciB2aWFcbiAqIHVwZGF0ZU9wdGlvbnMuIFlvdSBtYXkgcGFzcyBpbiBhbiAob3B0aW9uYWwpIHNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzXG4gKiB2YWx1ZXMgZm9yIHRoZSBvcHRpb24uXG4gKlxuICogQWxsIHZhbHVlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbW11dGFibGUuIElmIHlvdVxuICogbW9kaWZ5IHRoZW0sIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBjaGFuZ2VzIHdpbGwgYmUgaG9ub3JlZCBvciB0aGF0XG4gKiBkeWdyYXBocyB3aWxsIHJlbWFpbiBpbiBhIGNvbnNpc3RlbnQgc3RhdGUuIElmIHlvdSB3YW50IHRvIG1vZGlmeSBhbiBvcHRpb24sXG4gKiB1c2UgdXBkYXRlT3B0aW9ucygpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpIHtcbiAgcmV0dXJuIHRoaXMuYXR0cl8obmFtZSwgb3B0X3Nlcmllc05hbWUpO1xufTtcblxuLyoqXG4gKiBMaWtlIGdldE9wdGlvbigpLCBidXQgc3BlY2lmaWNhbGx5IHJldHVybnMgYSBudW1iZXIuXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gKGUuZy4gJ3N0cm9rZVdpZHRoJylcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Nlcmllc05hbWUgU2VyaWVzIG5hbWUgdG8gZ2V0IHBlci1zZXJpZXMgdmFsdWVzLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldE51bWVyaWNPcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle251bWJlcn0gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRTdHJpbmdPcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle3N0cmluZ30gKi8odGhpcy5nZXRPcHRpb24obmFtZSwgb3B0X3Nlcmllc05hbWUpKTtcbn07XG5cbi8qKlxuICogTGlrZSBnZXRPcHRpb24oKSwgYnV0IHNwZWNpZmljYWxseSByZXR1cm5zIGEgYm9vbGVhbi5cbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiAoZS5nLiAnc3Ryb2tlV2lkdGgnKVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc2VyaWVzTmFtZSBTZXJpZXMgbmFtZSB0byBnZXQgcGVyLXNlcmllcyB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldEJvb2xlYW5PcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle2Jvb2xlYW59ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG4vKipcbiAqIExpa2UgZ2V0T3B0aW9uKCksIGJ1dCBzcGVjaWZpY2FsbHkgcmV0dXJucyBhIGZ1bmN0aW9uLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIChlLmcuICdzdHJva2VXaWR0aCcpXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZXJpZXNOYW1lIFNlcmllcyBuYW1lIHRvIGdldCBwZXItc2VyaWVzIHZhbHVlcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLil9IFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0RnVuY3Rpb25PcHRpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzTmFtZSkge1xuICByZXR1cm4gLyoqIEB0eXBle2Z1bmN0aW9uKC4uLil9ICovKHRoaXMuZ2V0T3B0aW9uKG5hbWUsIG9wdF9zZXJpZXNOYW1lKSk7XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRPcHRpb25Gb3JBeGlzID0gZnVuY3Rpb24obmFtZSwgYXhpcykge1xuICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKG5hbWUsIGF4aXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgVGhlIG5hbWUgb2YgdGhlIGF4aXMgKGkuZS4gJ3gnLCAneScgb3IgJ3kyJylcbiAqIEByZXR1cm4geyAuLi4gfSBBIGZ1bmN0aW9uIG1hcHBpbmcgc3RyaW5nIC0+IG9wdGlvbiB2YWx1ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5vcHRpb25zVmlld0ZvckF4aXNfID0gZnVuY3Rpb24oYXhpcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihvcHQpIHtcbiAgICB2YXIgYXhpc19vcHRzID0gc2VsZi51c2VyX2F0dHJzXy5heGVzO1xuICAgIGlmIChheGlzX29wdHMgJiYgYXhpc19vcHRzW2F4aXNdICYmIGF4aXNfb3B0c1theGlzXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gYXhpc19vcHRzW2F4aXNdW29wdF07XG4gICAgfVxuXG4gICAgLy8gSSBkb24ndCBsaWtlIHRoYXQgdGhpcyBpcyBpbiBhIHNlY29uZCBzcG90LlxuICAgIGlmIChheGlzID09PSAneCcgJiYgb3B0ID09PSAnbG9nc2NhbGUnKSB7XG4gICAgICAvLyByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBUT0RPKGtvbmlnc2JlcmcpOiBwdWxsIHRoZSBkZWZhdWx0IGZyb20gYSBnbG9iYWwgZGVmYXVsdC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyB1c2VyLXNwZWNpZmllZCBhdHRyaWJ1dGVzIGFsd2F5cyB0cnVtcCBkZWZhdWx0cywgZXZlbiBpZiB0aGV5J3JlIGxlc3NcbiAgICAvLyBzcGVjaWZpYy5cbiAgICBpZiAodHlwZW9mKHNlbGYudXNlcl9hdHRyc19bb3B0XSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBzZWxmLnVzZXJfYXR0cnNfW29wdF07XG4gICAgfVxuXG4gICAgYXhpc19vcHRzID0gc2VsZi5hdHRyc18uYXhlcztcbiAgICBpZiAoYXhpc19vcHRzICYmIGF4aXNfb3B0c1theGlzXSAmJiBheGlzX29wdHNbYXhpc10uaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgcmV0dXJuIGF4aXNfb3B0c1theGlzXVtvcHRdO1xuICAgIH1cbiAgICAvLyBjaGVjayBvbGQtc3R5bGUgYXhpcyBvcHRpb25zXG4gICAgLy8gVE9ETyhkYW52ayk6IGFkZCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgaWYgZWl0aGVyIG9mIHRoZXNlIG1hdGNoLlxuICAgIGlmIChheGlzID09ICd5JyAmJiBzZWxmLmF4ZXNfWzBdLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgIHJldHVybiBzZWxmLmF4ZXNfWzBdW29wdF07XG4gICAgfSBlbHNlIGlmIChheGlzID09ICd5MicgJiYgc2VsZi5heGVzX1sxXS5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICByZXR1cm4gc2VsZi5heGVzX1sxXVtvcHRdO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZi5hdHRyXyhvcHQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvbGxpbmcgcGVyaW9kLCBhcyBzZXQgYnkgdGhlIHVzZXIgb3IgYW4gb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgcm9sbGluZyB3aW5kb3dcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucm9sbFBlcmlvZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb2xsUGVyaW9kXztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeC1yYW5nZS4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnkgem9vbWluZyxcbiAqIHBhbm5pbmcgb3IgYSBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtsZWZ0LCByaWdodF0uXG4gKiBJZiB0aGUgRHlncmFwaCBoYXMgZGF0ZXMgb24gdGhlIHgtYXhpcywgdGhlc2Ugd2lsbCBiZSBtaWxsaXMgc2luY2UgZXBvY2guXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnhBeGlzUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0ZVdpbmRvd18gPyB0aGlzLmRhdGVXaW5kb3dfIDogdGhpcy54QXhpc0V4dHJlbWVzKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvd2VyLSBhbmQgdXBwZXItYm91bmQgeC1heGlzIHZhbHVlcyBvZiB0aGVcbiAqIGRhdGEgc2V0LlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS54QXhpc0V4dHJlbWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYWQgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ3hSYW5nZVBhZCcpIC8gdGhpcy5wbG90dGVyXy5hcmVhLnc7XG4gIGlmICh0aGlzLm51bVJvd3MoKSA9PT0gMCkge1xuICAgIHJldHVybiBbMCAtIHBhZCwgMSArIHBhZF07XG4gIH1cbiAgdmFyIGxlZnQgPSB0aGlzLnJhd0RhdGFfWzBdWzBdO1xuICB2YXIgcmlnaHQgPSB0aGlzLnJhd0RhdGFfW3RoaXMucmF3RGF0YV8ubGVuZ3RoIC0gMV1bMF07XG4gIGlmIChwYWQpIHtcbiAgICAvLyBNdXN0IGtlZXAgdGhpcyBpbiBzeW5jIHdpdGggZHlncmFwaC1sYXlvdXQgX2V2YWx1YXRlTGltaXRzKClcbiAgICB2YXIgcmFuZ2UgPSByaWdodCAtIGxlZnQ7XG4gICAgbGVmdCAtPSByYW5nZSAqIHBhZDtcbiAgICByaWdodCArPSByYW5nZSAqIHBhZDtcbiAgfVxuICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeS1yYW5nZSBmb3IgYW4gYXhpcy4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnlcbiAqIHpvb21pbmcsIHBhbm5pbmcgb3IgYSBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMuIEF4aXMgaW5kaWNlcyBhcmUgemVyby1iYXNlZC4gSWZcbiAqIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGF4aXMuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtib3R0b20sIHRvcF0uXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnlBeGlzUmFuZ2UgPSBmdW5jdGlvbihpZHgpIHtcbiAgaWYgKHR5cGVvZihpZHgpID09IFwidW5kZWZpbmVkXCIpIGlkeCA9IDA7XG4gIGlmIChpZHggPCAwIHx8IGlkeCA+PSB0aGlzLmF4ZXNfLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBheGlzID0gdGhpcy5heGVzX1tpZHhdO1xuICByZXR1cm4gWyBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSwgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0gXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5LXZpc2libGUgeS1yYW5nZXMgZm9yIGVhY2ggYXhpcy4gVGhpcyBjYW4gYmUgYWZmZWN0ZWQgYnlcbiAqIHpvb21pbmcsIHBhbm5pbmcsIGNhbGxzIHRvIHVwZGF0ZU9wdGlvbnMsIGV0Yy5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgW2JvdHRvbSwgdG9wXSBwYWlycywgb25lIGZvciBlYWNoIHktYXhpcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUueUF4aXNSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICByZXQucHVzaCh0aGlzLnlBeGlzUmFuZ2UoaSkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBUT0RPKGRhbnZrKTogdXNlIHRoZXNlIGZ1bmN0aW9ucyB0aHJvdWdob3V0IGR5Z3JhcGhzLlxuLyoqXG4gKiBDb252ZXJ0IGZyb20gZGF0YSBjb29yZGluYXRlcyB0byBjYW52YXMvZGl2IFgvWSBjb29yZGluYXRlcy5cbiAqIElmIHNwZWNpZmllZCwgZG8gdGhpcyBjb252ZXJzaW9uIGZvciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBheGlzLiBVc2VzIHRoZSBmaXJzdCBheGlzIGJ5IGRlZmF1bHQuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXVxuICpcbiAqIE5vdGU6IHVzZSB0b0RvbVhDb29yZCBpbnN0ZWFkIG9mIHRvRG9tQ29vcmRzKHgsIG51bGwpIGFuZCB1c2UgdG9Eb21ZQ29vcmRcbiAqIGluc3RlYWQgb2YgdG9Eb21Db29yZHMobnVsbCwgeSwgYXhpcykuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tQ29vcmRzID0gZnVuY3Rpb24oeCwgeSwgYXhpcykge1xuICByZXR1cm4gWyB0aGlzLnRvRG9tWENvb3JkKHgpLCB0aGlzLnRvRG9tWUNvb3JkKHksIGF4aXMpIF07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBkYXRhIHggY29vcmRpbmF0ZXMgdG8gY2FudmFzL2RpdiBYIGNvb3JkaW5hdGUuXG4gKiBJZiBzcGVjaWZpZWQsIGRvIHRoaXMgY29udmVyc2lvbiBmb3IgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIGEgcGFydGljdWxhclxuICogYXhpcy5cbiAqIFJldHVybnMgYSBzaW5nbGUgdmFsdWUgb3IgbnVsbCBpZiB4IGlzIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tWENvb3JkID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFyZWEgPSB0aGlzLnBsb3R0ZXJfLmFyZWE7XG4gIHZhciB4UmFuZ2UgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgcmV0dXJuIGFyZWEueCArICh4IC0geFJhbmdlWzBdKSAvICh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pICogYXJlYS53O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gZGF0YSB4IGNvb3JkaW5hdGVzIHRvIGNhbnZhcy9kaXYgWSBjb29yZGluYXRlIGFuZCBvcHRpb25hbFxuICogYXhpcy4gVXNlcyB0aGUgZmlyc3QgYXhpcyBieSBkZWZhdWx0LlxuICpcbiAqIHJldHVybnMgYSBzaW5nbGUgdmFsdWUgb3IgbnVsbCBpZiB5IGlzIG51bGwuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnRvRG9tWUNvb3JkID0gZnVuY3Rpb24oeSwgYXhpcykge1xuICB2YXIgcGN0ID0gdGhpcy50b1BlcmNlbnRZQ29vcmQoeSwgYXhpcyk7XG5cbiAgaWYgKHBjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBhcmVhID0gdGhpcy5wbG90dGVyXy5hcmVhO1xuICByZXR1cm4gYXJlYS55ICsgcGN0ICogYXJlYS5oO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FudmFzL2RpdiBjb29yZHMgdG8gZGF0YSBjb29yZGluYXRlcy5cbiAqIElmIHNwZWNpZmllZCwgZG8gdGhpcyBjb252ZXJzaW9uIGZvciB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBwYXJ0aWN1bGFyXG4gKiBheGlzLiBVc2VzIHRoZSBmaXJzdCBheGlzIGJ5IGRlZmF1bHQuXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXS5cbiAqXG4gKiBOb3RlOiB1c2UgdG9EYXRhWENvb3JkIGluc3RlYWQgb2YgdG9EYXRhQ29vcmRzKHgsIG51bGwpIGFuZCB1c2UgdG9EYXRhWUNvb3JkXG4gKiBpbnN0ZWFkIG9mIHRvRGF0YUNvb3JkcyhudWxsLCB5LCBheGlzKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9EYXRhQ29vcmRzID0gZnVuY3Rpb24oeCwgeSwgYXhpcykge1xuICByZXR1cm4gWyB0aGlzLnRvRGF0YVhDb29yZCh4KSwgdGhpcy50b0RhdGFZQ29vcmQoeSwgYXhpcykgXTtcbn07XG5cbi8qKlxuICogQ29udmVydCBmcm9tIGNhbnZhcy9kaXYgeCBjb29yZGluYXRlIHRvIGRhdGEgY29vcmRpbmF0ZS5cbiAqXG4gKiBJZiB4IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RhdGFYQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHhSYW5nZSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuXG4gIGlmICghdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwibG9nc2NhbGVcIiwgJ3gnKSkge1xuICAgIHJldHVybiB4UmFuZ2VbMF0gKyAoeCAtIGFyZWEueCkgLyBhcmVhLncgKiAoeFJhbmdlWzFdIC0geFJhbmdlWzBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGN0ID0gKHggLSBhcmVhLngpIC8gYXJlYS53O1xuICAgIHJldHVybiB1dGlscy5sb2dSYW5nZUZyYWN0aW9uKHhSYW5nZVswXSwgeFJhbmdlWzFdLCBwY3QpO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW52YXMvZGl2IHkgY29vcmQgdG8gdmFsdWUuXG4gKlxuICogSWYgeSBpcyBudWxsLCB0aGlzIHJldHVybnMgbnVsbC5cbiAqIGlmIGF4aXMgaXMgbnVsbCwgdGhpcyB1c2VzIHRoZSBmaXJzdCBheGlzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b0RhdGFZQ29vcmQgPSBmdW5jdGlvbih5LCBheGlzKSB7XG4gIGlmICh5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHlSYW5nZSA9IHRoaXMueUF4aXNSYW5nZShheGlzKTtcblxuICBpZiAodHlwZW9mKGF4aXMpID09IFwidW5kZWZpbmVkXCIpIGF4aXMgPSAwO1xuICBpZiAoIXRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGF4aXMpKSB7XG4gICAgcmV0dXJuIHlSYW5nZVswXSArIChhcmVhLnkgKyBhcmVhLmggLSB5KSAvIGFyZWEuaCAqICh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXB1dGluZyB0aGUgaW52ZXJzZSBvZiB0b0RvbUNvb3JkLlxuICAgIHZhciBwY3QgPSAoeSAtIGFyZWEueSkgLyBhcmVhLmg7XG4gICAgLy8gTm90ZSByZXZlcnNlZCB5UmFuZ2UsIHkxIGlzIG9uIHRvcCB3aXRoIHBjdD09MC5cbiAgICByZXR1cm4gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih5UmFuZ2VbMV0sIHlSYW5nZVswXSwgcGN0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHkgZm9yIGFuIGF4aXMgdG8gYSBwZXJjZW50YWdlIGZyb20gdGhlIHRvcCB0byB0aGVcbiAqIGJvdHRvbSBvZiB0aGUgZHJhd2luZyBhcmVhLlxuICpcbiAqIElmIHRoZSBjb29yZGluYXRlIHJlcHJlc2VudHMgYSB2YWx1ZSB2aXNpYmxlIG9uIHRoZSBjYW52YXMsIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgdG9wIG9mIHRoZSBjYW52YXMuXG4gKiBIb3dldmVyLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB2YWx1ZXMgb3V0c2lkZSB0aGUgcmFuZ2UsIGFzXG4gKiB2YWx1ZXMgY2FuIGZhbGwgb3V0c2lkZSB0aGUgY2FudmFzLlxuICpcbiAqIElmIHkgaXMgbnVsbCwgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBpZiBheGlzIGlzIG51bGwsIHRoaXMgdXNlcyB0aGUgZmlyc3QgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgZGF0YSB5LWNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2F4aXNdIFRoZSBheGlzIG51bWJlciBvbiB3aGljaCB0aGUgZGF0YSBjb29yZGluYXRlIGxpdmVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBIGZyYWN0aW9uIGluIFswLCAxXSB3aGVyZSAwID0gdGhlIHRvcCBlZGdlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS50b1BlcmNlbnRZQ29vcmQgPSBmdW5jdGlvbih5LCBheGlzKSB7XG4gIGlmICh5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZihheGlzKSA9PSBcInVuZGVmaW5lZFwiKSBheGlzID0gMDtcblxuICB2YXIgeVJhbmdlID0gdGhpcy55QXhpc1JhbmdlKGF4aXMpO1xuXG4gIHZhciBwY3Q7XG4gIHZhciBsb2dzY2FsZSA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGF4aXMpO1xuICBpZiAobG9nc2NhbGUpIHtcbiAgICB2YXIgbG9ncjAgPSB1dGlscy5sb2cxMCh5UmFuZ2VbMF0pO1xuICAgIHZhciBsb2dyMSA9IHV0aWxzLmxvZzEwKHlSYW5nZVsxXSk7XG4gICAgcGN0ID0gKGxvZ3IxIC0gdXRpbHMubG9nMTAoeSkpIC8gKGxvZ3IxIC0gbG9ncjApO1xuICB9IGVsc2Uge1xuICAgIC8vIHlSYW5nZVsxXSAtIHkgaXMgdW5pdCBkaXN0YW5jZSBmcm9tIHRoZSBib3R0b20uXG4gICAgLy8geVJhbmdlWzFdIC0geVJhbmdlWzBdIGlzIHRoZSBzY2FsZSBvZiB0aGUgcmFuZ2UuXG4gICAgLy8gKHlSYW5nZVsxXSAtIHkpIC8gKHlSYW5nZVsxXSAtIHlSYW5nZVswXSkgaXMgdGhlICUgZnJvbSB0aGUgYm90dG9tLlxuICAgIHBjdCA9ICh5UmFuZ2VbMV0gLSB5KSAvICh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pO1xuICB9XG4gIHJldHVybiBwY3Q7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIHggdmFsdWUgdG8gYSBwZXJjZW50YWdlIGZyb20gdGhlIGxlZnQgdG8gdGhlIHJpZ2h0IG9mXG4gKiB0aGUgZHJhd2luZyBhcmVhLlxuICpcbiAqIElmIHRoZSBjb29yZGluYXRlIHJlcHJlc2VudHMgYSB2YWx1ZSB2aXNpYmxlIG9uIHRoZSBjYW52YXMsIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgbGVmdCBvZiB0aGUgY2FudmFzLlxuICogSG93ZXZlciwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdmFsdWVzIG91dHNpZGUgdGhlIHJhbmdlLCBhc1xuICogdmFsdWVzIGNhbiBmYWxsIG91dHNpZGUgdGhlIGNhbnZhcy5cbiAqXG4gKiBJZiB4IGlzIG51bGwsIHRoaXMgcmV0dXJucyBudWxsLlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGRhdGEgeC1jb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBIGZyYWN0aW9uIGluIFswLCAxXSB3aGVyZSAwID0gdGhlIGxlZnQgZWRnZS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudG9QZXJjZW50WENvb3JkID0gZnVuY3Rpb24oeCkge1xuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHhSYW5nZSA9IHRoaXMueEF4aXNSYW5nZSgpO1xuICB2YXIgcGN0O1xuICB2YXIgbG9nc2NhbGUgPSB0aGlzLmF0dHJpYnV0ZXNfLmdldEZvckF4aXMoXCJsb2dzY2FsZVwiLCAneCcpIDtcbiAgaWYgKGxvZ3NjYWxlID09PSB0cnVlKSB7ICAvLyBsb2dzY2FsZSBjYW4gYmUgbnVsbCBzbyB3ZSB0ZXN0IGZvciB0cnVlIGV4cGxpY2l0bHkuXG4gICAgdmFyIGxvZ3IwID0gdXRpbHMubG9nMTAoeFJhbmdlWzBdKTtcbiAgICB2YXIgbG9ncjEgPSB1dGlscy5sb2cxMCh4UmFuZ2VbMV0pO1xuICAgIHBjdCA9ICh1dGlscy5sb2cxMCh4KSAtIGxvZ3IwKSAvIChsb2dyMSAtIGxvZ3IwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB4IC0geFJhbmdlWzBdIGlzIHVuaXQgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdC5cbiAgICAvLyB4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0gaXMgdGhlIHNjYWxlIG9mIHRoZSByYW5nZS5cbiAgICAvLyBUaGUgZnVsbCBleHByZXNzaW9uIGJlbG93IGlzIHRoZSAlIGZyb20gdGhlIGxlZnQuXG4gICAgcGN0ID0gKHggLSB4UmFuZ2VbMF0pIC8gKHhSYW5nZVsxXSAtIHhSYW5nZVswXSk7XG4gIH1cbiAgcmV0dXJuIHBjdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKGluY2x1ZGluZyB0aGUgaW5kZXBlbmRlbnQgdmFyaWFibGUpLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm51bUNvbHVtbnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnJhd0RhdGFfKSByZXR1cm4gMDtcbiAgcmV0dXJuIHRoaXMucmF3RGF0YV9bMF0gPyB0aGlzLnJhd0RhdGFfWzBdLmxlbmd0aCA6IHRoaXMuYXR0cl8oXCJsYWJlbHNcIikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyAoZXhjbHVkaW5nIGFueSBoZWFkZXIvbGFiZWwgcm93KS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzLCBsZXNzIGFueSBoZWFkZXIuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm51bVJvd3MgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnJhd0RhdGFfKSByZXR1cm4gMDtcbiAgcmV0dXJuIHRoaXMucmF3RGF0YV8ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW4uIElmIHRoZSByb3cgYW5kIGNvbHVtbiBleGNlZWRcbiAqIHRoZSBib3VuZHMgb24gdGhlIGRhdGEsIHJldHVybnMgbnVsbC4gQWxzbyByZXR1cm5zIG51bGwgaWYgdGhlIHZhbHVlIGlzXG4gKiBtaXNzaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdyBUaGUgcm93IG51bWJlciBvZiB0aGUgZGF0YSAoMC1iYXNlZCkuIFJvdyAwIGlzIHRoZVxuICogICAgIGZpcnN0IHJvdyBvZiBkYXRhLCBub3QgYSBoZWFkZXIgcm93LlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIG51bWJlciBvZiB0aGUgZGF0YSAoMC1iYXNlZClcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGluIHRoZSBzcGVjaWZpZWQgY2VsbCBvciBudWxsIGlmIHRoZSByb3cvY29sXG4gKiAgICAgd2VyZSBvdXQgb2YgcmFuZ2UuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgaWYgKHJvdyA8IDAgfHwgcm93ID4gdGhpcy5yYXdEYXRhXy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBpZiAoY29sIDwgMCB8fCBjb2wgPiB0aGlzLnJhd0RhdGFfW3Jvd10ubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gdGhpcy5yYXdEYXRhX1tyb3ddW2NvbF07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIHRoZSBEeWdyYXBoOiBhIGNvbnRhaW5pbmcgZGl2LCBhIGRpdiB0b1xuICogZGlzcGxheSB0aGUgY3VycmVudCBwb2ludCwgYW5kIGEgdGV4dGJveCB0byBhZGp1c3QgdGhlIHJvbGxpbmcgYXZlcmFnZVxuICogcGVyaW9kLiBBbHNvIGNyZWF0ZXMgdGhlIFJlbmRlcmVyL0xheW91dCBlbGVtZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZUludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgLy8gQ3JlYXRlIHRoZSBhbGwtZW5jbG9zaW5nIGdyYXBoIGRpdlxuICB2YXIgZW5jbG9zaW5nID0gdGhpcy5tYWluZGl2XztcblxuICB0aGlzLmdyYXBoRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAvLyBUT0RPKGRhbnZrKTogYW55IG90aGVyIHN0eWxlcyB0aGF0IGFyZSB1c2VmdWwgdG8gc2V0IGhlcmU/XG4gIHRoaXMuZ3JhcGhEaXYuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnOyAgLy8gVGhpcyBpcyBhIENTUyBcInJlc2V0XCJcbiAgdGhpcy5ncmFwaERpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGVuY2xvc2luZy5hcHBlbmRDaGlsZCh0aGlzLmdyYXBoRGl2KTtcblxuICAvLyBDcmVhdGUgdGhlIGNhbnZhcyBmb3IgaW50ZXJhY3RpdmUgcGFydHMgb2YgdGhlIGNoYXJ0LlxuICB0aGlzLmNhbnZhc18gPSB1dGlscy5jcmVhdGVDYW52YXMoKTtcbiAgdGhpcy5jYW52YXNfLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gIC8vIC4uLiBhbmQgZm9yIHN0YXRpYyBwYXJ0cyBvZiB0aGUgY2hhcnQuXG4gIHRoaXMuaGlkZGVuXyA9IHRoaXMuY3JlYXRlUGxvdEtpdENhbnZhc18odGhpcy5jYW52YXNfKTtcblxuICB0aGlzLmNhbnZhc19jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmNhbnZhc18pO1xuICB0aGlzLmhpZGRlbl9jdHhfID0gdXRpbHMuZ2V0Q29udGV4dCh0aGlzLmhpZGRlbl8pO1xuXG4gIHRoaXMucmVzaXplRWxlbWVudHNfKCk7XG5cbiAgLy8gVGhlIGludGVyYWN0aXZlIHBhcnRzIG9mIHRoZSBncmFwaCBhcmUgZHJhd24gb24gdG9wIG9mIHRoZSBjaGFydC5cbiAgdGhpcy5ncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlbl8pO1xuICB0aGlzLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzXyk7XG4gIHRoaXMubW91c2VFdmVudEVsZW1lbnRfID0gdGhpcy5jcmVhdGVNb3VzZUV2ZW50RWxlbWVudF8oKTtcblxuICAvLyBDcmVhdGUgdGhlIGdyYXBoZXJcbiAgdGhpcy5sYXlvdXRfID0gbmV3IER5Z3JhcGhMYXlvdXQodGhpcyk7XG5cbiAgdmFyIGR5Z3JhcGggPSB0aGlzO1xuXG4gIHRoaXMubW91c2VNb3ZlSGFuZGxlcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgZHlncmFwaC5tb3VzZU1vdmVfKGUpO1xuICB9O1xuXG4gIHRoaXMubW91c2VPdXRIYW5kbGVyXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBUaGUgbW91c2UgaGFzIGxlZnQgdGhlIGNoYXJ0IGlmOlxuICAgIC8vIDEuIGUudGFyZ2V0IGlzIGluc2lkZSB0aGUgY2hhcnRcbiAgICAvLyAyLiBlLnJlbGF0ZWRUYXJnZXQgaXMgb3V0c2lkZSB0aGUgY2hhcnRcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5mcm9tRWxlbWVudDtcbiAgICB2YXIgcmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudDtcbiAgICBpZiAodXRpbHMuaXNOb2RlQ29udGFpbmVkQnkodGFyZ2V0LCBkeWdyYXBoLmdyYXBoRGl2KSAmJlxuICAgICAgICAhdXRpbHMuaXNOb2RlQ29udGFpbmVkQnkocmVsYXRlZFRhcmdldCwgZHlncmFwaC5ncmFwaERpdikpIHtcbiAgICAgIGR5Z3JhcGgubW91c2VPdXRfKGUpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQod2luZG93LCAnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcl8pO1xuICB0aGlzLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5tb3VzZUV2ZW50RWxlbWVudF8sICdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXJfKTtcblxuICAvLyBEb24ndCByZWNyZWF0ZSBhbmQgcmVnaXN0ZXIgdGhlIHJlc2l6ZSBoYW5kbGVyIG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBncmFwaCBpcyByZXNpemVkLlxuICBpZiAoIXRoaXMucmVzaXplSGFuZGxlcl8pIHtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gZnVuY3Rpb24oZSkge1xuICAgICAgZHlncmFwaC5yZXNpemUoKTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHdoZW4gdGhlIHdpbmRvdyBpcyByZXNpemVkLlxuICAgIC8vIFRPRE8oZGFudmspOiBkcm9wIGZyYW1lcyBkZXBlbmRpbmcgb24gY29tcGxleGl0eSBvZiB0aGUgY2hhcnQuXG4gICAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5yZXNpemVFbGVtZW50c18gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaERpdi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiO1xuICB0aGlzLmdyYXBoRGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyArIFwicHhcIjtcblxuICB2YXIgY2FudmFzU2NhbGUgPSB1dGlscy5nZXRDb250ZXh0UGl4ZWxSYXRpbyh0aGlzLmNhbnZhc19jdHhfKTtcbiAgdGhpcy5jYW52YXNfLndpZHRoID0gdGhpcy53aWR0aF8gKiBjYW52YXNTY2FsZTtcbiAgdGhpcy5jYW52YXNfLmhlaWdodCA9IHRoaXMuaGVpZ2h0XyAqIGNhbnZhc1NjYWxlO1xuICB0aGlzLmNhbnZhc18uc3R5bGUud2lkdGggPSB0aGlzLndpZHRoXyArIFwicHhcIjsgICAgLy8gZm9yIElFXG4gIHRoaXMuY2FudmFzXy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7ICAvLyBmb3IgSUVcbiAgaWYgKGNhbnZhc1NjYWxlICE9PSAxKSB7XG4gICAgdGhpcy5jYW52YXNfY3R4Xy5zY2FsZShjYW52YXNTY2FsZSwgY2FudmFzU2NhbGUpO1xuICB9XG5cbiAgdmFyIGhpZGRlblNjYWxlID0gdXRpbHMuZ2V0Q29udGV4dFBpeGVsUmF0aW8odGhpcy5oaWRkZW5fY3R4Xyk7XG4gIHRoaXMuaGlkZGVuXy53aWR0aCA9IHRoaXMud2lkdGhfICogaGlkZGVuU2NhbGU7XG4gIHRoaXMuaGlkZGVuXy5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKiBoaWRkZW5TY2FsZTtcbiAgdGhpcy5oaWRkZW5fLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aF8gKyBcInB4XCI7ICAgIC8vIGZvciBJRVxuICB0aGlzLmhpZGRlbl8uc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHRfICsgXCJweFwiOyAgLy8gZm9yIElFXG4gIGlmIChoaWRkZW5TY2FsZSAhPT0gMSkge1xuICAgIHRoaXMuaGlkZGVuX2N0eF8uc2NhbGUoaGlkZGVuU2NhbGUsIGhpZGRlblNjYWxlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXRhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBkeWdyYXBoIGFuZCBudWxsIG91dCBhbGwgZGF0YSByZWZlcmVuY2VzLlxuICogQ2FsbGluZyB0aGlzIHdoZW4geW91J3JlIGRvbmUgd2l0aCBhIGR5Z3JhcGggY2FuIGRyYW1hdGljYWxseSByZWR1Y2UgbWVtb3J5XG4gKiB1c2FnZS4gU2VlLCBlLmcuLCB0aGUgdGVzdHMvcGVyZi5odG1sIGV4YW1wbGUuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jYW52YXNfY3R4Xy5yZXN0b3JlKCk7XG4gIHRoaXMuaGlkZGVuX2N0eF8ucmVzdG9yZSgpO1xuXG4gIC8vIERlc3Ryb3kgYW55IHBsdWdpbnMsIGluIHRoZSByZXZlcnNlIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG4gIGZvciAodmFyIGkgPSB0aGlzLnBsdWdpbnNfLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBsdWdpbnNfLnBvcCgpO1xuICAgIGlmIChwLnBsdWdpbi5kZXN0cm95KSBwLnBsdWdpbi5kZXN0cm95KCk7XG4gIH1cblxuICB2YXIgcmVtb3ZlUmVjdXJzaXZlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgcmVtb3ZlUmVjdXJzaXZlKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMucmVtb3ZlVHJhY2tlZEV2ZW50c18oKTtcblxuICAvLyByZW1vdmUgbW91c2UgZXZlbnQgaGFuZGxlcnMgKFRoaXMgbWF5IG5vdCBiZSBuZWNlc3NhcnkgYW55bW9yZSlcbiAgdXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0SGFuZGxlcl8pO1xuICB1dGlscy5yZW1vdmVFdmVudCh0aGlzLm1vdXNlRXZlbnRFbGVtZW50XywgJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcl8pO1xuXG4gIC8vIHJlbW92ZSB3aW5kb3cgaGFuZGxlcnNcbiAgdXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgdGhpcy5yZXNpemVIYW5kbGVyXyA9IG51bGw7XG5cbiAgcmVtb3ZlUmVjdXJzaXZlKHRoaXMubWFpbmRpdl8pO1xuXG4gIHZhciBudWxsT3V0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgbiBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Yob2JqW25dKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb2JqW25dID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZXNlIG1heSBub3QgYWxsIGJlIG5lY2Vzc2FyeSwgYnV0IGl0IGNhbid0IGh1cnQuLi5cbiAgbnVsbE91dCh0aGlzLmxheW91dF8pO1xuICBudWxsT3V0KHRoaXMucGxvdHRlcl8pO1xuICBudWxsT3V0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBjYW52YXMgb24gd2hpY2ggdGhlIGNoYXJ0IHdpbGwgYmUgZHJhd24uIE9ubHkgdGhlIFJlbmRlcmVyIGV2ZXJcbiAqIGRyYXdzIG9uIHRoaXMgcGFydGljdWxhciBjYW52YXMuIEFsbCBEeWdyYXBoIHdvcmsgKGkuZS4gZHJhd2luZyBob3ZlciBkb3RzXG4gKiBvciB0aGUgem9vbSByZWN0YW5nbGVzKSBpcyBkb25lIG9uIHRoaXMuY2FudmFzXy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXMgVGhlIER5Z3JhcGggY2FudmFzIG92ZXIgd2hpY2ggdG8gb3ZlcmxheSB0aGUgcGxvdFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3bHktY3JlYXRlZCBjYW52YXNcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNyZWF0ZVBsb3RLaXRDYW52YXNfID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIHZhciBoID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIGguc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIC8vIFRPRE8oZGFudmspOiBoIHNob3VsZCBiZSBvZmZzZXQgZnJvbSBjYW52YXMuIGNhbnZhcyBuZWVkcyB0byBpbmNsdWRlXG4gIC8vIHNvbWUgZXh0cmEgYXJlYSB0byBtYWtlIGl0IGVhc2llciB0byB6b29tIGluIG9uIHRoZSBmYXIgbGVmdCBhbmQgZmFyXG4gIC8vIHJpZ2h0LiBoIG5lZWRzIHRvIGJlIHByZWNpc2VseSB0aGUgcGxvdCBhcmVhLCBzbyB0aGF0IGNsaXBwaW5nIG9jY3Vycy5cbiAgaC5zdHlsZS50b3AgPSBjYW52YXMuc3R5bGUudG9wO1xuICBoLnN0eWxlLmxlZnQgPSBjYW52YXMuc3R5bGUubGVmdDtcbiAgaC53aWR0aCA9IHRoaXMud2lkdGhfO1xuICBoLmhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgaC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGhfICsgXCJweFwiOyAgICAvLyBmb3IgSUVcbiAgaC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodF8gKyBcInB4XCI7ICAvLyBmb3IgSUVcbiAgcmV0dXJuIGg7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb3ZlcmxheSBlbGVtZW50IHVzZWQgdG8gaGFuZGxlIG1vdXNlIGV2ZW50cy5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1vdXNlIGV2ZW50IGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jcmVhdGVNb3VzZUV2ZW50RWxlbWVudF8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzXztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgZGlzdGluY3QgY29sb3JzIGZvciB0aGUgZGF0YSBzZXJpZXMuIFRoaXMgaXMgZG9uZSB3aXRoIGFcbiAqIGNvbG9yIHdoZWVsLiBTYXR1cmF0aW9uL1ZhbHVlIGFyZSBjdXN0b21pemFibGUsIGFuZCB0aGUgaHVlIGlzXG4gKiBlcXVhbGx5LXNwYWNlZCBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLiBJZiBhIGN1c3RvbSBzZXQgb2YgY29sb3JzIGlzXG4gKiBzcGVjaWZpZWQsIHRoYXQgaXMgdXNlZCBpbnN0ZWFkLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0Q29sb3JzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgdmFyIG51bSA9IGxhYmVscy5sZW5ndGggLSAxO1xuICB0aGlzLmNvbG9yc18gPSBbXTtcbiAgdGhpcy5jb2xvcnNNYXBfID0ge307XG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgZm9yIHdoZW4gbm8gY3VzdG9tIGNvbG9ycyBhcmUgc3BlY2lmaWVkLlxuICB2YXIgc2F0ID0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdjb2xvclNhdHVyYXRpb24nKSB8fCAxLjA7XG4gIHZhciB2YWwgPSB0aGlzLmdldE51bWVyaWNPcHRpb24oJ2NvbG9yVmFsdWUnKSB8fCAwLjU7XG4gIHZhciBoYWxmID0gTWF0aC5jZWlsKG51bSAvIDIpO1xuXG4gIHZhciBjb2xvcnMgPSB0aGlzLmdldE9wdGlvbignY29sb3JzJyk7XG4gIHZhciB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmlsaXR5KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICBpZiAoIXZpc2liaWxpdHlbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbGFiZWwgPSBsYWJlbHNbaSArIDFdO1xuICAgIHZhciBjb2xvclN0ciA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yU2VyaWVzKCdjb2xvcicsIGxhYmVsKTtcbiAgICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JzW2kgJSBjb2xvcnMubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsdGVybmF0ZSBjb2xvcnMgZm9yIGhpZ2ggY29udHJhc3QuXG4gICAgICAgIHZhciBpZHggPSBpICUgMiA/IChoYWxmICsgKGkgKyAxKS8gMikgOiBNYXRoLmNlaWwoKGkgKyAxKSAvIDIpO1xuICAgICAgICB2YXIgaHVlID0gKDEuMCAqIGlkeCAvICgxICsgbnVtKSk7XG4gICAgICAgIGNvbG9yU3RyID0gdXRpbHMuaHN2VG9SR0IoaHVlLCBzYXQsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29sb3JzXy5wdXNoKGNvbG9yU3RyKTtcbiAgICB0aGlzLmNvbG9yc01hcF9bbGFiZWxdID0gY29sb3JTdHI7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0IG9mIGNvbG9ycy4gVGhpcyBpcyBlaXRoZXIgdGhlIGxpc3Qgb2YgY29sb3JzIHBhc3NlZCBpbiB0aGVcbiAqIGF0dHJpYnV0ZXMgb3IgdGhlIGF1dG9nZW5lcmF0ZWQgbGlzdCBvZiByZ2IocixnLGIpIHN0cmluZ3MuXG4gKiBUaGlzIGRvZXMgbm90IHJldHVybiBjb2xvcnMgZm9yIGludmlzaWJsZSBzZXJpZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gVGhlIGxpc3Qgb2YgY29sb3JzLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRDb2xvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29sb3JzXztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZldyBhdHRyaWJ1dGVzIG9mIGEgc2VyaWVzLCBpLmUuIGl0cyBjb2xvciwgaXRzIHZpc2liaWxpdHksIHdoaWNoXG4gKiBheGlzIGl0J3MgYXNzaWduZWQgdG8sIGFuZCBpdHMgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBkYXRhLlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBzZXJpZXMgZG9lcyBub3QgZXhpc3QuXG4gKiBPdGhlcndpc2UsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggY29sdW1uLCB2aXNpYmlsaXR5LCBjb2xvciBhbmQgYXhpcyBwcm9wZXJ0aWVzLlxuICogVGhlIFwiYXhpc1wiIHByb3BlcnR5IHdpbGwgYmUgc2V0IHRvIDEgZm9yIHkxIGFuZCAyIGZvciB5Mi5cbiAqIFRoZSBcImNvbHVtblwiIHByb3BlcnR5IGNhbiBiZSBmZWQgYmFjayBpbnRvIGdldFZhbHVlKHJvdywgY29sdW1uKSB0byBnZXRcbiAqIHZhbHVlcyBmb3IgdGhpcyBzZXJpZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdldFByb3BlcnRpZXNGb3JTZXJpZXMgPSBmdW5jdGlvbihzZXJpZXNfbmFtZSkge1xuICB2YXIgaWR4ID0gLTE7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsYWJlbHNbaV0gPT0gc2VyaWVzX25hbWUpIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGlkeCA9PSAtMSkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBzZXJpZXNfbmFtZSxcbiAgICBjb2x1bW46IGlkeCxcbiAgICB2aXNpYmxlOiB0aGlzLnZpc2liaWxpdHkoKVtpZHggLSAxXSxcbiAgICBjb2xvcjogdGhpcy5jb2xvcnNNYXBfW3Nlcmllc19uYW1lXSxcbiAgICBheGlzOiAxICsgdGhpcy5hdHRyaWJ1dGVzXy5heGlzRm9yU2VyaWVzKHNlcmllc19uYW1lKVxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIHRleHQgYm94IHRvIGFkanVzdCB0aGUgYXZlcmFnaW5nIHBlcmlvZFxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlUm9sbEludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgLy8gQ3JlYXRlIGEgcm9sbGVyIGlmIG9uZSBkb2Vzbid0IGV4aXN0IGFscmVhZHkuXG4gIGlmICghdGhpcy5yb2xsZXJfKSB7XG4gICAgdGhpcy5yb2xsZXJfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIHRoaXMucm9sbGVyXy50eXBlID0gXCJ0ZXh0XCI7XG4gICAgdGhpcy5yb2xsZXJfLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB0aGlzLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMucm9sbGVyXyk7XG4gIH1cblxuICB2YXIgZGlzcGxheSA9IHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignc2hvd1JvbGxlcicpID8gJ2Jsb2NrJyA6ICdub25lJztcblxuICB2YXIgYXJlYSA9IHRoaXMucGxvdHRlcl8uYXJlYTtcbiAgdmFyIHRleHRBdHRyID0geyBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICBcInpJbmRleFwiOiAxMCxcbiAgICAgICAgICAgICAgICAgICBcInRvcFwiOiAoYXJlYS55ICsgYXJlYS5oIC0gMjUpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiAoYXJlYS54ICsgMSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgIH07XG4gIHRoaXMucm9sbGVyXy5zaXplID0gXCIyXCI7XG4gIHRoaXMucm9sbGVyXy52YWx1ZSA9IHRoaXMucm9sbFBlcmlvZF87XG4gIGZvciAodmFyIG5hbWUgaW4gdGV4dEF0dHIpIHtcbiAgICBpZiAodGV4dEF0dHIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHRoaXMucm9sbGVyXy5zdHlsZVtuYW1lXSA9IHRleHRBdHRyW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkeWdyYXBoID0gdGhpcztcbiAgdGhpcy5yb2xsZXJfLm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7IGR5Z3JhcGguYWRqdXN0Um9sbChkeWdyYXBoLnJvbGxlcl8udmFsdWUpOyB9O1xufTtcblxuLyoqXG4gKiBTZXQgdXAgYWxsIHRoZSBtb3VzZSBoYW5kbGVycyBuZWVkZWQgdG8gY2FwdHVyZSBkcmFnZ2luZyBiZWhhdmlvciBmb3Igem9vbVxuICogZXZlbnRzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY3JlYXRlRHJhZ0ludGVyZmFjZV8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgLy8gVHJhY2tzIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGRvd24gcmlnaHQgbm93XG4gICAgaXNab29taW5nOiBmYWxzZSxcbiAgICBpc1Bhbm5pbmc6IGZhbHNlLCAgLy8gaXMgdGhpcyBkcmFnIHBhcnQgb2YgYSBwYW4/XG4gICAgaXMyRFBhbjogZmFsc2UsICAgIC8vIGlmIHNvLCBpcyB0aGF0IHBhbiAxLSBvciAyLWRpbWVuc2lvbmFsP1xuICAgIGRyYWdTdGFydFg6IG51bGwsIC8vIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgZHJhZ1N0YXJ0WTogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRW5kWDogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRW5kWTogbnVsbCwgLy8gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICBkcmFnRGlyZWN0aW9uOiBudWxsLFxuICAgIHByZXZFbmRYOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIHByZXZFbmRZOiBudWxsLCAvLyBwaXhlbCBjb29yZGluYXRlc1xuICAgIHByZXZEcmFnRGlyZWN0aW9uOiBudWxsLFxuICAgIGNhbmNlbE5leHREYmxjbGljazogZmFsc2UsICAvLyBzZWUgY29tbWVudCBpbiBkeWdyYXBoLWludGVyYWN0aW9uLW1vZGVsLmpzXG5cbiAgICAvLyBUaGUgdmFsdWUgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZ3JhcGggd2hlbiBhIHBhbiBvcGVyYXRpb24gc3RhcnRzLlxuICAgIGluaXRpYWxMZWZ0bW9zdERhdGU6IG51bGwsXG5cbiAgICAvLyBUaGUgbnVtYmVyIG9mIHVuaXRzIGVhY2ggcGl4ZWwgc3BhbnMuIChUaGlzIHdvbid0IGJlIHZhbGlkIGZvciBsb2dcbiAgICAvLyBzY2FsZXMpXG4gICAgeFVuaXRzUGVyUGl4ZWw6IG51bGwsXG5cbiAgICAvLyBUT0RPKGRhbnZrKTogdXBkYXRlIHRoaXMgY29tbWVudFxuICAgIC8vIFRoZSByYW5nZSBpbiBzZWNvbmQvdmFsdWUgdW5pdHMgdGhhdCB0aGUgdmlld3BvcnQgZW5jb21wYXNzZXMgZHVyaW5nIGFcbiAgICAvLyBwYW5uaW5nIG9wZXJhdGlvbi5cbiAgICBkYXRlUmFuZ2U6IG51bGwsXG5cbiAgICAvLyBUb3AtbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcywgaW4gRE9NIGNvb3Jkc1xuICAgIC8vIFRPRE8oa29uaWdzYmVyZyk6IFJlbmFtZSB0b3BMZWZ0Q2FudmFzWCwgdG9wTGVmdENhbnZhc1kuXG4gICAgcHg6IDAsXG4gICAgcHk6IDAsXG5cbiAgICAvLyBWYWx1ZXMgZm9yIHVzZSB3aXRoIHBhbkVkZ2VGcmFjdGlvbiwgd2hpY2ggbGltaXQgaG93IGZhciBvdXRzaWRlIHRoZVxuICAgIC8vIGdyYXBoJ3MgZGF0YSBib3VuZGFyaWVzIGl0IGNhbiBiZSBwYW5uZWQuXG4gICAgYm91bmRlZERhdGVzOiBudWxsLCAvLyBbbWluRGF0ZSwgbWF4RGF0ZV1cbiAgICBib3VuZGVkVmFsdWVzOiBudWxsLCAvLyBbW21pblZhbHVlLCBtYXhWYWx1ZV0gLi4uXVxuXG4gICAgLy8gV2UgY292ZXIgaWZyYW1lcyBkdXJpbmcgbW91c2UgaW50ZXJhY3Rpb25zLiBTZWUgY29tbWVudHMgaW5cbiAgICAvLyBkeWdyYXBoLXV0aWxzLmpzIGZvciBtb3JlIGluZm8gb24gd2h5IHRoaXMgaXMgYSBnb29kIGlkZWEuXG4gICAgdGFycDogbmV3IElGcmFtZVRhcnAoKSxcblxuICAgIC8vIGNvbnRleHRCIGlzIHRoZSBzYW1lIHRoaW5nIGFzIHRoaXMgY29udGV4dCBvYmplY3QgYnV0IHJlbmFtZWQuXG4gICAgaW5pdGlhbGl6ZU1vdXNlRG93bjogZnVuY3Rpb24oZXZlbnQsIGcsIGNvbnRleHRCKSB7XG4gICAgICAvLyBwcmV2ZW50cyBtb3VzZSBkcmFncyBmcm9tIHNlbGVjdGluZyBwYWdlIHRleHQuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgIC8vIEZpcmVmb3gsIENocm9tZSwgZXRjLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTsgIC8vIElFXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXNQb3MgPSB1dGlscy5maW5kUG9zKGcuY2FudmFzXyk7XG4gICAgICBjb250ZXh0Qi5weCA9IGNhbnZhc1Bvcy54O1xuICAgICAgY29udGV4dEIucHkgPSBjYW52YXNQb3MueTtcbiAgICAgIGNvbnRleHRCLmRyYWdTdGFydFggPSB1dGlscy5kcmFnR2V0WF8oZXZlbnQsIGNvbnRleHRCKTtcbiAgICAgIGNvbnRleHRCLmRyYWdTdGFydFkgPSB1dGlscy5kcmFnR2V0WV8oZXZlbnQsIGNvbnRleHRCKTtcbiAgICAgIGNvbnRleHRCLmNhbmNlbE5leHREYmxjbGljayA9IGZhbHNlO1xuICAgICAgY29udGV4dEIudGFycC5jb3ZlcigpO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAoY29udGV4dC5pc1pvb21pbmcgfHwgY29udGV4dC5pc1Bhbm5pbmcpIHtcbiAgICAgICAgY29udGV4dC5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dC5kcmFnU3RhcnRYID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5kcmFnU3RhcnRZID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQuaXNQYW5uaW5nKSB7XG4gICAgICAgIGNvbnRleHQuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRleHQuZHJhZ2dpbmdEYXRlID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5kYXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZWxldGUgc2VsZi5heGVzX1tpXS5kcmFnZ2luZ1ZhbHVlO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmF4ZXNfW2ldLmRyYWdWYWx1ZVJhbmdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQudGFycC51bmNvdmVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbnRlcmFjdGlvbk1vZGVsID0gdGhpcy5nZXRPcHRpb24oXCJpbnRlcmFjdGlvbk1vZGVsXCIpO1xuXG4gIC8vIFNlbGYgaXMgdGhlIGdyYXBoLlxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gRnVuY3Rpb24gdGhhdCBiaW5kcyB0aGUgZ3JhcGggYW5kIGNvbnRleHQgdG8gdGhlIGhhbmRsZXIuXG4gIHZhciBiaW5kSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIoZXZlbnQsIHNlbGYsIGNvbnRleHQpO1xuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgZXZlbnROYW1lIGluIGludGVyYWN0aW9uTW9kZWwpIHtcbiAgICBpZiAoIWludGVyYWN0aW9uTW9kZWwuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkgY29udGludWU7XG4gICAgdGhpcy5hZGRBbmRUcmFja0V2ZW50KHRoaXMubW91c2VFdmVudEVsZW1lbnRfLCBldmVudE5hbWUsXG4gICAgICAgIGJpbmRIYW5kbGVyKGludGVyYWN0aW9uTW9kZWxbZXZlbnROYW1lXSkpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBkdXJpbmcgYSBkcmFnLCBidXQgbm90IG92ZXIgdGhlXG4gIC8vIGNhbnZhcywgdGhlbiBpdCBkb2Vzbid0IGNvdW50IGFzIGEgem9vbWluZyBhY3Rpb24uXG4gIGlmICghaW50ZXJhY3Rpb25Nb2RlbC53aWxsRGVzdHJveUNvbnRleHRNeXNlbGYpIHtcbiAgICB2YXIgbW91c2VVcEhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29udGV4dC5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkQW5kVHJhY2tFdmVudChkb2N1bWVudCwgJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gIH1cbn07XG5cbi8qKlxuICogRHJhdyBhIGdyYXkgem9vbSByZWN0YW5nbGUgb3ZlciB0aGUgZGVzaXJlZCBhcmVhIG9mIHRoZSBjYW52YXMuIEFsc28gY2xlYXJzXG4gKiB1cCBhbnkgcHJldmlvdXMgem9vbSByZWN0YW5nbGVzIHRoYXQgd2VyZSBkcmF3bi4gVGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgdG9cbiAqIGF2b2lkIGV4dHJhIHJlZHJhd2luZywgYnV0IGl0J3MgdHJpY2t5IHRvIGF2b2lkIGludGVyYWN0aW9ucyB3aXRoIHRoZSBzdGF0dXNcbiAqIGRvdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSB6b29tIHJlY3RhbmdsZS4gQWNjZXB0YWJsZVxuICogICAgIHZhbHVlcyBhcmUgdXRpbHMuSE9SSVpPTlRBTCBhbmQgdXRpbHMuVkVSVElDQUwuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRYIFRoZSBYIHBvc2l0aW9uIHdoZXJlIHRoZSBkcmFnIHN0YXJ0ZWQsIGluIGNhbnZhc1xuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFggVGhlIGN1cnJlbnQgWCBwb3NpdGlvbiBvZiB0aGUgZHJhZywgaW4gY2FudmFzIGNvb3Jkcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFkgVGhlIFkgcG9zaXRpb24gd2hlcmUgdGhlIGRyYWcgc3RhcnRlZCwgaW4gY2FudmFzXG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWSBUaGUgY3VycmVudCBZIHBvc2l0aW9uIG9mIHRoZSBkcmFnLCBpbiBjYW52YXMgY29vcmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHByZXZEaXJlY3Rpb24gdGhlIHZhbHVlIG9mIGRpcmVjdGlvbiBvbiB0aGUgcHJldmlvdXMgY2FsbCB0b1xuICogICAgIHRoaXMgZnVuY3Rpb24uIFVzZWQgdG8gYXZvaWQgZXhjZXNzIHJlZHJhd2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHByZXZFbmRYIFRoZSB2YWx1ZSBvZiBlbmRYIG9uIHRoZSBwcmV2aW91cyBjYWxsIHRvIHRoaXNcbiAqICAgICBmdW5jdGlvbi4gVXNlZCB0byBhdm9pZCBleGNlc3MgcmVkcmF3aW5nXG4gKiBAcGFyYW0ge251bWJlcn0gcHJldkVuZFkgVGhlIHZhbHVlIG9mIGVuZFkgb24gdGhlIHByZXZpb3VzIGNhbGwgdG8gdGhpc1xuICogICAgIGZ1bmN0aW9uLiBVc2VkIHRvIGF2b2lkIGV4Y2VzcyByZWRyYXdpbmdcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRyYXdab29tUmVjdF8gPSBmdW5jdGlvbihkaXJlY3Rpb24sIHN0YXJ0WCwgZW5kWCwgc3RhcnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFksIHByZXZEaXJlY3Rpb24sIHByZXZFbmRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZFbmRZKSB7XG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc19jdHhfO1xuXG4gIC8vIENsZWFuIHVwIGZyb20gdGhlIHByZXZpb3VzIHJlY3QgaWYgbmVjZXNzYXJ5XG4gIGlmIChwcmV2RGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICBjdHguY2xlYXJSZWN0KE1hdGgubWluKHN0YXJ0WCwgcHJldkVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS55LFxuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoc3RhcnRYIC0gcHJldkVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS5oKTtcbiAgfSBlbHNlIGlmIChwcmV2RGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgY3R4LmNsZWFyUmVjdCh0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS54LCBNYXRoLm1pbihzdGFydFksIHByZXZFbmRZKSxcbiAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLncsIE1hdGguYWJzKHN0YXJ0WSAtIHByZXZFbmRZKSk7XG4gIH1cblxuICAvLyBEcmF3IGEgbGlnaHQtZ3JleSByZWN0YW5nbGUgdG8gc2hvdyB0aGUgbmV3IHZpZXdpbmcgYXJlYVxuICBpZiAoZGlyZWN0aW9uID09IHV0aWxzLkhPUklaT05UQUwpIHtcbiAgICBpZiAoZW5kWCAmJiBzdGFydFgpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTI4LDEyOCwxMjgsMC4zMylcIjtcbiAgICAgIGN0eC5maWxsUmVjdChNYXRoLm1pbihzdGFydFgsIGVuZFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS55LFxuICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGVuZFggLSBzdGFydFgpLCB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS5oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09IHV0aWxzLlZFUlRJQ0FMKSB7XG4gICAgaWYgKGVuZFkgJiYgc3RhcnRZKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDEyOCwxMjgsMTI4LDAuMzMpXCI7XG4gICAgICBjdHguZmlsbFJlY3QodGhpcy5sYXlvdXRfLmdldFBsb3RBcmVhKCkueCwgTWF0aC5taW4oc3RhcnRZLCBlbmRZKSxcbiAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dF8uZ2V0UGxvdEFyZWEoKS53LCBNYXRoLmFicyhlbmRZIC0gc3RhcnRZKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSB6b29tIHJlY3RhbmdsZSAoYW5kIHBlcmZvcm0gbm8gem9vbSkuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jbGVhclpvb21SZWN0XyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRab29tUmVjdEFyZ3NfID0gbnVsbDtcbiAgdGhpcy5jYW52YXNfY3R4Xy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG59O1xuXG4vKipcbiAqIFpvb20gdG8gc29tZXRoaW5nIGNvbnRhaW5pbmcgW2xvd1gsIGhpZ2hYXS4gVGhlc2UgYXJlIHBpeGVsIGNvb3JkaW5hdGVzIGluXG4gKiB0aGUgY2FudmFzLiBUaGUgZXhhY3Qgem9vbSB3aW5kb3cgbWF5IGJlIHNsaWdodGx5IGxhcmdlciBpZiB0aGVyZSBhcmUgbm8gZGF0YVxuICogcG9pbnRzIG5lYXIgbG93WCBvciBoaWdoWC4gRG9uJ3QgY29uZnVzZSB0aGlzIGZ1bmN0aW9uIHdpdGggZG9ab29tWERhdGVzLFxuICogd2hpY2ggYWNjZXB0cyBkYXRlcyB0aGF0IG1hdGNoIHRoZSByYXcgZGF0YS4gVGhpcyBmdW5jdGlvbiByZWRyYXdzIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93WCBUaGUgbGVmdG1vc3QgcGl4ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdmlzaWJsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoWCBUaGUgcmlnaHRtb3N0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb1pvb21YXyA9IGZ1bmN0aW9uKGxvd1gsIGhpZ2hYKSB7XG4gIHRoaXMuY3VycmVudFpvb21SZWN0QXJnc18gPSBudWxsO1xuICAvLyBGaW5kIHRoZSBlYXJsaWVzdCBhbmQgbGF0ZXN0IGRhdGVzIGNvbnRhaW5lZCBpbiB0aGlzIGNhbnZhc3ggcmFuZ2UuXG4gIC8vIENvbnZlcnQgdGhlIGNhbGwgdG8gZGF0ZSByYW5nZXMgb2YgdGhlIHJhdyBkYXRhLlxuICB2YXIgbWluRGF0ZSA9IHRoaXMudG9EYXRhWENvb3JkKGxvd1gpO1xuICB2YXIgbWF4RGF0ZSA9IHRoaXMudG9EYXRhWENvb3JkKGhpZ2hYKTtcbiAgdGhpcy5kb1pvb21YRGF0ZXNfKG1pbkRhdGUsIG1heERhdGUpO1xufTtcblxuLyoqXG4gKiBab29tIHRvIHNvbWV0aGluZyBjb250YWluaW5nIFttaW5EYXRlLCBtYXhEYXRlXSB2YWx1ZXMuIERvbid0IGNvbmZ1c2UgdGhpc1xuICogbWV0aG9kIHdpdGggZG9ab29tWCB3aGljaCBhY2NlcHRzIHBpeGVsIGNvb3JkaW5hdGVzLiBUaGlzIGZ1bmN0aW9uIHJlZHJhd3NcbiAqIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWluRGF0ZSBUaGUgbWluaW11bSBkYXRlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGF0ZSBUaGUgbWF4aW11bSBkYXRlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5kb1pvb21YRGF0ZXNfID0gZnVuY3Rpb24obWluRGF0ZSwgbWF4RGF0ZSkge1xuICAvLyBUT0RPKGRhbnZrKTogd2hlbiB4QXhpc1JhbmdlIGlzIG51bGwgKGkuZS4gXCJmaXQgdG8gZGF0YVwiLCB0aGUgYW5pbWF0aW9uXG4gIC8vIGNhbiBwcm9kdWNlIHN0cmFuZ2UgZWZmZWN0cy4gUmF0aGVyIHRoYW4gdGhlIHgtYXhpcyB0cmFuc2l0aW9uaW5nIHNsb3dseVxuICAvLyBiZXR3ZWVuIHZhbHVlcywgaXQgY2FuIGplcmsgYXJvdW5kLilcbiAgdmFyIG9sZF93aW5kb3cgPSB0aGlzLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIG5ld193aW5kb3cgPSBbbWluRGF0ZSwgbWF4RGF0ZV07XG4gIHRoaXMuem9vbWVkX3hfID0gdHJ1ZTtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB0aGlzLmRvQW5pbWF0ZWRab29tKG9sZF93aW5kb3csIG5ld193aW5kb3csIG51bGwsIG51bGwsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGF0LmdldEZ1bmN0aW9uT3B0aW9uKFwiem9vbUNhbGxiYWNrXCIpKSB7XG4gICAgICB0aGF0LmdldEZ1bmN0aW9uT3B0aW9uKFwiem9vbUNhbGxiYWNrXCIpLmNhbGwodGhhdCxcbiAgICAgICAgICBtaW5EYXRlLCBtYXhEYXRlLCB0aGF0LnlBeGlzUmFuZ2VzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFpvb20gdG8gc29tZXRoaW5nIGNvbnRhaW5pbmcgW2xvd1ksIGhpZ2hZXS4gVGhlc2UgYXJlIHBpeGVsIGNvb3JkaW5hdGVzIGluXG4gKiB0aGUgY2FudmFzLiBUaGlzIGZ1bmN0aW9uIHJlZHJhd3MgdGhlIGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dZIFRoZSB0b3Btb3N0IHBpeGVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHZpc2libGUuXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFkgVGhlIGxvd2VzdCBwaXhlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZG9ab29tWV8gPSBmdW5jdGlvbihsb3dZLCBoaWdoWSkge1xuICB0aGlzLmN1cnJlbnRab29tUmVjdEFyZ3NfID0gbnVsbDtcbiAgLy8gRmluZCB0aGUgaGlnaGVzdCBhbmQgbG93ZXN0IHZhbHVlcyBpbiBwaXhlbCByYW5nZSBmb3IgZWFjaCBheGlzLlxuICAvLyBOb3RlIHRoYXQgbG93WSAoaW4gcGl4ZWxzKSBjb3JyZXNwb25kcyB0byB0aGUgbWF4IFZhbHVlIChpbiBkYXRhIGNvb3JkcykuXG4gIC8vIFRoaXMgaXMgYmVjYXVzZSBwaXhlbHMgaW5jcmVhc2UgYXMgeW91IGdvIGRvd24gb24gdGhlIHNjcmVlbiwgd2hlcmVhcyBkYXRhXG4gIC8vIGNvb3JkaW5hdGVzIGluY3JlYXNlIGFzIHlvdSBnbyB1cCB0aGUgc2NyZWVuLlxuICB2YXIgb2xkVmFsdWVSYW5nZXMgPSB0aGlzLnlBeGlzUmFuZ2VzKCk7XG4gIHZhciBuZXdWYWx1ZVJhbmdlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaGkgPSB0aGlzLnRvRGF0YVlDb29yZChsb3dZLCBpKTtcbiAgICB2YXIgbG93ID0gdGhpcy50b0RhdGFZQ29vcmQoaGlnaFksIGkpO1xuICAgIG5ld1ZhbHVlUmFuZ2VzLnB1c2goW2xvdywgaGldKTtcbiAgfVxuXG4gIHRoaXMuem9vbWVkX3lfID0gdHJ1ZTtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB0aGlzLmRvQW5pbWF0ZWRab29tKG51bGwsIG51bGwsIG9sZFZhbHVlUmFuZ2VzLCBuZXdWYWx1ZVJhbmdlcywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoYXQuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikpIHtcbiAgICAgIHZhciB4UmFuZ2UgPSB0aGF0LnhBeGlzUmFuZ2UoKTtcbiAgICAgIHRoYXQuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikuY2FsbCh0aGF0LFxuICAgICAgICAgIHhSYW5nZVswXSwgeFJhbmdlWzFdLCB0aGF0LnlBeGlzUmFuZ2VzKCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFRyYW5zaXRpb24gZnVuY3Rpb24gdG8gdXNlIGluIGFuaW1hdGlvbnMuIFJldHVybnMgdmFsdWVzIGJldHdlZW4gMC4wXG4gKiAodG90YWxseSBvbGQgdmFsdWVzKSBhbmQgMS4wICh0b3RhbGx5IG5ldyB2YWx1ZXMpIGZvciBlYWNoIGZyYW1lLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC56b29tQW5pbWF0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbihmcmFtZSwgbnVtRnJhbWVzKSB7XG4gIHZhciBrID0gMS41O1xuICByZXR1cm4gKDEuMCAtIE1hdGgucG93KGssIC1mcmFtZSkpIC8gKDEuMCAtIE1hdGgucG93KGssIC1udW1GcmFtZXMpKTtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIHpvb20gdG8gdGhlIG9yaWdpbmFsIHZpZXcgY29vcmRpbmF0ZXMuIFRoaXMgaXMgdGhlIHNhbWUgYXNcbiAqIGRvdWJsZS1jbGlja2luZyBvbiB0aGUgZ3JhcGguXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlc2V0Wm9vbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGlydHkgPSBmYWxzZSwgZGlydHlYID0gZmFsc2UsIGRpcnR5WSA9IGZhbHNlO1xuICBpZiAodGhpcy5kYXRlV2luZG93XyAhPT0gbnVsbCkge1xuICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICBkaXJ0eVggPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZih0aGlzLmF4ZXNfW2ldLnZhbHVlV2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5heGVzX1tpXS52YWx1ZVdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgZGlydHlZID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhciBhbnkgc2VsZWN0aW9uLCBzaW5jZSBpdCdzIGxpa2VseSB0byBiZSBkcmF3biBpbiB0aGUgd3JvbmcgcGxhY2UuXG4gIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICBpZiAoZGlydHkpIHtcbiAgICB0aGlzLnpvb21lZF94XyA9IGZhbHNlO1xuICAgIHRoaXMuem9vbWVkX3lfID0gZmFsc2U7XG5cbiAgICAvL2NhbGN1bGF0ZSBleHRyZW1lcyB0byBhdm9pZCBsYWNrIG9mIHBhZGRpbmcgb24gcmVzZXQuXG4gICAgdmFyIGV4dHJlbWVzID0gdGhpcy54QXhpc0V4dHJlbWVzKCk7XG4gICAgdmFyIG1pbkRhdGUgPSBleHRyZW1lc1swXSxcbiAgICAgICAgbWF4RGF0ZSA9IGV4dHJlbWVzWzFdO1xuXG4gICAgLy8gVE9ETyhkYW52ayk6IG1lcmdlIHRoaXMgYmxvY2sgdy8gdGhlIGNvZGUgYmVsb3cuXG4gICAgaWYgKCF0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJhbmltYXRlZFpvb21zXCIpKSB7XG4gICAgICB0aGlzLmRhdGVXaW5kb3dfID0gbnVsbDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmF4ZXNfW2ldLnZhbHVlV2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYXhlc19baV0udmFsdWVXaW5kb3c7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0dyYXBoXygpO1xuICAgICAgaWYgKHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikpIHtcbiAgICAgICAgdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInpvb21DYWxsYmFja1wiKS5jYWxsKHRoaXMsXG4gICAgICAgICAgICBtaW5EYXRlLCBtYXhEYXRlLCB0aGlzLnlBeGlzUmFuZ2VzKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvbGRXaW5kb3c9bnVsbCwgbmV3V2luZG93PW51bGwsIG9sZFZhbHVlUmFuZ2VzPW51bGwsIG5ld1ZhbHVlUmFuZ2VzPW51bGw7XG4gICAgaWYgKGRpcnR5WCkge1xuICAgICAgb2xkV2luZG93ID0gdGhpcy54QXhpc1JhbmdlKCk7XG4gICAgICBuZXdXaW5kb3cgPSBbbWluRGF0ZSwgbWF4RGF0ZV07XG4gICAgfVxuXG4gICAgaWYgKGRpcnR5WSkge1xuICAgICAgb2xkVmFsdWVSYW5nZXMgPSB0aGlzLnlBeGlzUmFuZ2VzKCk7XG4gICAgICAvLyBUT0RPKGRhbnZrKTogdGhpcyBpcyBwcmV0dHkgaW5lZmZpY2llbnRcbiAgICAgIHZhciBwYWNrZWQgPSB0aGlzLmdhdGhlckRhdGFzZXRzXyh0aGlzLnJvbGxlZFNlcmllc18sIG51bGwpO1xuICAgICAgdmFyIGV4dHJlbWVzID0gcGFja2VkLmV4dHJlbWVzO1xuXG4gICAgICAvLyB0aGlzIGhhcyB0aGUgc2lkZS1lZmZlY3Qgb2YgbW9kaWZ5aW5nIHRoaXMuYXhlc18uXG4gICAgICAvLyB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIGluIHRoaXMgY29udGV4dCwgYnV0IGl0J3MgY29udmVuaWVudCAod2VcbiAgICAgIC8vIG5lZWQgdGhpcy5heGVzX1sqXS5leHRyZW1lVmFsdWVzKSBhbmQgbm90IGhhcm1mdWwgc2luY2Ugd2UnbGwgYmVcbiAgICAgIC8vIGNhbGxpbmcgZHJhd0dyYXBoXyBzaG9ydGx5LCB3aGljaCBjbG9iYmVycyB0aGVzZSB2YWx1ZXMuXG4gICAgICB0aGlzLmNvbXB1dGVZQXhpc1Jhbmdlc18oZXh0cmVtZXMpO1xuXG4gICAgICBuZXdWYWx1ZVJhbmdlcyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNfW2ldO1xuICAgICAgICBuZXdWYWx1ZVJhbmdlcy5wdXNoKChheGlzLnZhbHVlUmFuZ2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy52YWx1ZVJhbmdlICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnZhbHVlUmFuZ2UgOiBheGlzLmV4dHJlbWVSYW5nZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuZG9BbmltYXRlZFpvb20ob2xkV2luZG93LCBuZXdXaW5kb3csIG9sZFZhbHVlUmFuZ2VzLCBuZXdWYWx1ZVJhbmdlcyxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC5kYXRlV2luZG93XyA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LmF4ZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5heGVzX1tpXS52YWx1ZVdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhhdC5heGVzX1tpXS52YWx1ZVdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoYXQuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikpIHtcbiAgICAgICAgICAgIHRoYXQuZ2V0RnVuY3Rpb25PcHRpb24oXCJ6b29tQ2FsbGJhY2tcIikuY2FsbCh0aGF0LFxuICAgICAgICAgICAgICAgIG1pbkRhdGUsIG1heERhdGUsIHRoYXQueUF4aXNSYW5nZXMoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb21iaW5lZCBhbmltYXRpb24gbG9naWMgZm9yIGFsbCB6b29tIGZ1bmN0aW9ucy5cbiAqIGVpdGhlciB0aGUgeCBwYXJhbWV0ZXJzIG9yIHkgcGFyYW1ldGVycyBtYXkgYmUgbnVsbC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRvQW5pbWF0ZWRab29tID0gZnVuY3Rpb24ob2xkWFJhbmdlLCBuZXdYUmFuZ2UsIG9sZFlSYW5nZXMsIG5ld1lSYW5nZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGVwcyA9IHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImFuaW1hdGVkWm9vbXNcIikgP1xuICAgICAgRHlncmFwaC5BTklNQVRJT05fU1RFUFMgOiAxO1xuXG4gIHZhciB3aW5kb3dzID0gW107XG4gIHZhciB2YWx1ZVJhbmdlcyA9IFtdO1xuICB2YXIgc3RlcCwgZnJhYztcblxuICBpZiAob2xkWFJhbmdlICE9PSBudWxsICYmIG5ld1hSYW5nZSAhPT0gbnVsbCkge1xuICAgIGZvciAoc3RlcCA9IDE7IHN0ZXAgPD0gc3RlcHM7IHN0ZXArKykge1xuICAgICAgZnJhYyA9IER5Z3JhcGguem9vbUFuaW1hdGlvbkZ1bmN0aW9uKHN0ZXAsIHN0ZXBzKTtcbiAgICAgIHdpbmRvd3Nbc3RlcC0xXSA9IFtvbGRYUmFuZ2VbMF0qKDEtZnJhYykgKyBmcmFjKm5ld1hSYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbGRYUmFuZ2VbMV0qKDEtZnJhYykgKyBmcmFjKm5ld1hSYW5nZVsxXV07XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZFlSYW5nZXMgIT09IG51bGwgJiYgbmV3WVJhbmdlcyAhPT0gbnVsbCkge1xuICAgIGZvciAoc3RlcCA9IDE7IHN0ZXAgPD0gc3RlcHM7IHN0ZXArKykge1xuICAgICAgZnJhYyA9IER5Z3JhcGguem9vbUFuaW1hdGlvbkZ1bmN0aW9uKHN0ZXAsIHN0ZXBzKTtcbiAgICAgIHZhciB0aGlzUmFuZ2UgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5heGVzXy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzUmFuZ2UucHVzaChbb2xkWVJhbmdlc1tqXVswXSooMS1mcmFjKSArIGZyYWMqbmV3WVJhbmdlc1tqXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFlSYW5nZXNbal1bMV0qKDEtZnJhYykgKyBmcmFjKm5ld1lSYW5nZXNbal1bMV1dKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlUmFuZ2VzW3N0ZXAtMV0gPSB0aGlzUmFuZ2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB1dGlscy5yZXBlYXRBbmRDbGVhbnVwKGZ1bmN0aW9uKHN0ZXApIHtcbiAgICBpZiAodmFsdWVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuYXhlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB2YWx1ZVJhbmdlc1tzdGVwXVtpXTtcbiAgICAgICAgdGhhdC5heGVzX1tpXS52YWx1ZVdpbmRvdyA9IFt3WzBdLCB3WzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpbmRvd3MubGVuZ3RoKSB7XG4gICAgICB0aGF0LmRhdGVXaW5kb3dfID0gd2luZG93c1tzdGVwXTtcbiAgICB9XG4gICAgdGhhdC5kcmF3R3JhcGhfKCk7XG4gIH0sIHN0ZXBzLCBEeWdyYXBoLkFOSU1BVElPTl9EVVJBVElPTiAvIHN0ZXBzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBncmFwaCdzIGFyZWEgb2JqZWN0LlxuICpcbiAqIFJldHVybnM6IHt4LCB5LCB3LCBofVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnBsb3R0ZXJfLmFyZWE7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBtb3VzZSBldmVudCB0byBET00gY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGdyYXBoIG9yaWdpbi5cbiAqXG4gKiBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXk6IFtYLCBZXS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZXZlbnRUb0RvbUNvb3JkcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudC5vZmZzZXRYICYmIGV2ZW50Lm9mZnNldFkpIHtcbiAgICByZXR1cm4gWyBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZIF07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGV2ZW50RWxlbWVudFBvcyA9IHV0aWxzLmZpbmRQb3ModGhpcy5tb3VzZUV2ZW50RWxlbWVudF8pO1xuICAgIHZhciBjYW52YXN4ID0gdXRpbHMucGFnZVgoZXZlbnQpIC0gZXZlbnRFbGVtZW50UG9zLng7XG4gICAgdmFyIGNhbnZhc3kgPSB1dGlscy5wYWdlWShldmVudCkgLSBldmVudEVsZW1lbnRQb3MueTtcbiAgICByZXR1cm4gW2NhbnZhc3gsIGNhbnZhc3ldO1xuICB9XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgY2FudmFzIFggY29vcmRpbmF0ZSwgZmluZCB0aGUgY2xvc2VzdCByb3cuXG4gKiBAcGFyYW0ge251bWJlcn0gZG9tWCBncmFwaC1yZWxhdGl2ZSBET00gWCBjb29yZGluYXRlXG4gKiBSZXR1cm5zIHtudW1iZXJ9IHJvdyBudW1iZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5maW5kQ2xvc2VzdFJvdyA9IGZ1bmN0aW9uKGRvbVgpIHtcbiAgdmFyIG1pbkRpc3RYID0gSW5maW5pdHk7XG4gIHZhciBjbG9zZXN0Um93ID0gLTE7XG4gIHZhciBzZXRzID0gdGhpcy5sYXlvdXRfLnBvaW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHNldHNbaV07XG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgICAgaWYgKCF1dGlscy5pc1ZhbGlkUG9pbnQocG9pbnQsIHRydWUpKSBjb250aW51ZTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMocG9pbnQuY2FudmFzeCAtIGRvbVgpO1xuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0WCkge1xuICAgICAgICBtaW5EaXN0WCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RSb3cgPSBwb2ludC5pZHg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RSb3c7XG59O1xuXG4vKipcbiAqIEdpdmVuIGNhbnZhcyBYLFkgY29vcmRpbmF0ZXMsIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKlxuICogVGhpcyBmaW5kcyB0aGUgaW5kaXZpZHVhbCBkYXRhIHBvaW50IGFjcm9zcyBhbGwgdmlzaWJsZSBzZXJpZXNcbiAqIHRoYXQncyBjbG9zZXN0IHRvIHRoZSBzdXBwbGllZCBET00gY29vcmRpbmF0ZXMgdXNpbmcgdGhlIHN0YW5kYXJkXG4gKiBFdWNsaWRlYW4gWCxZIGRpc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21YIGdyYXBoLXJlbGF0aXZlIERPTSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21ZIGdyYXBoLXJlbGF0aXZlIERPTSBZIGNvb3JkaW5hdGVcbiAqIFJldHVybnM6IHtyb3csIHNlcmllc05hbWUsIHBvaW50fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZmluZENsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uKGRvbVgsIGRvbVkpIHtcbiAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgdmFyIGRpc3QsIGR4LCBkeSwgcG9pbnQsIGNsb3Nlc3RQb2ludCwgY2xvc2VzdFNlcmllcywgY2xvc2VzdFJvdztcbiAgZm9yICggdmFyIHNldElkeCA9IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoIC0gMSA7IHNldElkeCA+PSAwIDsgLS1zZXRJZHggKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBpZiAoIXV0aWxzLmlzVmFsaWRQb2ludChwb2ludCkpIGNvbnRpbnVlO1xuICAgICAgZHggPSBwb2ludC5jYW52YXN4IC0gZG9tWDtcbiAgICAgIGR5ID0gcG9pbnQuY2FudmFzeSAtIGRvbVk7XG4gICAgICBkaXN0ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RQb2ludCA9IHBvaW50O1xuICAgICAgICBjbG9zZXN0U2VyaWVzID0gc2V0SWR4O1xuICAgICAgICBjbG9zZXN0Um93ID0gcG9pbnQuaWR4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgbmFtZSA9IHRoaXMubGF5b3V0Xy5zZXROYW1lc1tjbG9zZXN0U2VyaWVzXTtcbiAgcmV0dXJuIHtcbiAgICByb3c6IGNsb3Nlc3RSb3csXG4gICAgc2VyaWVzTmFtZTogbmFtZSxcbiAgICBwb2ludDogY2xvc2VzdFBvaW50XG4gIH07XG59O1xuXG4vKipcbiAqIEdpdmVuIGNhbnZhcyBYLFkgY29vcmRpbmF0ZXMsIGZpbmQgdGhlIHRvdWNoZWQgYXJlYSBpbiBhIHN0YWNrZWQgZ3JhcGguXG4gKlxuICogVGhpcyBmaXJzdCBmaW5kcyB0aGUgWCBkYXRhIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHN1cHBsaWVkIERPTSBYIGNvb3JkaW5hdGUsXG4gKiB0aGVuIGZpbmRzIHRoZSBzZXJpZXMgd2hpY2ggcHV0cyB0aGUgWSBjb29yZGluYXRlIG9uIHRvcCBvZiBpdHMgZmlsbGVkIGFyZWEsXG4gKiB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGFkamFjZW50IHBvaW50IHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21YIGdyYXBoLXJlbGF0aXZlIERPTSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkb21ZIGdyYXBoLXJlbGF0aXZlIERPTSBZIGNvb3JkaW5hdGVcbiAqIFJldHVybnM6IHtyb3csIHNlcmllc05hbWUsIHBvaW50fVxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZmluZFN0YWNrZWRQb2ludCA9IGZ1bmN0aW9uKGRvbVgsIGRvbVkpIHtcbiAgdmFyIHJvdyA9IHRoaXMuZmluZENsb3Nlc3RSb3coZG9tWCk7XG4gIHZhciBjbG9zZXN0UG9pbnQsIGNsb3Nlc3RTZXJpZXM7XG4gIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoOyArK3NldElkeCkge1xuICAgIHZhciBib3VuZGFyeSA9IHRoaXMuZ2V0TGVmdEJvdW5kYXJ5XyhzZXRJZHgpO1xuICAgIHZhciByb3dJZHggPSByb3cgLSBib3VuZGFyeTtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50c1tzZXRJZHhdO1xuICAgIGlmIChyb3dJZHggPj0gcG9pbnRzLmxlbmd0aCkgY29udGludWU7XG4gICAgdmFyIHAxID0gcG9pbnRzW3Jvd0lkeF07XG4gICAgaWYgKCF1dGlscy5pc1ZhbGlkUG9pbnQocDEpKSBjb250aW51ZTtcbiAgICB2YXIgcHkgPSBwMS5jYW52YXN5O1xuICAgIGlmIChkb21YID4gcDEuY2FudmFzeCAmJiByb3dJZHggKyAxIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgLy8gaW50ZXJwb2xhdGUgc2VyaWVzIFkgdmFsdWUgdXNpbmcgbmV4dCBwb2ludFxuICAgICAgdmFyIHAyID0gcG9pbnRzW3Jvd0lkeCArIDFdO1xuICAgICAgaWYgKHV0aWxzLmlzVmFsaWRQb2ludChwMikpIHtcbiAgICAgICAgdmFyIGR4ID0gcDIuY2FudmFzeCAtIHAxLmNhbnZhc3g7XG4gICAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgICB2YXIgciA9IChkb21YIC0gcDEuY2FudmFzeCkgLyBkeDtcbiAgICAgICAgICBweSArPSByICogKHAyLmNhbnZhc3kgLSBwMS5jYW52YXN5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZG9tWCA8IHAxLmNhbnZhc3ggJiYgcm93SWR4ID4gMCkge1xuICAgICAgLy8gaW50ZXJwb2xhdGUgc2VyaWVzIFkgdmFsdWUgdXNpbmcgcHJldmlvdXMgcG9pbnRcbiAgICAgIHZhciBwMCA9IHBvaW50c1tyb3dJZHggLSAxXTtcbiAgICAgIGlmICh1dGlscy5pc1ZhbGlkUG9pbnQocDApKSB7XG4gICAgICAgIHZhciBkeCA9IHAxLmNhbnZhc3ggLSBwMC5jYW52YXN4O1xuICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgdmFyIHIgPSAocDEuY2FudmFzeCAtIGRvbVgpIC8gZHg7XG4gICAgICAgICAgcHkgKz0gciAqIChwMC5jYW52YXN5IC0gcDEuY2FudmFzeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RvcCBpZiB0aGUgcG9pbnQgKGRvbVgsIHB5KSBpcyBhYm92ZSB0aGlzIHNlcmllcycgdXBwZXIgZWRnZVxuICAgIGlmIChzZXRJZHggPT09IDAgfHwgcHkgPCBkb21ZKSB7XG4gICAgICBjbG9zZXN0UG9pbnQgPSBwMTtcbiAgICAgIGNsb3Nlc3RTZXJpZXMgPSBzZXRJZHg7XG4gICAgfVxuICB9XG4gIHZhciBuYW1lID0gdGhpcy5sYXlvdXRfLnNldE5hbWVzW2Nsb3Nlc3RTZXJpZXNdO1xuICByZXR1cm4ge1xuICAgIHJvdzogcm93LFxuICAgIHNlcmllc05hbWU6IG5hbWUsXG4gICAgcG9pbnQ6IGNsb3Nlc3RQb2ludFxuICB9O1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBtb3VzZSBtb3ZlcyBpbiB0aGUgY2FudmFzLCBkaXNwbGF5IGluZm9ybWF0aW9uIGFib3V0IGEgbmVhcmJ5IGRhdGFcbiAqIHBvaW50IGFuZCBkcmF3IGRvdHMgb3ZlciB0aG9zZSBwb2ludHMgaW4gdGhlIGRhdGEgc2VyaWVzLiBUaGlzIGZ1bmN0aW9uXG4gKiB0YWtlcyBjYXJlIG9mIGNsZWFudXAgb2YgcHJldmlvdXNseS1kcmF3biBkb3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBtb3VzZW1vdmUgZXZlbnQgZnJvbSB0aGUgYnJvd3Nlci5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLm1vdXNlTW92ZV8gPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBUaGlzIHByZXZlbnRzIEpTIGVycm9ycyB3aGVuIG1vdXNpbmcgb3ZlciB0aGUgY2FudmFzIGJlZm9yZSBkYXRhIGxvYWRzLlxuICB2YXIgcG9pbnRzID0gdGhpcy5sYXlvdXRfLnBvaW50cztcbiAgaWYgKHBvaW50cyA9PT0gdW5kZWZpbmVkIHx8IHBvaW50cyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gIHZhciBjYW52YXNDb29yZHMgPSB0aGlzLmV2ZW50VG9Eb21Db29yZHMoZXZlbnQpO1xuICB2YXIgY2FudmFzeCA9IGNhbnZhc0Nvb3Jkc1swXTtcbiAgdmFyIGNhbnZhc3kgPSBjYW52YXNDb29yZHNbMV07XG5cbiAgdmFyIGhpZ2hsaWdodFNlcmllc09wdHMgPSB0aGlzLmdldE9wdGlvbihcImhpZ2hsaWdodFNlcmllc09wdHNcIik7XG4gIHZhciBzZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChoaWdobGlnaHRTZXJpZXNPcHRzICYmICF0aGlzLmlzU2VyaWVzTG9ja2VkKCkpIHtcbiAgICB2YXIgY2xvc2VzdDtcbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpKSB7XG4gICAgICBjbG9zZXN0ID0gdGhpcy5maW5kU3RhY2tlZFBvaW50KGNhbnZhc3gsIGNhbnZhc3kpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZXN0ID0gdGhpcy5maW5kQ2xvc2VzdFBvaW50KGNhbnZhc3gsIGNhbnZhc3kpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25DaGFuZ2VkID0gdGhpcy5zZXRTZWxlY3Rpb24oY2xvc2VzdC5yb3csIGNsb3Nlc3Quc2VyaWVzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuZmluZENsb3Nlc3RSb3coY2FudmFzeCk7XG4gICAgc2VsZWN0aW9uQ2hhbmdlZCA9IHRoaXMuc2V0U2VsZWN0aW9uKGlkeCk7XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwiaGlnaGxpZ2h0Q2FsbGJhY2tcIik7XG4gIGlmIChjYWxsYmFjayAmJiBzZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCxcbiAgICAgICAgdGhpcy5sYXN0eF8sXG4gICAgICAgIHRoaXMuc2VsUG9pbnRzXyxcbiAgICAgICAgdGhpcy5sYXN0Um93XyxcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZXRfKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGZXRjaCBsZWZ0IG9mZnNldCBmcm9tIHRoZSBzcGVjaWZpZWQgc2V0IGluZGV4IG9yIGlmIG5vdCBwYXNzZWQsIHRoZVxuICogZmlyc3QgZGVmaW5lZCBib3VuZGFyeUlkcyByZWNvcmQgKHNlZSBidWcgIzIzNikuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRMZWZ0Qm91bmRhcnlfID0gZnVuY3Rpb24oc2V0SWR4KSB7XG4gIGlmICh0aGlzLmJvdW5kYXJ5SWRzX1tzZXRJZHhdKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZGFyeUlkc19bc2V0SWR4XVswXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm91bmRhcnlJZHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZGFyeUlkc19baV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGFyeUlkc19baV1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5EeWdyYXBoLnByb3RvdHlwZS5hbmltYXRlU2VsZWN0aW9uXyA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICB2YXIgdG90YWxTdGVwcyA9IDEwO1xuICB2YXIgbWlsbGlzID0gMzA7XG4gIGlmICh0aGlzLmZhZGVMZXZlbCA9PT0gdW5kZWZpbmVkKSB0aGlzLmZhZGVMZXZlbCA9IDA7XG4gIGlmICh0aGlzLmFuaW1hdGVJZCA9PT0gdW5kZWZpbmVkKSB0aGlzLmFuaW1hdGVJZCA9IDA7XG4gIHZhciBzdGFydCA9IHRoaXMuZmFkZUxldmVsO1xuICB2YXIgc3RlcHMgPSBkaXJlY3Rpb24gPCAwID8gc3RhcnQgOiB0b3RhbFN0ZXBzIC0gc3RhcnQ7XG4gIGlmIChzdGVwcyA8PSAwKSB7XG4gICAgaWYgKHRoaXMuZmFkZUxldmVsKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbl8oMS4wKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRoaXNJZCA9ICsrdGhpcy5hbmltYXRlSWQ7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGNsZWFudXBJZkNsZWFyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gaWYgd2UgaGF2ZW4ndCByZWFjaGVkIGZhZGVMZXZlbCAwIGluIHRoZSBtYXggZnJhbWUgdGltZSxcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgY2xlYXIgaGFwcGVucyBhbmQganVzdCBnbyB0byAwXG4gICAgaWYgKHRoYXQuZmFkZUxldmVsICE9PSAwICYmIGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIHRoYXQuZmFkZUxldmVsID0gMDtcbiAgICAgIHRoYXQuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG4gIHV0aWxzLnJlcGVhdEFuZENsZWFudXAoXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgLy8gaWdub3JlIHNpbXVsdGFuZW91cyBhbmltYXRpb25zXG4gICAgICBpZiAodGhhdC5hbmltYXRlSWQgIT0gdGhpc0lkKSByZXR1cm47XG5cbiAgICAgIHRoYXQuZmFkZUxldmVsICs9IGRpcmVjdGlvbjtcbiAgICAgIGlmICh0aGF0LmZhZGVMZXZlbCA9PT0gMCkge1xuICAgICAgICB0aGF0LmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LnVwZGF0ZVNlbGVjdGlvbl8odGhhdC5mYWRlTGV2ZWwgLyB0b3RhbFN0ZXBzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0ZXBzLCBtaWxsaXMsIGNsZWFudXBJZkNsZWFyaW5nKTtcbn07XG5cbi8qKlxuICogRHJhdyBkb3RzIG92ZXIgdGhlIHNlbGVjdGllZCBwb2ludHMgaW4gdGhlIGRhdGEgc2VyaWVzLiBUaGlzIGZ1bmN0aW9uXG4gKiB0YWtlcyBjYXJlIG9mIGNsZWFudXAgb2YgcHJldmlvdXNseS1kcmF3biBkb3RzLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudXBkYXRlU2VsZWN0aW9uXyA9IGZ1bmN0aW9uKG9wdF9hbmltRnJhY3Rpb24pIHtcbiAgLyp2YXIgZGVmYXVsdFByZXZlbnRlZCA9ICovXG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3NlbGVjdCcsIHtcbiAgICBzZWxlY3RlZFJvdzogdGhpcy5sYXN0Um93XyxcbiAgICBzZWxlY3RlZFg6IHRoaXMubGFzdHhfLFxuICAgIHNlbGVjdGVkUG9pbnRzOiB0aGlzLnNlbFBvaW50c19cbiAgfSk7XG4gIC8vIFRPRE8oZGFudmspOiB1c2UgZGVmYXVsdFByZXZlbnRlZCBoZXJlP1xuXG4gIC8vIENsZWFyIHRoZSBwcmV2aW91c2x5IGRyYXduIHZlcnRpY2FsLCBpZiB0aGVyZSBpcyBvbmVcbiAgdmFyIGk7XG4gIHZhciBjdHggPSB0aGlzLmNhbnZhc19jdHhfO1xuICBpZiAodGhpcy5nZXRPcHRpb24oJ2hpZ2hsaWdodFNlcmllc09wdHMnKSkge1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gICAgdmFyIGFscGhhID0gMS4wIC0gdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQWxwaGEnKTtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gdXRpbHMudG9SR0JfKHRoaXMuZ2V0T3B0aW9uKCdoaWdobGlnaHRTZXJpZXNCYWNrZ3JvdW5kQ29sb3InKSk7XG5cbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIC8vIEFjdGl2YXRpbmcgYmFja2dyb3VuZCBmYWRlIGluY2x1ZGVzIGFuIGFuaW1hdGlvbiBlZmZlY3QgZm9yIGEgZ3JhZHVhbFxuICAgICAgLy8gZmFkZS4gVE9ETyhrbGF1c3cpOiBtYWtlIHRoaXMgaW5kZXBlbmRlbnRseSBjb25maWd1cmFibGUgaWYgaXQgY2F1c2VzXG4gICAgICAvLyBpc3N1ZXM/IFVzZSBhIHNoYXJlZCBwcmVmZXJlbmNlIHRvIGNvbnRyb2wgYW5pbWF0aW9ucz9cbiAgICAgIHZhciBhbmltYXRlQmFja2dyb3VuZEZhZGUgPSB0cnVlO1xuICAgICAgaWYgKGFuaW1hdGVCYWNrZ3JvdW5kRmFkZSkge1xuICAgICAgICBpZiAob3B0X2FuaW1GcmFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc3RhcnQgYSBuZXcgYW5pbWF0aW9uXG4gICAgICAgICAgdGhpcy5hbmltYXRlU2VsZWN0aW9uXygxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGEgKj0gb3B0X2FuaW1GcmFjdGlvbjtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgnICsgYmFja2dyb3VuZENvbG9yLnIgKyAnLCcgKyBiYWNrZ3JvdW5kQ29sb3IuZyArICcsJyArIGJhY2tncm91bmRDb2xvci5iICsgJywnICsgYWxwaGEgKyAnKSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gICAgfVxuXG4gICAgLy8gUmVkcmF3IG9ubHkgdGhlIGhpZ2hsaWdodGVkIHNlcmllcyBpbiB0aGUgaW50ZXJhY3RpdmUgY2FudmFzIChub3QgdGhlXG4gICAgLy8gc3RhdGljIHBsb3QgY2FudmFzLCB3aGljaCBpcyB3aGVyZSBzZXJpZXMgYXJlIHVzdWFsbHkgZHJhd24pLlxuICAgIHRoaXMucGxvdHRlcl8uX3JlbmRlckxpbmVDaGFydCh0aGlzLmhpZ2hsaWdodFNldF8sIGN0eCk7XG4gIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91c1ZlcnRpY2FsWF8gPj0gMCkge1xuICAgIC8vIERldGVybWluZSB0aGUgbWF4aW11bSBoaWdobGlnaHQgY2lyY2xlIHNpemUuXG4gICAgdmFyIG1heENpcmNsZVNpemUgPSAwO1xuICAgIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKCdsYWJlbHMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgciA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScsIGxhYmVsc1tpXSk7XG4gICAgICBpZiAociA+IG1heENpcmNsZVNpemUpIG1heENpcmNsZVNpemUgPSByO1xuICAgIH1cbiAgICB2YXIgcHggPSB0aGlzLnByZXZpb3VzVmVydGljYWxYXztcbiAgICBjdHguY2xlYXJSZWN0KHB4IC0gbWF4Q2lyY2xlU2l6ZSAtIDEsIDAsXG4gICAgICAgICAgICAgICAgICAyICogbWF4Q2lyY2xlU2l6ZSArIDIsIHRoaXMuaGVpZ2h0Xyk7XG4gIH1cblxuICBpZiAodGhpcy5zZWxQb2ludHNfLmxlbmd0aCA+IDApIHtcbiAgICAvLyBEcmF3IGNvbG9yZWQgY2lyY2xlcyBvdmVyIHRoZSBjZW50ZXIgb2YgZWFjaCBzZWxlY3RlZCBwb2ludFxuICAgIHZhciBjYW52YXN4ID0gdGhpcy5zZWxQb2ludHNfWzBdLmNhbnZhc3g7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZWxQb2ludHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0aGlzLnNlbFBvaW50c19baV07XG4gICAgICBpZiAoaXNOYU4ocHQuY2FudmFzeSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgY2lyY2xlU2l6ZSA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignaGlnaGxpZ2h0Q2lyY2xlU2l6ZScsIHB0Lm5hbWUpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcImRyYXdIaWdobGlnaHRQb2ludENhbGxiYWNrXCIsIHB0Lm5hbWUpO1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5wbG90dGVyXy5jb2xvcnNbcHQubmFtZV07XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdXRpbHMuQ2lyY2xlcy5ERUZBVUxUO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbignc3Ryb2tlV2lkdGgnLCBwdC5uYW1lKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLCBwdC5uYW1lLCBjdHgsIGNhbnZhc3gsIHB0LmNhbnZhc3ksXG4gICAgICAgICAgY29sb3IsIGNpcmNsZVNpemUsIHB0LmlkeCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICB0aGlzLnByZXZpb3VzVmVydGljYWxYXyA9IGNhbnZhc3g7XG4gIH1cbn07XG5cbi8qKlxuICogTWFudWFsbHkgc2V0IHRoZSBzZWxlY3RlZCBwb2ludHMgYW5kIGRpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlbSBpbiB0aGVcbiAqIGxlZ2VuZC4gVGhlIHNlbGVjdGlvbiBjYW4gYmUgY2xlYXJlZCB1c2luZyBjbGVhclNlbGVjdGlvbigpIGFuZCBxdWVyaWVkXG4gKiB1c2luZyBnZXRTZWxlY3Rpb24oKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgUm93IG51bWJlciB0aGF0IHNob3VsZCBiZSBoaWdobGlnaHRlZCAoaS5lLiBhcHBlYXIgd2l0aFxuICogaG92ZXIgZG90cyBvbiB0aGUgY2hhcnQpLlxuICogQHBhcmFtIHtzZXJpZXNOYW1lfSBvcHRpb25hbCBzZXJpZXMgbmFtZSB0byBoaWdobGlnaHQgdGhhdCBzZXJpZXMgd2l0aCB0aGVcbiAqIHRoZSBoaWdobGlnaHRTZXJpZXNPcHRzIHNldHRpbmcuXG4gKiBAcGFyYW0geyBsb2NrZWQgfSBvcHRpb25hbCBJZiB0cnVlLCBrZWVwIHNlcmllc05hbWUgc2VsZWN0ZWQgd2hlbiBtb3VzaW5nXG4gKiBvdmVyIHRoZSBncmFwaCwgZGlzYWJsaW5nIGNsb3Nlc3Qtc2VyaWVzIGhpZ2hsaWdodGluZy4gQ2FsbCBjbGVhclNlbGVjdGlvbigpXG4gKiB0byB1bmxvY2sgaXQuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJvdywgb3B0X3Nlcmllc05hbWUsIG9wdF9sb2NrZWQpIHtcbiAgLy8gRXh0cmFjdCB0aGUgcG9pbnRzIHdlJ3ZlIHNlbGVjdGVkXG4gIHRoaXMuc2VsUG9pbnRzXyA9IFtdO1xuXG4gIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChyb3cgIT09IGZhbHNlICYmIHJvdyA+PSAwKSB7XG4gICAgaWYgKHJvdyAhPSB0aGlzLmxhc3RSb3dfKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RSb3dfID0gcm93O1xuICAgIGZvciAodmFyIHNldElkeCA9IDA7IHNldElkeCA8IHRoaXMubGF5b3V0Xy5wb2ludHMubGVuZ3RoOyArK3NldElkeCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBwb2ludCBhdCB0aGUgYXBwcm9wcmlhdGUgaW5kZXggaXMgdGhlIHBvaW50IHdlJ3JlIGxvb2tpbmdcbiAgICAgIC8vIGZvci4gIElmIGl0IGlzLCBqdXN0IHVzZSBpdCwgb3RoZXJ3aXNlIHNlYXJjaCB0aGUgYXJyYXkgZm9yIGEgcG9pbnRcbiAgICAgIC8vIGluIHRoZSBwcm9wZXIgcGxhY2UuXG4gICAgICB2YXIgc2V0Um93ID0gcm93IC0gdGhpcy5nZXRMZWZ0Qm91bmRhcnlfKHNldElkeCk7XG4gICAgICBpZiAoc2V0Um93IDwgcG9pbnRzLmxlbmd0aCAmJiBwb2ludHNbc2V0Um93XS5pZHggPT0gcm93KSB7XG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tzZXRSb3ddO1xuICAgICAgICBpZiAocG9pbnQueXZhbCAhPT0gbnVsbCkgdGhpcy5zZWxQb2ludHNfLnB1c2gocG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgcG9pbnRJZHggPSAwOyBwb2ludElkeCA8IHBvaW50cy5sZW5ndGg7ICsrcG9pbnRJZHgpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbcG9pbnRJZHhdO1xuICAgICAgICAgIGlmIChwb2ludC5pZHggPT0gcm93KSB7XG4gICAgICAgICAgICBpZiAocG9pbnQueXZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLnNlbFBvaW50c18ucHVzaChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMubGFzdFJvd18gPj0gMCkgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5sYXN0Um93XyA9IC0xO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VsUG9pbnRzXy5sZW5ndGgpIHtcbiAgICB0aGlzLmxhc3R4XyA9IHRoaXMuc2VsUG9pbnRzX1swXS54dmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdHhfID0gLTE7XG4gIH1cblxuICBpZiAob3B0X3Nlcmllc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmhpZ2hsaWdodFNldF8gIT09IG9wdF9zZXJpZXNOYW1lKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmhpZ2hsaWdodFNldF8gPSBvcHRfc2VyaWVzTmFtZTtcbiAgfVxuXG4gIGlmIChvcHRfbG9ja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmxvY2tlZFNldF8gPSBvcHRfbG9ja2VkO1xuICB9XG5cbiAgaWYgKGNoYW5nZWQpIHtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbl8odW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbi8qKlxuICogVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSBjYW52YXMuIENsZWFyIG91dCB3aGF0ZXZlciBhcnRpZmFjdHMgcmVtYWluXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIG1vdXNlb3V0IGV2ZW50IGZyb20gdGhlIGJyb3dzZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5tb3VzZU91dF8gPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAodGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInVuaGlnaGxpZ2h0Q2FsbGJhY2tcIikpIHtcbiAgICB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwidW5oaWdobGlnaHRDYWxsYmFja1wiKS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJoaWRlT3ZlcmxheU9uTW91c2VPdXRcIikgJiYgIXRoaXMubG9ja2VkU2V0Xykge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIChpLmUuIHBvaW50cyB0aGF0IHdlcmUgaGlnaGxpZ2h0ZWQgYnkgbW92aW5nXG4gKiB0aGUgbW91c2Ugb3ZlciB0aGUgY2hhcnQpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNhc2NhZGVFdmVudHNfKCdkZXNlbGVjdCcsIHt9KTtcblxuICB0aGlzLmxvY2tlZFNldF8gPSBmYWxzZTtcbiAgLy8gR2V0IHJpZCBvZiB0aGUgb3ZlcmxheSBkYXRhXG4gIGlmICh0aGlzLmZhZGVMZXZlbCkge1xuICAgIHRoaXMuYW5pbWF0ZVNlbGVjdGlvbl8oLTEpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmNhbnZhc19jdHhfLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbiAgdGhpcy5mYWRlTGV2ZWwgPSAwO1xuICB0aGlzLnNlbFBvaW50c18gPSBbXTtcbiAgdGhpcy5sYXN0eF8gPSAtMTtcbiAgdGhpcy5sYXN0Um93XyA9IC0xO1xuICB0aGlzLmhpZ2hsaWdodFNldF8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByb3cuIFRvIGdldCBkYXRhIGZvciB0aGlzIHJvdyxcbiAqIHlvdSBjYW4gdXNlIHRoZSBnZXRWYWx1ZSBtZXRob2QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHJvdyBudW1iZXIsIG9yIC0xIGlmIG5vdGhpbmcgaXMgc2VsZWN0ZWRcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5zZWxQb2ludHNfIHx8IHRoaXMuc2VsUG9pbnRzXy5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yICh2YXIgc2V0SWR4ID0gMDsgc2V0SWR4IDwgdGhpcy5sYXlvdXRfLnBvaW50cy5sZW5ndGg7IHNldElkeCsrKSB7XG4gICAgdmFyIHBvaW50cyA9IHRoaXMubGF5b3V0Xy5wb2ludHNbc2V0SWR4XTtcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBwb2ludHMubGVuZ3RoOyByb3crKykge1xuICAgICAgaWYgKHBvaW50c1tyb3ddLnggPT0gdGhpcy5zZWxQb2ludHNfWzBdLngpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1tyb3ddLmlkeDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHktaGlnaGxpZ2h0ZWQgc2VyaWVzLlxuICogT25seSBhdmFpbGFibGUgd2hlbiB0aGUgaGlnaGxpZ2h0U2VyaWVzT3B0cyBvcHRpb24gaXMgaW4gdXNlLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZXJpZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0U2V0Xztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50bHktaGlnaGxpZ2h0ZWQgc2VyaWVzIHdhcyBsb2NrZWRcbiAqIHZpYSBzZXRTZWxlY3Rpb24oLi4uLCBzZXJpZXNOYW1lLCB0cnVlKS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuaXNTZXJpZXNMb2NrZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubG9ja2VkU2V0Xztcbn07XG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGVyZSdzIGRhdGEgYXZhaWxhYmxlIHRvIGJlIGdyYXBoZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBSYXcgQ1NWIGRhdGEgdG8gYmUgcGxvdHRlZFxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubG9hZGVkRXZlbnRfID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLnJhd0RhdGFfID0gdGhpcy5wYXJzZUNTVl8oZGF0YSk7XG4gIHRoaXMuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8oKTtcbiAgdGhpcy5wcmVkcmF3XygpO1xufTtcblxuLyoqXG4gKiBBZGQgdGlja3Mgb24gdGhlIHgtYXhpcyByZXByZXNlbnRpbmcgeWVhcnMsIG1vbnRocywgcXVhcnRlcnMsIHdlZWtzLCBvciBkYXlzXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hZGRYVGlja3NfID0gZnVuY3Rpb24oKSB7XG4gIC8vIERldGVybWluZSB0aGUgY29ycmVjdCB0aWNrcyBzY2FsZSBvbiB0aGUgeC1heGlzOiBxdWFydGVybHksIG1vbnRobHksIC4uLlxuICB2YXIgcmFuZ2U7XG4gIGlmICh0aGlzLmRhdGVXaW5kb3dfKSB7XG4gICAgcmFuZ2UgPSBbdGhpcy5kYXRlV2luZG93X1swXSwgdGhpcy5kYXRlV2luZG93X1sxXV07XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2UgPSB0aGlzLnhBeGlzRXh0cmVtZXMoKTtcbiAgfVxuXG4gIHZhciB4QXhpc09wdGlvbnNWaWV3ID0gdGhpcy5vcHRpb25zVmlld0ZvckF4aXNfKCd4Jyk7XG4gIHZhciB4VGlja3MgPSB4QXhpc09wdGlvbnNWaWV3KCd0aWNrZXInKShcbiAgICAgIHJhbmdlWzBdLFxuICAgICAgcmFuZ2VbMV0sXG4gICAgICB0aGlzLnBsb3R0ZXJfLmFyZWEudywgIC8vIFRPRE8oZGFudmspOiBzaG91bGQgYmUgYXJlYS53aWR0aFxuICAgICAgeEF4aXNPcHRpb25zVmlldyxcbiAgICAgIHRoaXMpO1xuICAvLyB2YXIgbXNnID0gJ3RpY2tlcignICsgcmFuZ2VbMF0gKyAnLCAnICsgcmFuZ2VbMV0gKyAnLCAnICsgdGhpcy53aWR0aF8gKyAnLCAnICsgdGhpcy5hdHRyXygncGl4ZWxzUGVyWExhYmVsJykgKyAnKSAtPiAnICsgSlNPTi5zdHJpbmdpZnkoeFRpY2tzKTtcbiAgLy8gY29uc29sZS5sb2cobXNnKTtcbiAgdGhpcy5sYXlvdXRfLnNldFhUaWNrcyh4VGlja3MpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb3JyZWN0IGhhbmRsZXIgY2xhc3MgZm9yIHRoZSBjdXJyZW50bHkgc2V0IG9wdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRIYW5kbGVyQ2xhc3NfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYW5kbGVyQ2xhc3M7XG4gIGlmICh0aGlzLmF0dHJfKCdkYXRhSGFuZGxlcicpKSB7XG4gICAgaGFuZGxlckNsYXNzID0gIHRoaXMuYXR0cl8oJ2RhdGFIYW5kbGVyJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5mcmFjdGlvbnNfKSB7XG4gICAgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignZXJyb3JCYXJzJykpIHtcbiAgICAgIGhhbmRsZXJDbGFzcyA9IEZyYWN0aW9uc0JhcnNIYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyQ2xhc3MgPSBEZWZhdWx0RnJhY3Rpb25IYW5kbGVyO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oJ2N1c3RvbUJhcnMnKSkge1xuICAgIGhhbmRsZXJDbGFzcyA9IEN1c3RvbUJhcnNIYW5kbGVyO1xuICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbignZXJyb3JCYXJzJykpIHtcbiAgICBoYW5kbGVyQ2xhc3MgPSBFcnJvckJhcnNIYW5kbGVyO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZXJDbGFzcyA9IERlZmF1bHRIYW5kbGVyO1xuICB9XG4gIHJldHVybiBoYW5kbGVyQ2xhc3M7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlIGNoYXJ0J3MgZGF0YSBpcyBjaGFuZ2VkIG9yIHRoZSBvcHRpb25zXG4gKiBkaWN0aW9uYXJ5IGlzIHVwZGF0ZWQuIEl0IGlzIF9ub3RfIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHBhbnMgb3Igem9vbXMuIFRoZVxuICogaWRlYSBpcyB0aGF0IHZhbHVlcyBkZXJpdmVkIGZyb20gdGhlIGNoYXJ0J3MgZGF0YSBjYW4gYmUgY29tcHV0ZWQgaGVyZSxcbiAqIHJhdGhlciB0aGFuIGV2ZXJ5IHRpbWUgdGhlIGNoYXJ0IGlzIGRyYXduLiBUaGlzIGluY2x1ZGVzIHRoaW5ncyBsaWtlIHRoZVxuICogbnVtYmVyIG9mIGF4ZXMsIHJvbGxpbmcgYXZlcmFnZXMsIGV0Yy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucHJlZHJhd18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcblxuICAvLyBDcmVhdGUgdGhlIGNvcnJlY3QgZGF0YUhhbmRsZXJcbiAgdGhpcy5kYXRhSGFuZGxlcl8gPSBuZXcgKHRoaXMuZ2V0SGFuZGxlckNsYXNzXygpKSgpO1xuXG4gIHRoaXMubGF5b3V0Xy5jb21wdXRlUGxvdEFyZWEoKTtcblxuICAvLyBUT0RPKGRhbnZrKTogbW92ZSBtb3JlIGNvbXB1dGF0aW9ucyBvdXQgb2YgZHJhd0dyYXBoXyBhbmQgaW50byBoZXJlLlxuICB0aGlzLmNvbXB1dGVZQXhlc18oKTtcblxuICBpZiAoIXRoaXMuaXNfaW5pdGlhbF9kcmF3Xykge1xuICAgIHRoaXMuY2FudmFzX2N0eF8ucmVzdG9yZSgpO1xuICAgIHRoaXMuaGlkZGVuX2N0eF8ucmVzdG9yZSgpO1xuICB9XG5cbiAgdGhpcy5jYW52YXNfY3R4Xy5zYXZlKCk7XG4gIHRoaXMuaGlkZGVuX2N0eF8uc2F2ZSgpO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBwbG90dGVyLlxuICB0aGlzLnBsb3R0ZXJfID0gbmV3IER5Z3JhcGhDYW52YXNSZW5kZXJlcih0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGRlbl8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuX2N0eF8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Xyk7XG5cbiAgLy8gVGhlIHJvbGxlciBzaXRzIGluIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGNoYXJ0LiBXZSBkb24ndCBrbm93IHdoZXJlXG4gIC8vIHRoaXMgd2lsbCBiZSB1bnRpbCB0aGUgb3B0aW9ucyBhcmUgYXZhaWxhYmxlLCBzbyBpdCdzIHBvc2l0aW9uZWQgaGVyZS5cbiAgdGhpcy5jcmVhdGVSb2xsSW50ZXJmYWNlXygpO1xuXG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3ByZWRyYXcnKTtcblxuICAvLyBDb252ZXJ0IHRoZSByYXcgZGF0YSAoYSAyRCBhcnJheSkgaW50byB0aGUgaW50ZXJuYWwgZm9ybWF0IGFuZCBjb21wdXRlXG4gIC8vIHJvbGxpbmcgYXZlcmFnZXMuXG4gIHRoaXMucm9sbGVkU2VyaWVzXyA9IFtudWxsXTsgIC8vIHgtYXhpcyBpcyB0aGUgZmlyc3Qgc2VyaWVzIGFuZCBpdCdzIHNwZWNpYWxcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm51bUNvbHVtbnMoKTsgaSsrKSB7XG4gICAgLy8gdmFyIGxvZ1NjYWxlID0gdGhpcy5hdHRyXygnbG9nc2NhbGUnLCBpKTsgLy8gVE9ETyhrbGF1c3cpOiB0aGlzIGxvb2tzIHdyb25nIC8vIGtvbmlnc2JlcmcgdGhpbmtzIHNvIHRvby5cbiAgICB2YXIgc2VyaWVzID0gdGhpcy5kYXRhSGFuZGxlcl8uZXh0cmFjdFNlcmllcyh0aGlzLnJhd0RhdGFfLCBpLCB0aGlzLmF0dHJpYnV0ZXNfKTtcbiAgICBpZiAodGhpcy5yb2xsUGVyaW9kXyA+IDEpIHtcbiAgICAgIHNlcmllcyA9IHRoaXMuZGF0YUhhbmRsZXJfLnJvbGxpbmdBdmVyYWdlKHNlcmllcywgdGhpcy5yb2xsUGVyaW9kXywgdGhpcy5hdHRyaWJ1dGVzXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yb2xsZWRTZXJpZXNfLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBkYXRhIG9yIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCB0aGVuIHdlJ2QgYmV0dGVyIHJlZHJhdy5cbiAgdGhpcy5kcmF3R3JhcGhfKCk7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIGRvIHZhcmlvdXMgYW5pbWF0aW9ucy5cbiAgdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZHJhd2luZ1RpbWVNc18gPSAoZW5kIC0gc3RhcnQpO1xufTtcblxuLyoqXG4gKiBQb2ludCBzdHJ1Y3R1cmUuXG4gKlxuICogeHZhbF8qIGFuZCB5dmFsXyogYXJlIHRoZSBvcmlnaW5hbCB1bnNjYWxlZCBkYXRhIHZhbHVlcyxcbiAqIHdoaWxlIHhfKiBhbmQgeV8qIGFyZSBzY2FsZWQgdG8gdGhlIHJhbmdlICgwLjAtMS4wKSBmb3IgcGxvdHRpbmcuXG4gKiB5dmFsX3N0YWNrZWQgaXMgdGhlIGN1bXVsYXRpdmUgWSB2YWx1ZSB1c2VkIGZvciBzdGFja2luZyBncmFwaHMsXG4gKiBhbmQgYm90dG9tL3RvcC9taW51cy9wbHVzIGFyZSB1c2VkIGZvciBlcnJvciBiYXIgZ3JhcGhzLlxuICpcbiAqIEB0eXBlZGVmIHt7XG4gKiAgICAgaWR4OiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nLFxuICogICAgIHg6ID9udW1iZXIsXG4gKiAgICAgeHZhbDogP251bWJlcixcbiAqICAgICB5X2JvdHRvbTogP251bWJlcixcbiAqICAgICB5OiA/bnVtYmVyLFxuICogICAgIHlfc3RhY2tlZDogP251bWJlcixcbiAqICAgICB5X3RvcDogP251bWJlcixcbiAqICAgICB5dmFsX21pbnVzOiA/bnVtYmVyLFxuICogICAgIHl2YWw6ID9udW1iZXIsXG4gKiAgICAgeXZhbF9wbHVzOiA/bnVtYmVyLFxuICogICAgIHl2YWxfc3RhY2tlZFxuICogfX1cbiAqL1xuRHlncmFwaC5Qb2ludFR5cGUgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBwb2ludCBzdGFja2luZyBmb3Igc3RhY2tlZEdyYXBoPXRydWUuXG4gKlxuICogRm9yIHN0YWNraW5nIHB1cnBvc2VzLCBpbnRlcnBvbGF0ZSBvciBleHRlbmQgbmVpZ2hib3JpbmcgZGF0YSBhY3Jvc3NcbiAqIE5hTiB2YWx1ZXMgYmFzZWQgb24gc3RhY2tlZEdyYXBoTmFORmlsbCBzZXR0aW5ncy4gVGhpcyBpcyBmb3IgZGlzcGxheVxuICogb25seSwgdGhlIHVuZGVybHlpbmcgZGF0YSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgbGVnZW5kIHJlbWFpbnMgTmFOLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPn0gcG9pbnRzIFBvaW50IGFycmF5IGZvciBhIHNpbmdsZSBzZXJpZXMuXG4gKiAgICAgVXBkYXRlcyBlYWNoIFBvaW50J3MgeXZhbF9zdGFja2VkIHByb3BlcnR5LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY3VtdWxhdGl2ZVl2YWwgQWNjdW11bGF0ZWQgdG9wLW9mLWdyYXBoIHN0YWNrZWQgWVxuICogICAgIHZhbHVlcyBmb3IgdGhlIHNlcmllcyBzZWVuIHNvIGZhci4gSW5kZXggaXMgdGhlIHJvdyBudW1iZXIuIFVwZGF0ZWRcbiAqICAgICBiYXNlZCBvbiB0aGUgY3VycmVudCBzZXJpZXMncyB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzZXJpZXNFeHRyZW1lcyBNaW4gYW5kIG1heCB2YWx1ZXMsIHVwZGF0ZWRcbiAqICAgICB0byByZWZsZWN0IHRoZSBzdGFja2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsTWV0aG9kIEludGVycG9sYXRpb24gbWV0aG9kLCBvbmUgb2YgJ2FsbCcsICdpbnNpZGUnLCBvclxuICogICAgICdub25lJy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGguc3RhY2tQb2ludHNfID0gZnVuY3Rpb24oXG4gICAgcG9pbnRzLCBjdW11bGF0aXZlWXZhbCwgc2VyaWVzRXh0cmVtZXMsIGZpbGxNZXRob2QpIHtcbiAgdmFyIGxhc3RYdmFsID0gbnVsbDtcbiAgdmFyIHByZXZQb2ludCA9IG51bGw7XG4gIHZhciBuZXh0UG9pbnQgPSBudWxsO1xuICB2YXIgbmV4dFBvaW50SWR4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgbmV4dCBzdGFja2FibGUgcG9pbnQgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gaW5kZXguXG4gIHZhciB1cGRhdGVOZXh0UG9pbnQgPSBmdW5jdGlvbihpZHgpIHtcbiAgICAvLyBJZiB3ZSd2ZSBwcmV2aW91c2x5IGZvdW5kIGEgbm9uLU5hTiBwb2ludCBhbmQgaGF2ZW4ndCBnb25lIHBhc3QgaXQgeWV0LFxuICAgIC8vIGp1c3QgdXNlIHRoYXQuXG4gICAgaWYgKG5leHRQb2ludElkeCA+PSBpZHgpIHJldHVybjtcblxuICAgIC8vIFdlIGhhdmVuJ3QgZm91bmQgYSBub24tTmFOIHBvaW50IHlldCBvciBoYXZlIG1vdmVkIHBhc3QgaXQsXG4gICAgLy8gbG9vayB0b3dhcmRzIHRoZSByaWdodCB0byBmaW5kIGEgbm9uLU5hTiBwb2ludC5cbiAgICBmb3IgKHZhciBqID0gaWR4OyBqIDwgcG9pbnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAvLyBDbGVhciBvdXQgYSBwcmV2aW91c2x5LWZvdW5kIHBvaW50IChpZiBhbnkpIHNpbmNlIGl0J3Mgbm8gbG9uZ2VyXG4gICAgICAvLyB2YWxpZCwgd2Ugc2hvdWxkbid0IHVzZSBpdCBmb3IgaW50ZXJwb2xhdGlvbiBhbnltb3JlLlxuICAgICAgbmV4dFBvaW50ID0gbnVsbDtcbiAgICAgIGlmICghaXNOYU4ocG9pbnRzW2pdLnl2YWwpICYmIHBvaW50c1tqXS55dmFsICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRQb2ludElkeCA9IGo7XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tqXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIHZhciB4dmFsID0gcG9pbnQueHZhbDtcbiAgICBpZiAoY3VtdWxhdGl2ZVl2YWxbeHZhbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VtdWxhdGl2ZVl2YWxbeHZhbF0gPSAwO1xuICAgIH1cblxuICAgIHZhciBhY3R1YWxZdmFsID0gcG9pbnQueXZhbDtcbiAgICBpZiAoaXNOYU4oYWN0dWFsWXZhbCkgfHwgYWN0dWFsWXZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYoZmlsbE1ldGhvZCA9PSAnbm9uZScpIHtcbiAgICAgICAgYWN0dWFsWXZhbCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZS9leHRlbmQgZm9yIHN0YWNraW5nIHB1cnBvc2VzIGlmIHBvc3NpYmxlLlxuICAgICAgICB1cGRhdGVOZXh0UG9pbnQoaSk7XG4gICAgICAgIGlmIChwcmV2UG9pbnQgJiYgbmV4dFBvaW50ICYmIGZpbGxNZXRob2QgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgLy8gVXNlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gcHJldlBvaW50IGFuZCBuZXh0UG9pbnQuXG4gICAgICAgICAgYWN0dWFsWXZhbCA9IHByZXZQb2ludC55dmFsICsgKG5leHRQb2ludC55dmFsIC0gcHJldlBvaW50Lnl2YWwpICpcbiAgICAgICAgICAgICAgKCh4dmFsIC0gcHJldlBvaW50Lnh2YWwpIC8gKG5leHRQb2ludC54dmFsIC0gcHJldlBvaW50Lnh2YWwpKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2UG9pbnQgJiYgZmlsbE1ldGhvZCA9PSAnYWxsJykge1xuICAgICAgICAgIGFjdHVhbFl2YWwgPSBwcmV2UG9pbnQueXZhbDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0UG9pbnQgJiYgZmlsbE1ldGhvZCA9PSAnYWxsJykge1xuICAgICAgICAgIGFjdHVhbFl2YWwgPSBuZXh0UG9pbnQueXZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3R1YWxZdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2tlZFl2YWwgPSBjdW11bGF0aXZlWXZhbFt4dmFsXTtcbiAgICBpZiAobGFzdFh2YWwgIT0geHZhbCkge1xuICAgICAgLy8gSWYgYW4geC12YWx1ZSBpcyByZXBlYXRlZCwgd2UgaWdub3JlIHRoZSBkdXBsaWNhdGVzLlxuICAgICAgc3RhY2tlZFl2YWwgKz0gYWN0dWFsWXZhbDtcbiAgICAgIGN1bXVsYXRpdmVZdmFsW3h2YWxdID0gc3RhY2tlZFl2YWw7XG4gICAgfVxuICAgIGxhc3RYdmFsID0geHZhbDtcblxuICAgIHBvaW50Lnl2YWxfc3RhY2tlZCA9IHN0YWNrZWRZdmFsO1xuXG4gICAgaWYgKHN0YWNrZWRZdmFsID4gc2VyaWVzRXh0cmVtZXNbMV0pIHtcbiAgICAgIHNlcmllc0V4dHJlbWVzWzFdID0gc3RhY2tlZFl2YWw7XG4gICAgfVxuICAgIGlmIChzdGFja2VkWXZhbCA8IHNlcmllc0V4dHJlbWVzWzBdKSB7XG4gICAgICBzZXJpZXNFeHRyZW1lc1swXSA9IHN0YWNrZWRZdmFsO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIExvb3Agb3ZlciBhbGwgZmllbGRzIGFuZCBjcmVhdGUgZGF0YXNldHMsIGNhbGN1bGF0aW5nIGV4dHJlbWUgeS12YWx1ZXMgZm9yXG4gKiBlYWNoIHNlcmllcyBhbmQgZXh0cmVtZSB4LWluZGljZXMgYXMgd2UgZ28uXG4gKlxuICogZGF0ZVdpbmRvdyBpcyBwYXNzZWQgaW4gYXMgYW4gZXhwbGljaXQgcGFyYW1ldGVyIHNvIHRoYXQgd2UgY2FuIGNvbXB1dGVcbiAqIGV4dHJlbWUgdmFsdWVzIFwic3BlY3VsYXRpdmVseVwiLCBpLmUuIHdpdGhvdXQgYWN0dWFsbHkgc2V0dGluZyBzdGF0ZSBvbiB0aGVcbiAqIGR5Z3JhcGguXG4gKlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPEFycmF5LjwobnVtYmVyfEFycmF5PG51bWJlcj4pPj59IHJvbGxlZFNlcmllcywgd2hlcmVcbiAqICAgICByb2xsZWRTZXJpZXNbc2VyaWVzSW5kZXhdW3Jvd10gPSByYXcgcG9pbnQsIHdoZXJlXG4gKiAgICAgc2VyaWVzSW5kZXggaXMgdGhlIGNvbHVtbiBudW1iZXIgc3RhcnRpbmcgd2l0aCAxLCBhbmRcbiAqICAgICByYXdQb2ludCBpcyBbeCx5XSBvciBbeCwgW3ksIGVycl1dIG9yIFt4LCBbeSwgeW1pbnVzLCB5cGx1c11dLlxuICogQHBhcmFtIHs/QXJyYXkuPG51bWJlcj59IGRhdGVXaW5kb3cgW3htaW4sIHhtYXhdIHBhaXIsIG9yIG51bGwuXG4gKiBAcmV0dXJuIHt7XG4gKiAgICAgcG9pbnRzOiBBcnJheS48QXJyYXkuPER5Z3JhcGguUG9pbnRUeXBlPj4sXG4gKiAgICAgc2VyaWVzRXh0cmVtZXM6IEFycmF5LjxBcnJheS48bnVtYmVyPj4sXG4gKiAgICAgYm91bmRhcnlJZHM6IEFycmF5LjxudW1iZXI+fX1cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmdhdGhlckRhdGFzZXRzXyA9IGZ1bmN0aW9uKHJvbGxlZFNlcmllcywgZGF0ZVdpbmRvdykge1xuICB2YXIgYm91bmRhcnlJZHMgPSBbXTtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICB2YXIgY3VtdWxhdGl2ZVl2YWwgPSBbXTsgIC8vIEZvciBzdGFja2VkIHNlcmllcy5cbiAgdmFyIGV4dHJlbWVzID0ge307ICAvLyBzZXJpZXMgbmFtZSAtPiBbbG93LCBoaWdoXVxuICB2YXIgc2VyaWVzSWR4LCBzYW1wbGVJZHg7XG4gIHZhciBmaXJzdElkeCwgbGFzdElkeDtcbiAgdmFyIGF4aXNJZHg7XG5cbiAgLy8gTG9vcCBvdmVyIHRoZSBmaWVsZHMgKHNlcmllcykuICBHbyBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdCxcbiAgLy8gYmVjYXVzZSBpZiB0aGV5J3JlIHN0YWNrZWQgdGhhdCdzIGhvdyB3ZSBhY2N1bXVsYXRlIHRoZSB2YWx1ZXMuXG4gIHZhciBudW1fc2VyaWVzID0gcm9sbGVkU2VyaWVzLmxlbmd0aCAtIDE7XG4gIHZhciBzZXJpZXM7XG4gIGZvciAoc2VyaWVzSWR4ID0gbnVtX3Nlcmllczsgc2VyaWVzSWR4ID49IDE7IHNlcmllc0lkeC0tKSB7XG4gICAgaWYgKCF0aGlzLnZpc2liaWxpdHkoKVtzZXJpZXNJZHggLSAxXSkgY29udGludWU7XG5cbiAgICAvLyBQcnVuZSBkb3duIHRvIHRoZSBkZXNpcmVkIHJhbmdlLCBpZiBuZWNlc3NhcnkgKGZvciB6b29taW5nKVxuICAgIC8vIEJlY2F1c2UgdGhlcmUgY2FuIGJlIGxpbmVzIGdvaW5nIHRvIHBvaW50cyBvdXRzaWRlIG9mIHRoZSB2aXNpYmxlIGFyZWEsXG4gICAgLy8gd2UgYWN0dWFsbHkgcHJ1bmUgdG8gdmlzaWJsZSBwb2ludHMsIHBsdXMgb25lIG9uIGVpdGhlciBzaWRlLlxuICAgIGlmIChkYXRlV2luZG93KSB7XG4gICAgICBzZXJpZXMgPSByb2xsZWRTZXJpZXNbc2VyaWVzSWR4XTtcbiAgICAgIHZhciBsb3cgPSBkYXRlV2luZG93WzBdO1xuICAgICAgdmFyIGhpZ2ggPSBkYXRlV2luZG93WzFdO1xuXG4gICAgICAvLyBUT0RPKGRhbnZrKTogZG8gYmluYXJ5IHNlYXJjaCBpbnN0ZWFkIG9mIGxpbmVhciBzZWFyY2guXG4gICAgICAvLyBUT0RPKGRhbnZrKTogcGFzcyBmaXJzdElkeCBhbmQgbGFzdElkeCBkaXJlY3RseSB0byB0aGUgcmVuZGVyZXIuXG4gICAgICBmaXJzdElkeCA9IG51bGw7XG4gICAgICBsYXN0SWR4ID0gbnVsbDtcbiAgICAgIGZvciAoc2FtcGxlSWR4ID0gMDsgc2FtcGxlSWR4IDwgc2VyaWVzLmxlbmd0aDsgc2FtcGxlSWR4KyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzYW1wbGVJZHhdWzBdID49IGxvdyAmJiBmaXJzdElkeCA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0SWR4ID0gc2FtcGxlSWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJpZXNbc2FtcGxlSWR4XVswXSA8PSBoaWdoKSB7XG4gICAgICAgICAgbGFzdElkeCA9IHNhbXBsZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RJZHggPT09IG51bGwpIGZpcnN0SWR4ID0gMDtcbiAgICAgIHZhciBjb3JyZWN0ZWRGaXJzdElkeCA9IGZpcnN0SWR4O1xuICAgICAgdmFyIGlzSW52YWxpZFZhbHVlID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpc0ludmFsaWRWYWx1ZSAmJiBjb3JyZWN0ZWRGaXJzdElkeCA+IDApIHtcbiAgICAgICAgY29ycmVjdGVkRmlyc3RJZHgtLTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHkgdmFsdWUgaXMgbnVsbC5cbiAgICAgICAgaXNJbnZhbGlkVmFsdWUgPSBzZXJpZXNbY29ycmVjdGVkRmlyc3RJZHhdWzFdID09PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdElkeCA9PT0gbnVsbCkgbGFzdElkeCA9IHNlcmllcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGNvcnJlY3RlZExhc3RJZHggPSBsYXN0SWR4O1xuICAgICAgaXNJbnZhbGlkVmFsdWUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGlzSW52YWxpZFZhbHVlICYmIGNvcnJlY3RlZExhc3RJZHggPCBzZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb3JyZWN0ZWRMYXN0SWR4Kys7XG4gICAgICAgIGlzSW52YWxpZFZhbHVlID0gc2VyaWVzW2NvcnJlY3RlZExhc3RJZHhdWzFdID09PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ycmVjdGVkRmlyc3RJZHghPT1maXJzdElkeCkge1xuICAgICAgICBmaXJzdElkeCA9IGNvcnJlY3RlZEZpcnN0SWR4O1xuICAgICAgfVxuICAgICAgaWYgKGNvcnJlY3RlZExhc3RJZHggIT09IGxhc3RJZHgpIHtcbiAgICAgICAgbGFzdElkeCA9IGNvcnJlY3RlZExhc3RJZHg7XG4gICAgICB9XG5cbiAgICAgIGJvdW5kYXJ5SWRzW3Nlcmllc0lkeC0xXSA9IFtmaXJzdElkeCwgbGFzdElkeF07XG5cbiAgICAgIC8vIC5zbGljZSdzIGVuZCBpcyBleGNsdXNpdmUsIHdlIHdhbnQgdG8gaW5jbHVkZSBsYXN0SWR4LlxuICAgICAgc2VyaWVzID0gc2VyaWVzLnNsaWNlKGZpcnN0SWR4LCBsYXN0SWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmllcyA9IHJvbGxlZFNlcmllc1tzZXJpZXNJZHhdO1xuICAgICAgYm91bmRhcnlJZHNbc2VyaWVzSWR4LTFdID0gWzAsIHNlcmllcy5sZW5ndGgtMV07XG4gICAgfVxuXG4gICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpW3Nlcmllc0lkeF07XG4gICAgdmFyIHNlcmllc0V4dHJlbWVzID0gdGhpcy5kYXRhSGFuZGxlcl8uZ2V0RXh0cmVtZVlWYWx1ZXMoc2VyaWVzLFxuICAgICAgICBkYXRlV2luZG93LCB0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJzdGVwUGxvdFwiLHNlcmllc05hbWUpKTtcblxuICAgIHZhciBzZXJpZXNQb2ludHMgPSB0aGlzLmRhdGFIYW5kbGVyXy5zZXJpZXNUb1BvaW50cyhzZXJpZXMsXG4gICAgICAgIHNlcmllc05hbWUsIGJvdW5kYXJ5SWRzW3Nlcmllc0lkeC0xXVswXSk7XG5cbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoXCIpKSB7XG4gICAgICBheGlzSWR4ID0gdGhpcy5hdHRyaWJ1dGVzXy5heGlzRm9yU2VyaWVzKHNlcmllc05hbWUpO1xuICAgICAgaWYgKGN1bXVsYXRpdmVZdmFsW2F4aXNJZHhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VtdWxhdGl2ZVl2YWxbYXhpc0lkeF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIER5Z3JhcGguc3RhY2tQb2ludHNfKHNlcmllc1BvaW50cywgY3VtdWxhdGl2ZVl2YWxbYXhpc0lkeF0sIHNlcmllc0V4dHJlbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwic3RhY2tlZEdyYXBoTmFORmlsbFwiKSk7XG4gICAgfVxuXG4gICAgZXh0cmVtZXNbc2VyaWVzTmFtZV0gPSBzZXJpZXNFeHRyZW1lcztcbiAgICBwb2ludHNbc2VyaWVzSWR4XSA9IHNlcmllc1BvaW50cztcbiAgfVxuXG4gIHJldHVybiB7IHBvaW50czogcG9pbnRzLCBleHRyZW1lczogZXh0cmVtZXMsIGJvdW5kYXJ5SWRzOiBib3VuZGFyeUlkcyB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGdyYXBoIHdpdGggbmV3IGRhdGEuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSB2aWV3aW5nIGFyZWFcbiAqIGhhcyBjaGFuZ2VkLiBJZiB0aGUgdW5kZXJseWluZyBkYXRhIG9yIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCBwcmVkcmF3XyB3aWxsXG4gKiBiZSBjYWxsZWQgYmVmb3JlIGRyYXdHcmFwaF8gaXMgY2FsbGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmRyYXdHcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoKTtcblxuICAvLyBUaGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGRyYXdDYWxsYmFjaywgYmVsb3cuXG4gIHZhciBpc19pbml0aWFsX2RyYXcgPSB0aGlzLmlzX2luaXRpYWxfZHJhd187XG4gIHRoaXMuaXNfaW5pdGlhbF9kcmF3XyA9IGZhbHNlO1xuXG4gIHRoaXMubGF5b3V0Xy5yZW1vdmVBbGxEYXRhc2V0cygpO1xuICB0aGlzLnNldENvbG9yc18oKTtcbiAgdGhpcy5hdHRyc18ucG9pbnRTaXplID0gMC41ICogdGhpcy5nZXROdW1lcmljT3B0aW9uKCdoaWdobGlnaHRDaXJjbGVTaXplJyk7XG5cbiAgdmFyIHBhY2tlZCA9IHRoaXMuZ2F0aGVyRGF0YXNldHNfKHRoaXMucm9sbGVkU2VyaWVzXywgdGhpcy5kYXRlV2luZG93Xyk7XG4gIHZhciBwb2ludHMgPSBwYWNrZWQucG9pbnRzO1xuICB2YXIgZXh0cmVtZXMgPSBwYWNrZWQuZXh0cmVtZXM7XG4gIHRoaXMuYm91bmRhcnlJZHNfID0gcGFja2VkLmJvdW5kYXJ5SWRzO1xuXG4gIHRoaXMuc2V0SW5kZXhCeU5hbWVfID0ge307XG4gIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpO1xuICBpZiAobGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnNldEluZGV4QnlOYW1lX1tsYWJlbHNbMF1dID0gMDtcbiAgfVxuICB2YXIgZGF0YUlkeCA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5zZXRJbmRleEJ5TmFtZV9bbGFiZWxzW2ldXSA9IGk7XG4gICAgaWYgKCF0aGlzLnZpc2liaWxpdHkoKVtpIC0gMV0pIGNvbnRpbnVlO1xuICAgIHRoaXMubGF5b3V0Xy5hZGREYXRhc2V0KGxhYmVsc1tpXSwgcG9pbnRzW2ldKTtcbiAgICB0aGlzLmRhdGFzZXRJbmRleF9baV0gPSBkYXRhSWR4Kys7XG4gIH1cblxuICB0aGlzLmNvbXB1dGVZQXhpc1Jhbmdlc18oZXh0cmVtZXMpO1xuICB0aGlzLmxheW91dF8uc2V0WUF4ZXModGhpcy5heGVzXyk7XG5cbiAgdGhpcy5hZGRYVGlja3NfKCk7XG5cbiAgLy8gU2F2ZSB0aGUgWCBheGlzIHpvb21lZCBzdGF0dXMgYXMgdGhlIHVwZGF0ZU9wdGlvbnMgY2FsbCB3aWxsIHRlbmQgdG8gc2V0IGl0IGVycm9uZW91c2x5XG4gIHZhciB0bXBfem9vbWVkX3ggPSB0aGlzLnpvb21lZF94XztcbiAgLy8gVGVsbCBQbG90S2l0IHRvIHVzZSB0aGlzIG5ldyBkYXRhIGFuZCByZW5kZXIgaXRzZWxmXG4gIHRoaXMuem9vbWVkX3hfID0gdG1wX3pvb21lZF94O1xuICB0aGlzLmxheW91dF8uZXZhbHVhdGUoKTtcbiAgdGhpcy5yZW5kZXJHcmFwaF8oaXNfaW5pdGlhbF9kcmF3KTtcblxuICBpZiAodGhpcy5nZXRTdHJpbmdPcHRpb24oXCJ0aW1pbmdOYW1lXCIpKSB7XG4gICAgdmFyIGVuZCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc29sZS5sb2codGhpcy5nZXRTdHJpbmdPcHRpb24oXCJ0aW1pbmdOYW1lXCIpICsgXCIgLSBkcmF3R3JhcGg6IFwiICsgKGVuZCAtIHN0YXJ0KSArIFwibXNcIik7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBkb2VzIHRoZSB3b3JrIG9mIGRyYXdpbmcgdGhlIGNoYXJ0LiBJdCBhc3N1bWVzIHRoYXQgdGhlIGxheW91dCBhbmQgYXhpc1xuICogc2NhbGVzIGhhdmUgYWxyZWFkeSBiZWVuIHNldCAoZS5nLiBieSBwcmVkcmF3XykuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVuZGVyR3JhcGhfID0gZnVuY3Rpb24oaXNfaW5pdGlhbF9kcmF3KSB7XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ2NsZWFyQ2hhcnQnKTtcbiAgdGhpcy5wbG90dGVyXy5jbGVhcigpO1xuXG4gIGlmICh0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKCd1bmRlcmxheUNhbGxiYWNrJykpIHtcbiAgICAvLyBOT1RFOiB3ZSBwYXNzIHRoZSBkeWdyYXBoIG9iamVjdCB0byB0aGlzIGNhbGxiYWNrIHR3aWNlIHRvIGF2b2lkIGJyZWFraW5nXG4gICAgLy8gdXNlcnMgd2hvIGV4cGVjdCBhIGRlcHJlY2F0ZWQgZm9ybSBvZiB0aGlzIGNhbGxiYWNrLlxuICAgIHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oJ3VuZGVybGF5Q2FsbGJhY2snKS5jYWxsKHRoaXMsXG4gICAgICAgIHRoaXMuaGlkZGVuX2N0eF8sIHRoaXMubGF5b3V0Xy5nZXRQbG90QXJlYSgpLCB0aGlzLCB0aGlzKTtcbiAgfVxuXG4gIHZhciBlID0ge1xuICAgIGNhbnZhczogdGhpcy5oaWRkZW5fLFxuICAgIGRyYXdpbmdDb250ZXh0OiB0aGlzLmhpZGRlbl9jdHhfXG4gIH07XG4gIHRoaXMuY2FzY2FkZUV2ZW50c18oJ3dpbGxEcmF3Q2hhcnQnLCBlKTtcbiAgdGhpcy5wbG90dGVyXy5yZW5kZXIoKTtcbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGlkRHJhd0NoYXJ0JywgZSk7XG4gIHRoaXMubGFzdFJvd18gPSAtMTsgIC8vIGJlY2F1c2UgcGx1Z2lucy9sZWdlbmQuanMgY2xlYXJzIHRoZSBsZWdlbmRcblxuICAvLyBUT0RPKGRhbnZrKTogaXMgdGhpcyBhIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2sgd2hlbiBwYW5uaW5nP1xuICAvLyBUaGUgaW50ZXJhY3Rpb24gY2FudmFzIHNob3VsZCBhbHJlYWR5IGJlIGVtcHR5IGluIHRoYXQgc2l0dWF0aW9uLlxuICB0aGlzLmNhbnZhc18uZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG5cbiAgaWYgKHRoaXMuZ2V0RnVuY3Rpb25PcHRpb24oXCJkcmF3Q2FsbGJhY2tcIikgIT09IG51bGwpIHtcbiAgICB0aGlzLmdldEZ1bmN0aW9uT3B0aW9uKFwiZHJhd0NhbGxiYWNrXCIpLmNhbGwodGhpcywgdGhpcywgaXNfaW5pdGlhbF9kcmF3KTtcbiAgfVxuICBpZiAoaXNfaW5pdGlhbF9kcmF3KSB7XG4gICAgdGhpcy5yZWFkeUZpcmVkXyA9IHRydWU7XG4gICAgd2hpbGUgKHRoaXMucmVhZHlGbnNfLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBmbiA9IHRoaXMucmVhZHlGbnNfLnBvcCgpO1xuICAgICAgZm4odGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmUgcHJvcGVydGllcyBvZiB0aGUgeS1heGVzIHdoaWNoIGFyZSBpbmRlcGVuZGVudCBvZiB0aGUgZGF0YVxuICogY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZC4gVGhpcyBpbmNsdWRlcyB0aGluZ3MgbGlrZSB0aGUgbnVtYmVyIG9mIGF4ZXMgYW5kXG4gKiB0aGUgc3R5bGUgb2YgdGhlIGF4ZXMuIEl0IGRvZXMgbm90IGluY2x1ZGUgdGhlIHJhbmdlIG9mIGVhY2ggYXhpcyBhbmQgaXRzXG4gKiB0aWNrIG1hcmtzLlxuICogVGhpcyBmaWxscyBpbiB0aGlzLmF4ZXNfLlxuICogYXhlc18gPSBbIHsgb3B0aW9ucyB9IF1cbiAqICAgaW5kaWNlcyBhcmUgaW50byB0aGUgYXhlc18gYXJyYXkuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmNvbXB1dGVZQXhlc18gPSBmdW5jdGlvbigpIHtcbiAgLy8gUHJlc2VydmUgdmFsdWVXaW5kb3cgc2V0dGluZ3MgaWYgdGhleSBleGlzdCwgYW5kIGlmIHRoZSB1c2VyIGhhc24ndFxuICAvLyBzcGVjaWZpZWQgYSBuZXcgdmFsdWVSYW5nZS5cbiAgdmFyIHZhbHVlV2luZG93cywgYXhpcywgaW5kZXgsIG9wdHMsIHY7XG4gIGlmICh0aGlzLmF4ZXNfICE9PSB1bmRlZmluZWQgJiYgdGhpcy51c2VyX2F0dHJzXy5oYXNPd25Qcm9wZXJ0eShcInZhbHVlUmFuZ2VcIikgPT09IGZhbHNlKSB7XG4gICAgdmFsdWVXaW5kb3dzID0gW107XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5heGVzXy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlV2luZG93cy5wdXNoKHRoaXMuYXhlc19baW5kZXhdLnZhbHVlV2luZG93KTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzLmF4ZXNfIGRvZXNuJ3QgbWF0Y2ggdGhpcy5hdHRyaWJ1dGVzXy5heGVzXy5vcHRpb25zLiBJdCdzIHVzZWQgZm9yXG4gIC8vIGRhdGEgY29tcHV0YXRpb24gYXMgd2VsbCBhcyBvcHRpb25zIHN0b3JhZ2UuXG4gIC8vIEdvIHRocm91Z2ggb25jZSBhbmQgYWRkIGFsbCB0aGUgYXhlcy5cbiAgdGhpcy5heGVzXyA9IFtdO1xuXG4gIGZvciAoYXhpcyA9IDA7IGF4aXMgPCB0aGlzLmF0dHJpYnV0ZXNfLm51bUF4ZXMoKTsgYXhpcysrKSB7XG4gICAgLy8gQWRkIGEgbmV3IGF4aXMsIG1ha2luZyBhIGNvcHkgb2YgaXRzIHBlci1heGlzIG9wdGlvbnMuXG4gICAgb3B0cyA9IHsgZyA6IHRoaXMgfTtcbiAgICB1dGlscy51cGRhdGUob3B0cywgdGhpcy5hdHRyaWJ1dGVzXy5heGlzT3B0aW9ucyhheGlzKSk7XG4gICAgdGhpcy5heGVzX1theGlzXSA9IG9wdHM7XG4gIH1cblxuXG4gIC8vIENvcHkgZ2xvYmFsIHZhbHVlUmFuZ2Ugb3B0aW9uIG92ZXIgdG8gdGhlIGZpcnN0IGF4aXMuXG4gIC8vIE5PVEUoa29uaWdzYmVyZyk6IEFyZSB0aGVzZSB0d28gc3RhdGVtZW50cyBuZWNlc3Nhcnk/XG4gIC8vIEkgdHJpZWQgcmVtb3ZpbmcgaXQuIFRoZSBhdXRvbWF0ZWQgdGVzdHMgcGFzcywgYW5kIG1hbnVhbGx5XG4gIC8vIG1lc3Npbmcgd2l0aCB0ZXN0cy96b29tLmh0bWwgc2hvd2VkIG5vIHRyb3VibGUuXG4gIHYgPSB0aGlzLmF0dHJfKCd2YWx1ZVJhbmdlJyk7XG4gIGlmICh2KSB0aGlzLmF4ZXNfWzBdLnZhbHVlUmFuZ2UgPSB2O1xuXG4gIGlmICh2YWx1ZVdpbmRvd3MgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFJlc3RvcmUgdmFsdWVXaW5kb3cgc2V0dGluZ3MuXG5cbiAgICAvLyBXaGVuIGdvaW5nIGZyb20gdHdvIGF4ZXMgYmFjayB0byBvbmUsIHdlIG9ubHkgcmVzdG9yZVxuICAgIC8vIG9uZSBheGlzLlxuICAgIHZhciBpZHhDb3VudCA9IE1hdGgubWluKHZhbHVlV2luZG93cy5sZW5ndGgsIHRoaXMuYXhlc18ubGVuZ3RoKTtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGlkeENvdW50OyBpbmRleCsrKSB7XG4gICAgICB0aGlzLmF4ZXNfW2luZGV4XS52YWx1ZVdpbmRvdyA9IHZhbHVlV2luZG93c1tpbmRleF07XG4gICAgfVxuICB9XG5cbiAgZm9yIChheGlzID0gMDsgYXhpcyA8IHRoaXMuYXhlc18ubGVuZ3RoOyBheGlzKyspIHtcbiAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgb3B0cyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoYXhpcyA/ICcyJyA6ICcnKSk7XG4gICAgICB2ID0gb3B0cyhcInZhbHVlUmFuZ2VcIik7XG4gICAgICBpZiAodikgdGhpcy5heGVzX1theGlzXS52YWx1ZVJhbmdlID0gdjtcbiAgICB9IGVsc2UgeyAgLy8gVG8ga2VlcCBvbGQgYmVoYXZpb3JcbiAgICAgIHZhciBheGVzID0gdGhpcy51c2VyX2F0dHJzXy5heGVzO1xuICAgICAgaWYgKGF4ZXMgJiYgYXhlcy55Mikge1xuICAgICAgICB2ID0gYXhlcy55Mi52YWx1ZVJhbmdlO1xuICAgICAgICBpZiAodikgdGhpcy5heGVzX1theGlzXS52YWx1ZVJhbmdlID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHktYXhlcyBvbiB0aGUgY2hhcnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgYXhlcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUubnVtQXhlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzXy5udW1BeGVzKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXR1cm5zIGF4aXMgcHJvcGVydGllcyBmb3IgdGhlIGdpdmVuIHNlcmllcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgZm9yIHdoaWNoIHRvIGdldCBheGlzXG4gKiBwcm9wZXJ0aWVzLCBlLmcuICdZMScuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBheGlzIHByb3BlcnRpZXMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmF4aXNQcm9wZXJ0aWVzRm9yU2VyaWVzID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIC8vIFRPRE8oZGFudmspOiBoYW5kbGUgZXJyb3JzLlxuICByZXR1cm4gdGhpcy5heGVzX1t0aGlzLmF0dHJpYnV0ZXNfLmF4aXNGb3JTZXJpZXMoc2VyaWVzKV07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmUgdGhlIHZhbHVlIHJhbmdlIGFuZCB0aWNrIG1hcmtzIGZvciBlYWNoIGF4aXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cmVtZXMgQSBtYXBwaW5nIGZyb20gc2VyaWVzTmFtZSAtPiBbbG93LCBoaWdoXVxuICogVGhpcyBmaWxscyBpbiB0aGUgdmFsdWVSYW5nZSBhbmQgdGlja3MgZmllbGRzIGluIGVhY2ggZW50cnkgb2YgdGhpcy5heGVzXy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY29tcHV0ZVlBeGlzUmFuZ2VzXyA9IGZ1bmN0aW9uKGV4dHJlbWVzKSB7XG4gIHZhciBpc051bGxVbmRlZmluZWRPck5hTiA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiBpc05hTihwYXJzZUZsb2F0KG51bSkpO1xuICB9O1xuICB2YXIgbnVtQXhlcyA9IHRoaXMuYXR0cmlidXRlc18ubnVtQXhlcygpO1xuICB2YXIgeXBhZENvbXBhdCwgc3Bhbiwgc2VyaWVzLCB5cGFkO1xuXG4gIHZhciBwX2F4aXM7XG5cbiAgLy8gQ29tcHV0ZSBleHRyZW1lIHZhbHVlcywgYSBzcGFuIGFuZCB0aWNrIG1hcmtzIGZvciBlYWNoIGF4aXMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQXhlczsgaSsrKSB7XG4gICAgdmFyIGF4aXMgPSB0aGlzLmF4ZXNfW2ldO1xuICAgIHZhciBsb2dzY2FsZSA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImxvZ3NjYWxlXCIsIGkpO1xuICAgIHZhciBpbmNsdWRlWmVybyA9IHRoaXMuYXR0cmlidXRlc18uZ2V0Rm9yQXhpcyhcImluY2x1ZGVaZXJvXCIsIGkpO1xuICAgIHZhciBpbmRlcGVuZGVudFRpY2tzID0gdGhpcy5hdHRyaWJ1dGVzXy5nZXRGb3JBeGlzKFwiaW5kZXBlbmRlbnRUaWNrc1wiLCBpKTtcbiAgICBzZXJpZXMgPSB0aGlzLmF0dHJpYnV0ZXNfLnNlcmllc0ZvckF4aXMoaSk7XG5cbiAgICAvLyBBZGQgc29tZSBwYWRkaW5nLiBUaGlzIHN1cHBvcnRzIHR3byBZIHBhZGRpbmcgb3BlcmF0aW9uIG1vZGVzOlxuICAgIC8vXG4gICAgLy8gLSBiYWNrd2FyZHMgY29tcGF0aWJsZSAoeVJhbmdlUGFkIG5vdCBzZXQpOlxuICAgIC8vICAgMTAlIHBhZGRpbmcgZm9yIGF1dG9tYXRpYyBZIHJhbmdlcywgYnV0IG5vdCBmb3IgdXNlci1zdXBwbGllZFxuICAgIC8vICAgcmFuZ2VzLCBhbmQgbW92ZSBhIGNsb3NlLXRvLXplcm8gZWRnZSB0byB6ZXJvIGV4Y2VwdCBpZlxuICAgIC8vICAgYXZvaWRNaW5aZXJvIGlzIHNldCwgc2luY2UgZHJhd2luZyBhdCB0aGUgZWRnZSByZXN1bHRzIGluXG4gICAgLy8gICBpbnZpc2libGUgbGluZXMuIFVuZm9ydHVuYXRlbHkgbGluZXMgZHJhd24gYXQgdGhlIGVkZ2Ugb2YgYVxuICAgIC8vICAgdXNlci1zdXBwbGllZCByYW5nZSB3aWxsIHN0aWxsIGJlIGludmlzaWJsZS4gSWYgbG9nc2NhbGUgaXNcbiAgICAvLyAgIHNldCwgYWRkIGEgdmFyaWFibGUgYW1vdW50IG9mIHBhZGRpbmcgYXQgdGhlIHRvcCBidXRcbiAgICAvLyAgIG5vbmUgYXQgdGhlIGJvdHRvbS5cbiAgICAvL1xuICAgIC8vIC0gbmV3LXN0eWxlICh5UmFuZ2VQYWQgc2V0IGJ5IHRoZSB1c2VyKTpcbiAgICAvLyAgIGFsd2F5cyBhZGQgdGhlIHNwZWNpZmllZCBZIHBhZGRpbmcuXG4gICAgLy9cbiAgICB5cGFkQ29tcGF0ID0gdHJ1ZTtcbiAgICB5cGFkID0gMC4xOyAvLyBhZGQgMTAlXG4gICAgaWYgKHRoaXMuZ2V0TnVtZXJpY09wdGlvbigneVJhbmdlUGFkJykgIT09IG51bGwpIHtcbiAgICAgIHlwYWRDb21wYXQgPSBmYWxzZTtcbiAgICAgIC8vIENvbnZlcnQgcGl4ZWwgcGFkZGluZyB0byByYXRpb1xuICAgICAgeXBhZCA9IHRoaXMuZ2V0TnVtZXJpY09wdGlvbigneVJhbmdlUGFkJykgLyB0aGlzLnBsb3R0ZXJfLmFyZWEuaDtcbiAgICB9XG5cbiAgICBpZiAoc2VyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgbm8gc2VyaWVzIGFyZSBkZWZpbmVkIG9yIHZpc2libGUgdGhlbiB1c2UgYSByZWFzb25hYmxlIGRlZmF1bHRcbiAgICAgIGF4aXMuZXh0cmVtZVJhbmdlID0gWzAsIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4dHJlbWVzIG9mIGV4dHJlbWVzLlxuICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTsgIC8vIGV4dHJlbWVzW3Nlcmllc1swXV1bMF07XG4gICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTsgIC8vIGV4dHJlbWVzW3Nlcmllc1swXV1bMV07XG4gICAgICB2YXIgZXh0cmVtZU1pblksIGV4dHJlbWVNYXhZO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyB0aGlzIHNraXBzIGludmlzaWJsZSBzZXJpZXNcbiAgICAgICAgaWYgKCFleHRyZW1lcy5oYXNPd25Qcm9wZXJ0eShzZXJpZXNbal0pKSBjb250aW51ZTtcblxuICAgICAgICAvLyBPbmx5IHVzZSB2YWxpZCBleHRyZW1lcyB0byBzdG9wIG51bGwgZGF0YSBzZXJpZXMnIGZyb20gY29ycnVwdGluZyB0aGUgc2NhbGUuXG4gICAgICAgIGV4dHJlbWVNaW5ZID0gZXh0cmVtZXNbc2VyaWVzW2pdXVswXTtcbiAgICAgICAgaWYgKGV4dHJlbWVNaW5ZICE9PSBudWxsKSB7XG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGV4dHJlbWVNaW5ZLCBtaW5ZKTtcbiAgICAgICAgfVxuICAgICAgICBleHRyZW1lTWF4WSA9IGV4dHJlbWVzW3Nlcmllc1tqXV1bMV07XG4gICAgICAgIGlmIChleHRyZW1lTWF4WSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChleHRyZW1lTWF4WSwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5jbHVkZSB6ZXJvIGlmIHJlcXVlc3RlZCBieSB0aGUgdXNlci5cbiAgICAgIGlmIChpbmNsdWRlWmVybyAmJiAhbG9nc2NhbGUpIHtcbiAgICAgICAgaWYgKG1pblkgPiAwKSBtaW5ZID0gMDtcbiAgICAgICAgaWYgKG1heFkgPCAwKSBtYXhZID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCBzY2FsZSwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gWzAsIDFdIGZvciBzYWZldHkuXG4gICAgICBpZiAobWluWSA9PSBJbmZpbml0eSkgbWluWSA9IDA7XG4gICAgICBpZiAobWF4WSA9PSAtSW5maW5pdHkpIG1heFkgPSAxO1xuXG4gICAgICBzcGFuID0gbWF4WSAtIG1pblk7XG4gICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHdlIGhhdmUgbm8gc2Vuc2Ugb2Ygc2NhbGUsIGNlbnRlciBvbiB0aGUgc29sZSB2YWx1ZS5cbiAgICAgIGlmIChzcGFuID09PSAwKSB7XG4gICAgICAgIGlmIChtYXhZICE9PSAwKSB7XG4gICAgICAgICAgc3BhbiA9IE1hdGguYWJzKG1heFkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC4uLiBhbmQgaWYgdGhlIHNvbGUgdmFsdWUgaXMgemVybywgdXNlIHJhbmdlIDAtMS5cbiAgICAgICAgICBtYXhZID0gMTtcbiAgICAgICAgICBzcGFuID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4QXhpc1kgPSBtYXhZLCBtaW5BeGlzWSA9IG1pblk7XG4gICAgICBpZiAoeXBhZENvbXBhdCkge1xuICAgICAgICBpZiAobG9nc2NhbGUpIHtcbiAgICAgICAgICBtYXhBeGlzWSA9IG1heFkgKyB5cGFkICogc3BhbjtcbiAgICAgICAgICBtaW5BeGlzWSA9IG1pblk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4QXhpc1kgPSBtYXhZICsgeXBhZCAqIHNwYW47XG4gICAgICAgICAgbWluQXhpc1kgPSBtaW5ZIC0geXBhZCAqIHNwYW47XG5cbiAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBiZWhhdmlvcjogTW92ZSB0aGUgc3BhbiB0byBzdGFydCBvciBlbmQgYXQgemVybyBpZiBpdCdzXG4gICAgICAgICAgLy8gY2xvc2UgdG8gemVybywgYnV0IG5vdCBpZiBhdm9pZE1pblplcm8gaXMgc2V0LlxuICAgICAgICAgIGlmICghdGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiYXZvaWRNaW5aZXJvXCIpKSB7XG4gICAgICAgICAgICBpZiAobWluQXhpc1kgPCAwICYmIG1pblkgPj0gMCkgbWluQXhpc1kgPSAwO1xuICAgICAgICAgICAgaWYgKG1heEF4aXNZID4gMCAmJiBtYXhZIDw9IDApIG1heEF4aXNZID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF4aXMuZXh0cmVtZVJhbmdlID0gW21pbkF4aXNZLCBtYXhBeGlzWV07XG4gICAgfVxuICAgIGlmIChheGlzLnZhbHVlV2luZG93KSB7XG4gICAgICAvLyBUaGlzIGlzIG9ubHkgc2V0IGlmIHRoZSB1c2VyIGhhcyB6b29tZWQgb24gdGhlIHktYXhpcy4gSXQgaXMgbmV2ZXIgc2V0XG4gICAgICAvLyBieSBhIHVzZXIuIEl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBheGlzLnZhbHVlUmFuZ2UgYmVjYXVzZSwgaWYgeW91IHNldFxuICAgICAgLy8gdmFsdWVSYW5nZSwgeW91J2Qgc3RpbGwgZXhwZWN0IHRvIGJlIGFibGUgdG8gcGFuLlxuICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2UgPSBbYXhpcy52YWx1ZVdpbmRvd1swXSwgYXhpcy52YWx1ZVdpbmRvd1sxXV07XG4gICAgfSBlbHNlIGlmIChheGlzLnZhbHVlUmFuZ2UpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB1c2VyLXNldCB2YWx1ZSByYW5nZSBmb3IgdGhpcyBheGlzLlxuICAgICAgdmFyIHkwID0gaXNOdWxsVW5kZWZpbmVkT3JOYU4oYXhpcy52YWx1ZVJhbmdlWzBdKSA/IGF4aXMuZXh0cmVtZVJhbmdlWzBdIDogYXhpcy52YWx1ZVJhbmdlWzBdO1xuICAgICAgdmFyIHkxID0gaXNOdWxsVW5kZWZpbmVkT3JOYU4oYXhpcy52YWx1ZVJhbmdlWzFdKSA/IGF4aXMuZXh0cmVtZVJhbmdlWzFdIDogYXhpcy52YWx1ZVJhbmdlWzFdO1xuICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2UgPSBbeTAsIHkxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2UgPSBheGlzLmV4dHJlbWVSYW5nZTtcbiAgICB9XG4gICAgaWYgKCFheGlzLnZhbHVlV2luZG93ICYmICF5cGFkQ29tcGF0KSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIHlSYW5nZVBhZCwgYWRqdXN0IHRoZSB1cHBlci9sb3dlciBib3VuZHMgdG8gYWRkXG4gICAgICAvLyBwYWRkaW5nIHVubGVzcyB0aGUgdXNlciBoYXMgem9vbWVkL3Bhbm5lZCB0aGUgWSBheGlzIHJhbmdlLlxuICAgICAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgICAgIHkwID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICAgIHkxID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV07XG4gICAgICAgIHZhciB5MHBjdCA9IHlwYWQgLyAoMiAqIHlwYWQgLSAxKTtcbiAgICAgICAgdmFyIHkxcGN0ID0gKHlwYWQgLSAxKSAvICgyICogeXBhZCAtIDEpO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSA9IHV0aWxzLmxvZ1JhbmdlRnJhY3Rpb24oeTAsIHkxLCB5MHBjdCk7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdID0gdXRpbHMubG9nUmFuZ2VGcmFjdGlvbih5MCwgeTEsIHkxcGN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkwID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICAgIHkxID0gYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV07XG4gICAgICAgIHNwYW4gPSB5MSAtIHkwO1xuICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSA9IHkwIC0gc3BhbiAqIHlwYWQ7XG4gICAgICAgIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzFdID0geTEgKyBzcGFuICogeXBhZDtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmIChpbmRlcGVuZGVudFRpY2tzKSB7XG4gICAgICBheGlzLmluZGVwZW5kZW50VGlja3MgPSBpbmRlcGVuZGVudFRpY2tzO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnNWaWV3Rm9yQXhpc18oJ3knICsgKGkgPyAnMicgOiAnJykpO1xuICAgICAgdmFyIHRpY2tlciA9IG9wdHMoJ3RpY2tlcicpO1xuICAgICAgYXhpcy50aWNrcyA9IHRpY2tlcihheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVswXSxcbiAgICAgICAgICAgICAgYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMV0sXG4gICAgICAgICAgICAgIHRoaXMucGxvdHRlcl8uYXJlYS5oLFxuICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICB0aGlzKTtcbiAgICAgIC8vIERlZmluZSB0aGUgZmlyc3QgaW5kZXBlbmRlbnQgYXhpcyBhcyBwcmltYXJ5IGF4aXMuXG4gICAgICBpZiAoIXBfYXhpcykgcF9heGlzID0gYXhpcztcbiAgICB9XG4gIH1cbiAgaWYgKHBfYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgKFwiQ29uZmlndXJhdGlvbiBFcnJvcjogQXQgbGVhc3Qgb25lIGF4aXMgaGFzIHRvIGhhdmUgdGhlIFxcXCJpbmRlcGVuZGVudFRpY2tzXFxcIiBvcHRpb24gYWN0aXZhdGVkLlwiKTtcbiAgfVxuICAvLyBBZGQgdGlja3MuIEJ5IGRlZmF1bHQsIGFsbCBheGVzIGluaGVyaXQgdGhlIHRpY2sgcG9zaXRpb25zIG9mIHRoZVxuICAvLyBwcmltYXJ5IGF4aXMuIEhvd2V2ZXIsIGlmIGFuIGF4aXMgaXMgc3BlY2lmaWNhbGx5IG1hcmtlZCBhcyBoYXZpbmdcbiAgLy8gaW5kZXBlbmRlbnQgdGlja3MsIHRoZW4gdGhhdCBpcyBwZXJtaXNzaWJsZSBhcyB3ZWxsLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUF4ZXM7IGkrKykge1xuICAgIHZhciBheGlzID0gdGhpcy5heGVzX1tpXTtcblxuICAgIGlmICghYXhpcy5pbmRlcGVuZGVudFRpY2tzKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9uc1ZpZXdGb3JBeGlzXygneScgKyAoaSA/ICcyJyA6ICcnKSk7XG4gICAgICB2YXIgdGlja2VyID0gb3B0cygndGlja2VyJyk7XG4gICAgICB2YXIgcF90aWNrcyA9IHBfYXhpcy50aWNrcztcbiAgICAgIHZhciBwX3NjYWxlID0gcF9heGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSAtIHBfYXhpcy5jb21wdXRlZFZhbHVlUmFuZ2VbMF07XG4gICAgICB2YXIgc2NhbGUgPSBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSAtIGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdO1xuICAgICAgdmFyIHRpY2tfdmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBfdGlja3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHlfZnJhYyA9IChwX3RpY2tzW2tdLnYgLSBwX2F4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdKSAvIHBfc2NhbGU7XG4gICAgICAgIHZhciB5X3ZhbCA9IGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdICsgeV9mcmFjICogc2NhbGU7XG4gICAgICAgIHRpY2tfdmFsdWVzLnB1c2goeV92YWwpO1xuICAgICAgfVxuXG4gICAgICBheGlzLnRpY2tzID0gdGlja2VyKGF4aXMuY29tcHV0ZWRWYWx1ZVJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLmNvbXB1dGVkVmFsdWVSYW5nZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbG90dGVyXy5hcmVhLmgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tfdmFsdWVzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGV0ZWN0cyB0aGUgdHlwZSBvZiB0aGUgc3RyIChkYXRlIG9yIG51bWVyaWMpIGFuZCBzZXRzIHRoZSB2YXJpb3VzXG4gKiBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhpcy5hdHRyc18gYmFzZWQgb24gdGhpcyB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBbiB4IHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZGV0ZWN0VHlwZUZyb21TdHJpbmdfID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBpc0RhdGUgPSBmYWxzZTtcbiAgdmFyIGRhc2hQb3MgPSBzdHIuaW5kZXhPZignLScpOyAgLy8gY291bGQgYmUgMjAwNi0wMS0wMSBfb3JfIDEuMGUtMlxuICBpZiAoKGRhc2hQb3MgPiAwICYmIChzdHJbZGFzaFBvcy0xXSAhPSAnZScgJiYgc3RyW2Rhc2hQb3MtMV0gIT0gJ0UnKSkgfHxcbiAgICAgIHN0ci5pbmRleE9mKCcvJykgPj0gMCB8fFxuICAgICAgaXNOYU4ocGFyc2VGbG9hdChzdHIpKSkge1xuICAgIGlzRGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PSA4ICYmIHN0ciA+ICcxOTcwMDEwMScgJiYgc3RyIDwgJzIwMzcxMjMxJykge1xuICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmUgc3VwcG9ydCBmb3IgdGhpcyBmb3JtYXQuXG4gICAgaXNEYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuc2V0WEF4aXNPcHRpb25zXyhpc0RhdGUpO1xufTtcblxuRHlncmFwaC5wcm90b3R5cGUuc2V0WEF4aXNPcHRpb25zXyA9IGZ1bmN0aW9uKGlzRGF0ZSkge1xuICBpZiAoaXNEYXRlKSB7XG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gdXRpbHMuZGF0ZVBhcnNlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG4gIH0gZWxzZSB7XG4gICAgLyoqIEBwcml2YXRlIChzaHV0IHVwLCBqc2RvYyEpICovXG4gICAgdGhpcy5hdHRyc18ueFZhbHVlUGFyc2VyID0gZnVuY3Rpb24oeCkgeyByZXR1cm4gcGFyc2VGbG9hdCh4KTsgfTtcbiAgICAvLyBUT0RPKGRhbnZrKTogdXNlIER5Z3JhcGgubnVtYmVyVmFsdWVGb3JtYXR0ZXIgaGVyZT9cbiAgICAvKiogQHByaXZhdGUgKHNodXQgdXAsIGpzZG9jISkgKi9cbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC50aWNrZXIgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljVGlja3M7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlcjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGFyc2VzIGEgc3RyaW5nIGluIGEgc3BlY2lhbCBjc3YgZm9ybWF0LiAgV2UgZXhwZWN0IGEgY3N2IGZpbGUgd2hlcmUgZWFjaFxuICogbGluZSBpcyBhIGRhdGUgcG9pbnQsIGFuZCB0aGUgZmlyc3QgZmllbGQgaW4gZWFjaCBsaW5lIGlzIHRoZSBkYXRlIHN0cmluZy5cbiAqIFdlIGFsc28gZXhwZWN0IHRoYXQgYWxsIHJlbWFpbmluZyBmaWVsZHMgcmVwcmVzZW50IHNlcmllcy5cbiAqIGlmIHRoZSBlcnJvckJhcnMgYXR0cmlidXRlIGlzIHNldCwgdGhlbiBpbnRlcnByZXQgdGhlIGZpZWxkcyBhczpcbiAqIGRhdGUsIHNlcmllczEsIHN0ZGRldjEsIHNlcmllczIsIHN0ZGRldjIsIC4uLlxuICogQHBhcmFtIHtbT2JqZWN0XX0gZGF0YSBTZWUgYWJvdmUuXG4gKlxuICogQHJldHVybiBbT2JqZWN0XSBBbiBhcnJheSB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByb3cuIFRoZXNlIGVudHJpZXNcbiAqIGFyZSBhbiBhcnJheSBvZiBjZWxscyBpbiB0aGF0IHJvdy4gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBwYXJzZWQgeC12YWx1ZSBmb3JcbiAqIHRoZSByb3cuIFRoZSBzZWNvbmQsIHRoaXJkLCBldGMuIGFyZSB0aGUgeS12YWx1ZXMuIFRoZXNlIGNhbiB0YWtlIG9uIG9uZSBvZlxuICogdGhyZWUgZm9ybXMsIGRlcGVuZGluZyBvbiB0aGUgQ1NWIGFuZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzOlxuICogMS4gbnVtZXJpYyB2YWx1ZVxuICogMi4gWyB2YWx1ZSwgc3RkZGV2IF1cbiAqIDMuIFsgbG93IHZhbHVlLCBjZW50ZXIgdmFsdWUsIGhpZ2ggdmFsdWUgXVxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5wYXJzZUNTVl8gPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGxpbmVfZGVsaW1pdGVyID0gdXRpbHMuZGV0ZWN0TGluZURlbGltaXRlcihkYXRhKTtcbiAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdChsaW5lX2RlbGltaXRlciB8fCBcIlxcblwiKTtcbiAgdmFyIHZhbHMsIGo7XG5cbiAgLy8gVXNlIHRoZSBkZWZhdWx0IGRlbGltaXRlciBvciBmYWxsIGJhY2sgdG8gYSB0YWIgaWYgdGhhdCBtYWtlcyBzZW5zZS5cbiAgdmFyIGRlbGltID0gdGhpcy5nZXRTdHJpbmdPcHRpb24oJ2RlbGltaXRlcicpO1xuICBpZiAobGluZXNbMF0uaW5kZXhPZihkZWxpbSkgPT0gLTEgJiYgbGluZXNbMF0uaW5kZXhPZignXFx0JykgPj0gMCkge1xuICAgIGRlbGltID0gJ1xcdCc7XG4gIH1cblxuICB2YXIgc3RhcnQgPSAwO1xuICBpZiAoISgnbGFiZWxzJyBpbiB0aGlzLnVzZXJfYXR0cnNfKSkge1xuICAgIC8vIFVzZXIgaGFzbid0IGV4cGxpY2l0bHkgc2V0IGxhYmVscywgc28gdGhleSdyZSAocHJlc3VtYWJseSkgaW4gdGhlIENTVi5cbiAgICBzdGFydCA9IDE7XG4gICAgdGhpcy5hdHRyc18ubGFiZWxzID0gbGluZXNbMF0uc3BsaXQoZGVsaW0pOyAgLy8gTk9URTogX25vdF8gdXNlcl9hdHRyc18uXG4gICAgdGhpcy5hdHRyaWJ1dGVzXy5yZXBhcnNlU2VyaWVzKCk7XG4gIH1cbiAgdmFyIGxpbmVfbm8gPSAwO1xuXG4gIHZhciB4UGFyc2VyO1xuICB2YXIgZGVmYXVsdFBhcnNlclNldCA9IGZhbHNlOyAgLy8gYXR0ZW1wdCB0byBhdXRvLWRldGVjdCB4IHZhbHVlIHR5cGVcbiAgdmFyIGV4cGVjdGVkQ29scyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIikubGVuZ3RoO1xuICB2YXIgb3V0T2ZPcmRlciA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgbGluZV9ubyA9IGk7XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSBjb250aW51ZTsgIC8vIHNraXAgYmxhbmsgbGluZXNcbiAgICBpZiAobGluZVswXSA9PSAnIycpIGNvbnRpbnVlOyAgICAvLyBza2lwIGNvbW1lbnQgbGluZXNcbiAgICB2YXIgaW5GaWVsZHMgPSBsaW5lLnNwbGl0KGRlbGltKTtcbiAgICBpZiAoaW5GaWVsZHMubGVuZ3RoIDwgMikgY29udGludWU7XG5cbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgaWYgKCFkZWZhdWx0UGFyc2VyU2V0KSB7XG4gICAgICB0aGlzLmRldGVjdFR5cGVGcm9tU3RyaW5nXyhpbkZpZWxkc1swXSk7XG4gICAgICB4UGFyc2VyID0gdGhpcy5nZXRGdW5jdGlvbk9wdGlvbihcInhWYWx1ZVBhcnNlclwiKTtcbiAgICAgIGRlZmF1bHRQYXJzZXJTZXQgPSB0cnVlO1xuICAgIH1cbiAgICBmaWVsZHNbMF0gPSB4UGFyc2VyKGluRmllbGRzWzBdLCB0aGlzKTtcblxuICAgIC8vIElmIGZyYWN0aW9ucyBhcmUgZXhwZWN0ZWQsIHBhcnNlIHRoZSBudW1iZXJzIGFzIFwiQS9CXCJcbiAgICBpZiAodGhpcy5mcmFjdGlvbnNfKSB7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgLy8gVE9ETyhkYW52ayk6IGZpZ3VyZSBvdXQgYW4gYXBwcm9wcmlhdGUgd2F5IHRvIGZsYWcgcGFyc2UgZXJyb3JzLlxuICAgICAgICB2YWxzID0gaW5GaWVsZHNbal0uc3BsaXQoXCIvXCIpO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggIT0gMikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4cGVjdGVkIGZyYWN0aW9uYWwgXCJudW0vZGVuXCIgdmFsdWVzIGluIENTViBkYXRhICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJidXQgZm91bmQgYSB2YWx1ZSAnXCIgKyBpbkZpZWxkc1tqXSArIFwiJyBvbiBsaW5lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgxICsgaSkgKyBcIiAoJ1wiICsgbGluZSArIFwiJykgd2hpY2ggaXMgbm90IG9mIHRoaXMgZm9ybS5cIik7XG4gICAgICAgICAgZmllbGRzW2pdID0gWzAsIDBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tqXSA9IFt1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzBdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8odmFsc1sxXSwgaSwgbGluZSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJlcnJvckJhcnNcIikpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvciBiYXJzLCB2YWx1ZXMgYXJlICh2YWx1ZSwgc3RkZGV2KSBwYWlyc1xuICAgICAgaWYgKGluRmllbGRzLmxlbmd0aCAlIDIgIT0gMSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeHBlY3RlZCBhbHRlcm5hdGluZyAodmFsdWUsIHN0ZGV2LikgcGFpcnMgaW4gQ1NWIGRhdGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2J1dCBsaW5lICcgKyAoMSArIGkpICsgJyBoYXMgYW4gb2RkIG51bWJlciBvZiB2YWx1ZXMgKCcgK1xuICAgICAgICAgICAgICAgICAgICAgIChpbkZpZWxkcy5sZW5ndGggLSAxKSArIFwiKTogJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDE7IGogPCBpbkZpZWxkcy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICBmaWVsZHNbKGogKyAxKSAvIDJdID0gW3V0aWxzLnBhcnNlRmxvYXRfKGluRmllbGRzW2pdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wYXJzZUZsb2F0XyhpbkZpZWxkc1tqICsgMV0sIGksIGxpbmUpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0Qm9vbGVhbk9wdGlvbihcImN1c3RvbUJhcnNcIikpIHtcbiAgICAgIC8vIEJhcnMgYXJlIGEgbG93O2NlbnRlcjtoaWdoIHR1cGxlXG4gICAgICBmb3IgKGogPSAxOyBqIDwgaW5GaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHZhbCA9IGluRmllbGRzW2pdO1xuICAgICAgICBpZiAoL14gKiQvLnRlc3QodmFsKSkge1xuICAgICAgICAgIGZpZWxkc1tqXSA9IFtudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxzID0gdmFsLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZmllbGRzW2pdID0gWyB1dGlscy5wYXJzZUZsb2F0Xyh2YWxzWzBdLCBpLCBsaW5lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VGbG9hdF8odmFsc1sxXSwgaSwgbGluZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBhcnNlRmxvYXRfKHZhbHNbMl0sIGksIGxpbmUpIF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2hlbiB1c2luZyBjdXN0b21CYXJzLCB2YWx1ZXMgbXVzdCBiZSBlaXRoZXIgYmxhbmsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ29yIFwibG93O2NlbnRlcjtoaWdoXCIgdHVwbGVzIChnb3QgXCInICsgdmFsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgb24gbGluZSAnICsgKDEraSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWx1ZXMgYXJlIGp1c3QgbnVtYmVyc1xuICAgICAgZm9yIChqID0gMTsgaiA8IGluRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGZpZWxkc1tqXSA9IHV0aWxzLnBhcnNlRmxvYXRfKGluRmllbGRzW2pdLCBpLCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldC5sZW5ndGggPiAwICYmIGZpZWxkc1swXSA8IHJldFtyZXQubGVuZ3RoIC0gMV1bMF0pIHtcbiAgICAgIG91dE9mT3JkZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmaWVsZHMubGVuZ3RoICE9IGV4cGVjdGVkQ29scykge1xuICAgICAgY29uc29sZS5lcnJvcihcIk51bWJlciBvZiBjb2x1bW5zIGluIGxpbmUgXCIgKyBpICsgXCIgKFwiICsgZmllbGRzLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBkb2VzIG5vdCBhZ3JlZSB3aXRoIG51bWJlciBvZiBsYWJlbHMgKFwiICsgZXhwZWN0ZWRDb2xzICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIFwiICsgbGluZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIHRoZSAnbGFiZWxzJyBvcHRpb24gYW5kIG5vbmUgb2YgdGhlIGNlbGxzIG9mIHRoZVxuICAgIC8vIGZpcnN0IHJvdyBwYXJzZWQgY29ycmVjdGx5LCB0aGVuIHRoZXkgcHJvYmFibHkgZG91YmxlLXNwZWNpZmllZCB0aGVcbiAgICAvLyBsYWJlbHMuIFdlIGdvIHdpdGggdGhlIHZhbHVlcyBzZXQgaW4gdGhlIG9wdGlvbiwgZGlzY2FyZCB0aGlzIHJvdyBhbmRcbiAgICAvLyBsb2cgYSB3YXJuaW5nIHRvIHRoZSBKUyBjb25zb2xlLlxuICAgIGlmIChpID09PSAwICYmIHRoaXMuYXR0cl8oJ2xhYmVscycpKSB7XG4gICAgICB2YXIgYWxsX251bGwgPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgYWxsX251bGwgJiYgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoZmllbGRzW2pdKSBhbGxfbnVsbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGFsbF9udWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBkeWdyYXBocyAnbGFiZWxzJyBvcHRpb24gaXMgc2V0LCBidXQgdGhlIGZpcnN0IHJvdyBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcIm9mIENTViBkYXRhICgnXCIgKyBsaW5lICsgXCInKSBhcHBlYXJzIHRvIGFsc28gY29udGFpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcImxhYmVscy4gV2lsbCBkcm9wIHRoZSBDU1YgbGFiZWxzIGFuZCB1c2UgdGhlIG9wdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICBcImxhYmVscy5cIik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXQucHVzaChmaWVsZHMpO1xuICB9XG5cbiAgaWYgKG91dE9mT3JkZXIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJDU1YgaXMgb3V0IG9mIG9yZGVyOyBvcmRlciBpdCBjb3JyZWN0bHkgdG8gc3BlZWQgbG9hZGluZy5cIik7XG4gICAgcmV0LnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBUaGUgdXNlciBoYXMgcHJvdmlkZWQgdGhlaXIgZGF0YSBhcyBhIHByZS1wYWNrYWdlZCBKUyBhcnJheS4gSWYgdGhlIHggdmFsdWVzXG4gKiBhcmUgbnVtZXJpYywgdGhpcyBpcyB0aGUgc2FtZSBhcyBkeWdyYXBocycgaW50ZXJuYWwgZm9ybWF0LiBJZiB0aGUgeCB2YWx1ZXNcbiAqIGFyZSBkYXRlcywgd2UgbmVlZCB0byBjb252ZXJ0IHRoZW0gZnJvbSBEYXRlIG9iamVjdHMgdG8gbXMgc2luY2UgZXBvY2guXG4gKiBAcGFyYW0geyFBcnJheX0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fSBkYXRhIHdpdGggbnVtZXJpYyB4IHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnBhcnNlQXJyYXlfID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyBQZWVrIGF0IHRoZSBmaXJzdCB4IHZhbHVlIHRvIHNlZSBpZiBpdCdzIG51bWVyaWMuXG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDYW4ndCBwbG90IGVtcHR5IGRhdGEgc2V0XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChkYXRhWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJEYXRhIHNldCBjYW5ub3QgY29udGFpbiBhbiBlbXB0eSByb3dcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuYXR0cl8oXCJsYWJlbHNcIikgPT09IG51bGwpIHtcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IGxhYmVscy4gU2V0IGxhYmVscyBleHBsaWNpdGx5IHZpYSAnbGFiZWxzJyBcIiArXG4gICAgICAgICAgICAgICAgIFwiaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyXCIpO1xuICAgIHRoaXMuYXR0cnNfLmxhYmVscyA9IFsgXCJYXCIgXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgZGF0YVswXS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hdHRyc18ubGFiZWxzLnB1c2goXCJZXCIgKyBpKTsgLy8gTm90IHVzZXJfYXR0cnNfLlxuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZXNfLnJlcGFyc2VTZXJpZXMoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnVtX2xhYmVscyA9IHRoaXMuYXR0cl8oXCJsYWJlbHNcIik7XG4gICAgaWYgKG51bV9sYWJlbHMubGVuZ3RoICE9IGRhdGFbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzbWF0Y2ggYmV0d2VlbiBudW1iZXIgb2YgbGFiZWxzIChcIiArIG51bV9sYWJlbHMgKyBcIilcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIGFuZCBudW1iZXIgb2YgY29sdW1ucyBpbiBhcnJheSAoXCIgKyBkYXRhWzBdLmxlbmd0aCArIFwiKVwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1dGlscy5pc0RhdGVMaWtlKGRhdGFbMF1bMF0pKSB7XG4gICAgLy8gU29tZSBpbnRlbGxpZ2VudCBkZWZhdWx0cyBmb3IgYSBkYXRlIHgtYXhpcy5cbiAgICB0aGlzLmF0dHJzXy5heGVzLngudmFsdWVGb3JtYXR0ZXIgPSB1dGlscy5kYXRlVmFsdWVGb3JtYXR0ZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LmF4aXNMYWJlbEZvcm1hdHRlciA9IHV0aWxzLmRhdGVBeGlzTGFiZWxGb3JtYXR0ZXI7XG5cbiAgICAvLyBBc3N1bWUgdGhleSdyZSBhbGwgZGF0ZXMuXG4gICAgdmFyIHBhcnNlZERhdGEgPSB1dGlscy5jbG9uZShkYXRhKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcnNlZERhdGFbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSb3cgXCIgKyAoMSArIGkpICsgXCIgb2YgZGF0YSBpcyBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkRGF0YVtpXVswXSA9PT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZihwYXJzZWREYXRhW2ldWzBdLmdldFRpbWUpICE9ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICBpc05hTihwYXJzZWREYXRhW2ldWzBdLmdldFRpbWUoKSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcInggdmFsdWUgaW4gcm93IFwiICsgKDEgKyBpKSArIFwiIGlzIG5vdCBhIERhdGVcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcGFyc2VkRGF0YVtpXVswXSA9IHBhcnNlZERhdGFbaV1bMF0uZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTb21lIGludGVsbGlnZW50IGRlZmF1bHRzIGZvciBhIG51bWVyaWMgeC1heGlzLlxuICAgIC8qKiBAcHJpdmF0ZSAoc2h1dCB1cCwganNkb2MhKSAqL1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMubnVtYmVyQXhpc0xhYmVsRm9ybWF0dGVyO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIERhdGFUYWJsZSBvYmplY3QgZnJvbSBndml6LlxuICogVGhlIGRhdGEgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGZpcnN0IGNvbHVtbiB0aGF0IGlzIGVpdGhlciBhIGRhdGUgb3IgYVxuICogbnVtYmVyLiBBbGwgc3Vic2VxdWVudCBjb2x1bW5zIG11c3QgYmUgbnVtYmVycy4gSWYgdGhlcmUgaXMgYSBjbGVhciBtaXNtYXRjaFxuICogYmV0d2VlbiB0aGlzLnhWYWx1ZVBhcnNlcl8gYW5kIHRoZSB0eXBlIG9mIHRoZSBmaXJzdCBjb2x1bW4sIGl0IHdpbGwgYmVcbiAqIGZpeGVkLiBGaWxscyBvdXQgcmF3RGF0YV8uXG4gKiBAcGFyYW0geyFnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGV9IGRhdGEgU2VlIGFib3ZlLlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucGFyc2VEYXRhVGFibGVfID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgc2hvcnRUZXh0Rm9yQW5ub3RhdGlvbk51bSA9IGZ1bmN0aW9uKG51bSkge1xuICAgIC8vIGNvbnZlcnRzIFswLTldKyBbQS1aXVthLXpdKlxuICAgIC8vIGV4YW1wbGU6IDA9QSwgMT1CLCAyNT1aLCAyNj1BYSwgMjc9QWJcbiAgICAvLyBhbmQgY29udGludWVzIGxpa2UuLiBCYSBCYiAuLiBaYSAuLiBaei4uQWFhLi4uWnp6IEFhYWEgWnp6elxuICAgIHZhciBzaG9ydFRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIEEgKi8gKyBudW0gJSAyNik7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyAyNik7XG4gICAgd2hpbGUgKCBudW0gPiAwICkge1xuICAgICAgc2hvcnRUZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSAvKiBBICovICsgKG51bSAtIDEpICUgMjYgKSArIHNob3J0VGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgbnVtID0gTWF0aC5mbG9vcigobnVtIC0gMSkgLyAyNik7XG4gICAgfVxuICAgIHJldHVybiBzaG9ydFRleHQ7XG4gIH07XG5cbiAgdmFyIGNvbHMgPSBkYXRhLmdldE51bWJlck9mQ29sdW1ucygpO1xuICB2YXIgcm93cyA9IGRhdGEuZ2V0TnVtYmVyT2ZSb3dzKCk7XG5cbiAgdmFyIGluZGVwVHlwZSA9IGRhdGEuZ2V0Q29sdW1uVHlwZSgwKTtcbiAgaWYgKGluZGVwVHlwZSA9PSAnZGF0ZScgfHwgaW5kZXBUeXBlID09ICdkYXRldGltZScpIHtcbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSB1dGlscy5kYXRlUGFyc2VyO1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IHV0aWxzLmRhdGVWYWx1ZUZvcm1hdHRlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLngudGlja2VyID0gRHlncmFwaFRpY2tlcnMuZGF0ZVRpY2tlcjtcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcbiAgfSBlbHNlIGlmIChpbmRlcFR5cGUgPT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmF0dHJzXy54VmFsdWVQYXJzZXIgPSBmdW5jdGlvbih4KSB7IHJldHVybiBwYXJzZUZsb2F0KHgpOyB9O1xuICAgIHRoaXMuYXR0cnNfLmF4ZXMueC52YWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG4gICAgdGhpcy5hdHRyc18uYXhlcy54LnRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbiAgICB0aGlzLmF0dHJzXy5heGVzLnguYXhpc0xhYmVsRm9ybWF0dGVyID0gdGhpcy5hdHRyc18uYXhlcy54LnZhbHVlRm9ybWF0dGVyO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIm9ubHkgJ2RhdGUnLCAnZGF0ZXRpbWUnIGFuZCAnbnVtYmVyJyB0eXBlcyBhcmUgc3VwcG9ydGVkIFwiICtcbiAgICAgICAgICBcImZvciBjb2x1bW4gMSBvZiBEYXRhVGFibGUgaW5wdXQgKEdvdCAnXCIgKyBpbmRlcFR5cGUgKyBcIicpXCIpO1xuICB9XG5cbiAgLy8gQXJyYXkgb2YgdGhlIGNvbHVtbiBpbmRpY2VzIHdoaWNoIGNvbnRhaW4gZGF0YSAoYW5kIG5vdCBhbm5vdGF0aW9ucykuXG4gIHZhciBjb2xJZHggPSBbXTtcbiAgdmFyIGFubm90YXRpb25Db2xzID0ge307ICAvLyBkYXRhIGluZGV4IC0+IFthbm5vdGF0aW9uIGNvbHNdXG4gIHZhciBoYXNBbm5vdGF0aW9ucyA9IGZhbHNlO1xuICB2YXIgaSwgajtcbiAgZm9yIChpID0gMTsgaSA8IGNvbHM7IGkrKykge1xuICAgIHZhciB0eXBlID0gZGF0YS5nZXRDb2x1bW5UeXBlKGkpO1xuICAgIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgICBjb2xJZHgucHVzaChpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycgJiYgdGhpcy5nZXRCb29sZWFuT3B0aW9uKCdkaXNwbGF5QW5ub3RhdGlvbnMnKSkge1xuICAgICAgLy8gVGhpcyBpcyBPSyAtLSBpdCdzIGFuIGFubm90YXRpb24gY29sdW1uLlxuICAgICAgdmFyIGRhdGFJZHggPSBjb2xJZHhbY29sSWR4Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFhbm5vdGF0aW9uQ29scy5oYXNPd25Qcm9wZXJ0eShkYXRhSWR4KSkge1xuICAgICAgICBhbm5vdGF0aW9uQ29sc1tkYXRhSWR4XSA9IFtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFubm90YXRpb25Db2xzW2RhdGFJZHhdLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBoYXNBbm5vdGF0aW9ucyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIk9ubHkgJ251bWJlcicgaXMgc3VwcG9ydGVkIGFzIGEgZGVwZW5kZW50IHR5cGUgd2l0aCBHdml6LlwiICtcbiAgICAgICAgICBcIiAnc3RyaW5nJyBpcyBvbmx5IHN1cHBvcnRlZCBpZiBkaXNwbGF5QW5ub3RhdGlvbnMgaXMgdHJ1ZVwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFkIGNvbHVtbiBsYWJlbHNcbiAgLy8gVE9ETyhkYW52ayk6IGFkZCBzdXBwb3J0IGJhY2sgZm9yIGVycm9yQmFyc1xuICB2YXIgbGFiZWxzID0gW2RhdGEuZ2V0Q29sdW1uTGFiZWwoMCldO1xuICBmb3IgKGkgPSAwOyBpIDwgY29sSWR4Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWxzLnB1c2goZGF0YS5nZXRDb2x1bW5MYWJlbChjb2xJZHhbaV0pKTtcbiAgICBpZiAodGhpcy5nZXRCb29sZWFuT3B0aW9uKFwiZXJyb3JCYXJzXCIpKSBpICs9IDE7XG4gIH1cbiAgdGhpcy5hdHRyc18ubGFiZWxzID0gbGFiZWxzO1xuICBjb2xzID0gbGFiZWxzLmxlbmd0aDtcblxuICB2YXIgcmV0ID0gW107XG4gIHZhciBvdXRPZk9yZGVyID0gZmFsc2U7XG4gIHZhciBhbm5vdGF0aW9ucyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIGlmICh0eXBlb2YoZGF0YS5nZXRWYWx1ZShpLCAwKSkgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGRhdGEuZ2V0VmFsdWUoaSwgMCkgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIklnbm9yaW5nIHJvdyBcIiArIGkgK1xuICAgICAgICAgICAgICAgICAgIFwiIG9mIERhdGFUYWJsZSBiZWNhdXNlIG9mIHVuZGVmaW5lZCBvciBudWxsIGZpcnN0IGNvbHVtbi5cIik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXBUeXBlID09ICdkYXRlJyB8fCBpbmRlcFR5cGUgPT0gJ2RhdGV0aW1lJykge1xuICAgICAgcm93LnB1c2goZGF0YS5nZXRWYWx1ZShpLCAwKS5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3cucHVzaChkYXRhLmdldFZhbHVlKGksIDApKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmdldEJvb2xlYW5PcHRpb24oXCJlcnJvckJhcnNcIikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb2xJZHgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNvbCA9IGNvbElkeFtqXTtcbiAgICAgICAgcm93LnB1c2goZGF0YS5nZXRWYWx1ZShpLCBjb2wpKTtcbiAgICAgICAgaWYgKGhhc0Fubm90YXRpb25zICYmXG4gICAgICAgICAgICBhbm5vdGF0aW9uQ29scy5oYXNPd25Qcm9wZXJ0eShjb2wpICYmXG4gICAgICAgICAgICBkYXRhLmdldFZhbHVlKGksIGFubm90YXRpb25Db2xzW2NvbF1bMF0pICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGFubiA9IHt9O1xuICAgICAgICAgIGFubi5zZXJpZXMgPSBkYXRhLmdldENvbHVtbkxhYmVsKGNvbCk7XG4gICAgICAgICAgYW5uLnh2YWwgPSByb3dbMF07XG4gICAgICAgICAgYW5uLnNob3J0VGV4dCA9IHNob3J0VGV4dEZvckFubm90YXRpb25OdW0oYW5ub3RhdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICBhbm4udGV4dCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYW5ub3RhdGlvbkNvbHNbY29sXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGspIGFubi50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBhbm4udGV4dCArPSBkYXRhLmdldFZhbHVlKGksIGFubm90YXRpb25Db2xzW2NvbF1ba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3RyaXAgb3V0IGluZmluaXRpZXMsIHdoaWNoIGdpdmUgZHlncmFwaHMgcHJvYmxlbXMgbGF0ZXIgb24uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUocm93W2pdKSkgcm93W2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvbHMgLSAxOyBqKyspIHtcbiAgICAgICAgcm93LnB1c2goWyBkYXRhLmdldFZhbHVlKGksIDEgKyAyICogaiksIGRhdGEuZ2V0VmFsdWUoaSwgMiArIDIgKiBqKSBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldC5sZW5ndGggPiAwICYmIHJvd1swXSA8IHJldFtyZXQubGVuZ3RoIC0gMV1bMF0pIHtcbiAgICAgIG91dE9mT3JkZXIgPSB0cnVlO1xuICAgIH1cbiAgICByZXQucHVzaChyb3cpO1xuICB9XG5cbiAgaWYgKG91dE9mT3JkZXIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJEYXRhVGFibGUgaXMgb3V0IG9mIG9yZGVyOyBvcmRlciBpdCBjb3JyZWN0bHkgdG8gc3BlZWQgbG9hZGluZy5cIik7XG4gICAgcmV0LnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gIH1cbiAgdGhpcy5yYXdEYXRhXyA9IHJldDtcblxuICBpZiAoYW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuc2V0QW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMsIHRydWUpO1xuICB9XG4gIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xufTtcblxuLyoqXG4gKiBTaWduYWxzIHRvIHBsdWdpbnMgdGhhdCB0aGUgY2hhcnQgZGF0YSBoYXMgdXBkYXRlZC5cbiAqIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZGF0YSBoYXMgdXBkYXRlZCBidXQgYmVmb3JlIHRoZSBjaGFydCBoYXMgcmVkcmF3bi5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuY2FzY2FkZURhdGFEaWRVcGRhdGVFdmVudF8gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETyhkYW52ayk6IHRoZXJlIGFyZSBzb21lIGlzc3VlcyBjaGVja2luZyB4QXhpc1JhbmdlKCkgYW5kIHVzaW5nXG4gIC8vIHRvRG9tQ29vcmRzIGZyb20gaGFuZGxlcnMgb2YgdGhpcyBldmVudC4gVGhlIHZpc2libGUgcmFuZ2Ugc2hvdWxkIGJlIHNldFxuICAvLyB3aGVuIHRoZSBjaGFydCBpcyBkcmF3biwgbm90IGRlcml2ZWQgZnJvbSB0aGUgZGF0YS5cbiAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGF0YURpZFVwZGF0ZScsIHt9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBDU1YgZGF0YS4gSWYgaXQncyBpbiBhIGZ1bmN0aW9uLCBjYWxsIHRoYXQgZnVuY3Rpb24uIElmIGl0J3MgaW4gYVxuICogZmlsZSwgZG8gYW4gWE1MSHR0cFJlcXVlc3QgdG8gZ2V0IGl0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc3RhcnRfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5maWxlXztcblxuICAvLyBGdW5jdGlvbnMgY2FuIHJldHVybiByZWZlcmVuY2VzIG9mIGFsbCBvdGhlciB0eXBlcy5cbiAgaWYgKHR5cGVvZiBkYXRhID09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSgpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgdGhpcy5yYXdEYXRhXyA9IHRoaXMucGFyc2VBcnJheV8oZGF0YSk7XG4gICAgdGhpcy5jYXNjYWRlRGF0YURpZFVwZGF0ZUV2ZW50XygpO1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgIHR5cGVvZiBkYXRhLmdldENvbHVtblJhbmdlID09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBtdXN0IGJlIGEgRGF0YVRhYmxlIGZyb20gZ3Zpei5cbiAgICB0aGlzLnBhcnNlRGF0YVRhYmxlXyhkYXRhKTtcbiAgICB0aGlzLmNhc2NhZGVEYXRhRGlkVXBkYXRlRXZlbnRfKCk7XG4gICAgdGhpcy5wcmVkcmF3XygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgLy8gSGV1cmlzdGljOiBhIG5ld2xpbmUgbWVhbnMgaXQncyBDU1YgZGF0YS4gT3RoZXJ3aXNlIGl0J3MgYW4gVVJMLlxuICAgIHZhciBsaW5lX2RlbGltaXRlciA9IHV0aWxzLmRldGVjdExpbmVEZWxpbWl0ZXIoZGF0YSk7XG4gICAgaWYgKGxpbmVfZGVsaW1pdGVyKSB7XG4gICAgICB0aGlzLmxvYWRlZEV2ZW50XyhkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVNT1ZFX0ZPUl9JRVxuICAgICAgdmFyIHJlcTtcbiAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgLy8gRmlyZWZveCwgT3BlcmEsIElFNywgYW5kIG90aGVyIGJyb3dzZXJzIHdpbGwgdXNlIHRoZSBuYXRpdmUgb2JqZWN0XG4gICAgICAgIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgNSBhbmQgNiB3aWxsIHVzZSB0aGUgQWN0aXZlWCBjb250cm9sXG4gICAgICAgIHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxsZXIgPSB0aGlzO1xuICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PT0gMjAwIHx8ICAvLyBOb3JtYWwgaHR0cFxuICAgICAgICAgICAgICByZXEuc3RhdHVzID09PSAwKSB7ICAgIC8vIENocm9tZSB3LyAtLWFsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXNcbiAgICAgICAgICAgIGNhbGxlci5sb2FkZWRFdmVudF8ocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXEub3BlbihcIkdFVFwiLCBkYXRhLCB0cnVlKTtcbiAgICAgIHJlcS5zZW5kKG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biBkYXRhIGZvcm1hdDogXCIgKyAodHlwZW9mIGRhdGEpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgZ3JhcGguIFRoZXNlIGNhbiBpbmNsdWRlOlxuICogPHVsPlxuICogPGxpPmZpbGU6IGNoYW5nZXMgdGhlIHNvdXJjZSBkYXRhIGZvciB0aGUgZ3JhcGg8L2xpPlxuICogPGxpPmVycm9yQmFyczogY2hhbmdlcyB3aGV0aGVyIHRoZSBkYXRhIGNvbnRhaW5zIHN0ZGRldjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIFRoZXJlJ3MgYSBodWdlIHZhcmlldHkgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuIEZvciBhXG4gKiBmdWxsIGxpc3QsIHNlZSBodHRwOi8vZHlncmFwaHMuY29tL29wdGlvbnMuaHRtbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRfYXR0cnMgVGhlIG5ldyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tfcmVkcmF3IFVzdWFsbHkgdGhlIGNoYXJ0IGlzIHJlZHJhd24gYWZ0ZXIgZXZlcnlcbiAqICAgICBjYWxsIHRvIHVwZGF0ZU9wdGlvbnMoKS4gSWYgeW91IGtub3cgYmV0dGVyLCB5b3UgY2FuIHBhc3MgdHJ1ZSB0b1xuICogICAgIGV4cGxpY2l0bHkgYmxvY2sgdGhlIHJlZHJhdy4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBjaGFpbmluZ1xuICogICAgIHVwZGF0ZU9wdGlvbnMoKSBjYWxscywgYXZvaWRpbmcgdGhlIG9jY2FzaW9uYWwgaW5maW5pdGUgbG9vcCBhbmRcbiAqICAgICBwcmV2ZW50aW5nIHJlZHJhd3Mgd2hlbiBpdCdzIG5vdCBuZWNlc3NhcnkgKGUuZy4gd2hlbiB1cGRhdGluZyBhXG4gKiAgICAgY2FsbGJhY2spLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gZnVuY3Rpb24oaW5wdXRfYXR0cnMsIGJsb2NrX3JlZHJhdykge1xuICBpZiAodHlwZW9mKGJsb2NrX3JlZHJhdykgPT0gJ3VuZGVmaW5lZCcpIGJsb2NrX3JlZHJhdyA9IGZhbHNlO1xuXG4gIC8vIGNvcHlVc2VyQXR0cnNfIGRyb3BzIHRoZSBcImZpbGVcIiBwYXJhbWV0ZXIgYXMgYSBjb252ZW5pZW5jZSB0byB1cy5cbiAgdmFyIGZpbGUgPSBpbnB1dF9hdHRycy5maWxlO1xuICB2YXIgYXR0cnMgPSBEeWdyYXBoLmNvcHlVc2VyQXR0cnNfKGlucHV0X2F0dHJzKTtcblxuICAvLyBUT0RPKGRhbnZrKTogdGhpcyBpcyBhIG1lc3MuIE1vdmUgdGhlc2Ugb3B0aW9ucyBpbnRvIGF0dHJfLlxuICBpZiAoJ3JvbGxQZXJpb2QnIGluIGF0dHJzKSB7XG4gICAgdGhpcy5yb2xsUGVyaW9kXyA9IGF0dHJzLnJvbGxQZXJpb2Q7XG4gIH1cbiAgaWYgKCdkYXRlV2luZG93JyBpbiBhdHRycykge1xuICAgIHRoaXMuZGF0ZVdpbmRvd18gPSBhdHRycy5kYXRlV2luZG93O1xuICAgIGlmICghKCdpc1pvb21lZElnbm9yZVByb2dyYW1tYXRpY1pvb20nIGluIGF0dHJzKSkge1xuICAgICAgdGhpcy56b29tZWRfeF8gPSAoYXR0cnMuZGF0ZVdpbmRvdyAhPT0gbnVsbCk7XG4gICAgfVxuICB9XG4gIGlmICgndmFsdWVSYW5nZScgaW4gYXR0cnMgJiYgISgnaXNab29tZWRJZ25vcmVQcm9ncmFtbWF0aWNab29tJyBpbiBhdHRycykpIHtcbiAgICB0aGlzLnpvb21lZF95XyA9IChhdHRycy52YWx1ZVJhbmdlICE9PSBudWxsKTtcbiAgfVxuXG4gIC8vIFRPRE8oZGFudmspOiB2YWxpZGF0ZSBwZXItc2VyaWVzIG9wdGlvbnMuXG4gIC8vIFN1cHBvcnRlZDpcbiAgLy8gc3Ryb2tlV2lkdGhcbiAgLy8gcG9pbnRTaXplXG4gIC8vIGRyYXdQb2ludHNcbiAgLy8gaGlnaGxpZ2h0Q2lyY2xlU2l6ZVxuXG4gIC8vIENoZWNrIGlmIHRoaXMgc2V0IG9wdGlvbnMgd2lsbCByZXF1aXJlIG5ldyBwb2ludHMuXG4gIHZhciByZXF1aXJlc05ld1BvaW50cyA9IHV0aWxzLmlzUGl4ZWxDaGFuZ2luZ09wdGlvbkxpc3QodGhpcy5hdHRyXyhcImxhYmVsc1wiKSwgYXR0cnMpO1xuXG4gIHV0aWxzLnVwZGF0ZURlZXAodGhpcy51c2VyX2F0dHJzXywgYXR0cnMpO1xuXG4gIHRoaXMuYXR0cmlidXRlc18ucmVwYXJzZVNlcmllcygpO1xuXG4gIGlmIChmaWxlKSB7XG4gICAgLy8gVGhpcyBldmVudCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBhYm91dCB0byBjaGFuZ2UsIGJ1dCBoYXNuJ3QgeWV0LlxuICAgIC8vIFRPRE8oZGFudmspOiBzdXBwb3J0IGNhbmNlbGF0aW9uIG9mIHRoZSB1cGRhdGUgdmlhIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5jYXNjYWRlRXZlbnRzXygnZGF0YVdpbGxVcGRhdGUnLCB7fSk7XG5cbiAgICB0aGlzLmZpbGVfID0gZmlsZTtcbiAgICBpZiAoIWJsb2NrX3JlZHJhdykgdGhpcy5zdGFydF8oKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWJsb2NrX3JlZHJhdykge1xuICAgICAgaWYgKHJlcXVpcmVzTmV3UG9pbnRzKSB7XG4gICAgICAgIHRoaXMucHJlZHJhd18oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyR3JhcGhfKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBhIGNvcHkgb2YgaW5wdXQgYXR0cmlidXRlcywgcmVtb3ZpbmcgZmlsZSBhcyBhIGNvbnZlbmllbmNlLlxuICovXG5EeWdyYXBoLmNvcHlVc2VyQXR0cnNfID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgdmFyIG15X2F0dHJzID0ge307XG4gIGZvciAodmFyIGsgaW4gYXR0cnMpIHtcbiAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICBpZiAoayA9PSAnZmlsZScpIGNvbnRpbnVlO1xuICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrKSkgbXlfYXR0cnNba10gPSBhdHRyc1trXTtcbiAgfVxuICByZXR1cm4gbXlfYXR0cnM7XG59O1xuXG4vKipcbiAqIFJlc2l6ZXMgdGhlIGR5Z3JhcGguIElmIG5vIHBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCwgcmVzaXplcyB0byBmaWxsIHRoZVxuICogY29udGFpbmluZyBkaXYgKHdoaWNoIGhhcyBwcmVzdW1hYmx5IGNoYW5nZWQgc2l6ZSBzaW5jZSB0aGUgZHlncmFwaCB3YXNcbiAqIGluc3RhbnRpYXRlZC4gSWYgdGhlIHdpZHRoL2hlaWdodCBhcmUgc3BlY2lmaWVkLCB0aGUgZGl2IHdpbGwgYmUgcmVzaXplZC5cbiAqXG4gKiBUaGlzIGlzIGZhciBtb3JlIGVmZmljaWVudCB0aGFuIGRlc3Ryb3lpbmcgYW5kIHJlLWluc3RhbnRpYXRpbmcgYVxuICogRHlncmFwaCwgc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIHJlcGFyc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggKGluIHBpeGVscylcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IChpbiBwaXhlbHMpXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHRoaXMucmVzaXplX2xvY2spIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZXNpemVfbG9jayA9IHRydWU7XG5cbiAgaWYgKCh3aWR0aCA9PT0gbnVsbCkgIT0gKGhlaWdodCA9PT0gbnVsbCkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJEeWdyYXBoLnJlc2l6ZSgpIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB6ZXJvIHBhcmFtZXRlcnMgb3IgXCIgK1xuICAgICAgICAgICAgICAgICBcInR3byBub24tTlVMTCBwYXJhbWV0ZXJzLiBQcmV0ZW5kaW5nIGl0IHdhcyB6ZXJvLlwiKTtcbiAgICB3aWR0aCA9IGhlaWdodCA9IG51bGw7XG4gIH1cblxuICB2YXIgb2xkX3dpZHRoID0gdGhpcy53aWR0aF87XG4gIHZhciBvbGRfaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuXG4gIGlmICh3aWR0aCkge1xuICAgIHRoaXMubWFpbmRpdl8uc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB0aGlzLm1haW5kaXZfLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB0aGlzLndpZHRoXyA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0XyA9IGhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndpZHRoXyA9IHRoaXMubWFpbmRpdl8uY2xpZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHRfID0gdGhpcy5tYWluZGl2Xy5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBpZiAob2xkX3dpZHRoICE9IHRoaXMud2lkdGhfIHx8IG9sZF9oZWlnaHQgIT0gdGhpcy5oZWlnaHRfKSB7XG4gICAgLy8gUmVzaXppbmcgYSBjYW52YXMgZXJhc2VzIGl0LCBldmVuIHdoZW4gdGhlIHNpemUgZG9lc24ndCBjaGFuZ2UsIHNvXG4gICAgLy8gYW55IHJlc2l6ZSBuZWVkcyB0byBiZSBmb2xsb3dlZCBieSBhIHJlZHJhdy5cbiAgICB0aGlzLnJlc2l6ZUVsZW1lbnRzXygpO1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfVxuXG4gIHRoaXMucmVzaXplX2xvY2sgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgcm9sbGluZyBhdmVyYWdlLiBVcGRhdGVzIHRoZSBncmFwaCB0b1xuICogcmVmbGVjdCB0aGUgbmV3IGF2ZXJhZ2luZyBwZXJpb2QuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBwb2ludHMgb3ZlciB3aGljaCB0byBhdmVyYWdlIHRoZSBkYXRhLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5hZGp1c3RSb2xsID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHRoaXMucm9sbFBlcmlvZF8gPSBsZW5ndGg7XG4gIHRoaXMucHJlZHJhd18oKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gYXJyYXkgb2YgdmlzaWJpbGl0eSBzdGF0dXNlcy5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUudmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuICAvLyBEbyBsYXp5LWluaXRpYWxpemF0aW9uLCBzbyB0aGF0IHRoaXMgaGFwcGVucyBhZnRlciB3ZSBrbm93IHRoZSBudW1iZXIgb2ZcbiAgLy8gZGF0YSBzZXJpZXMuXG4gIGlmICghdGhpcy5nZXRPcHRpb24oXCJ2aXNpYmlsaXR5XCIpKSB7XG4gICAgdGhpcy5hdHRyc18udmlzaWJpbGl0eSA9IFtdO1xuICB9XG4gIC8vIFRPRE8oZGFudmspOiBpdCBsb29rcyBsaWtlIHRoaXMgY291bGQgZ28gaW50byBhbiBpbmZpbml0ZSBsb29wIHcvIHVzZXJfYXR0cnMuXG4gIHdoaWxlICh0aGlzLmdldE9wdGlvbihcInZpc2liaWxpdHlcIikubGVuZ3RoIDwgdGhpcy5udW1Db2x1bW5zKCkgLSAxKSB7XG4gICAgdGhpcy5hdHRyc18udmlzaWJpbGl0eS5wdXNoKHRydWUpO1xuICB9XG4gIHJldHVybiB0aGlzLmdldE9wdGlvbihcInZpc2liaWxpdHlcIik7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHZpc2liaWxpdHkgb2Ygb25lIG9yIG1vcmUgc2VyaWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfG9iamVjdH0gbnVtIHRoZSBzZXJpZXMgaW5kZXggb3IgYW4gYXJyYXkgb2Ygc2VyaWVzIGluZGljZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYm9vbGVhbiBhcnJheSBvZiB2aXNpYmlsaXR5IHN0YXRlcyBieSBpbmRleFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYW4gb2JqZWN0IG1hcHBpbmcgc2VyaWVzIG51bWJlcnMsIGFzIGtleXMsIHRvIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSBzdGF0ZSAoYm9vbGVhbiB2YWx1ZXMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIHRoZSB2aXNpYmlsaXR5IHN0YXRlIGV4cHJlc3NlZCBhcyBhIGJvb2xlYW5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2V0VmlzaWJpbGl0eSA9IGZ1bmN0aW9uKG51bSwgdmFsdWUpIHtcbiAgdmFyIHggPSB0aGlzLnZpc2liaWxpdHkoKTtcbiAgdmFyIG51bUlzT2JqZWN0ID0gZmFsc2U7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KG51bSkpIHtcbiAgICBpZiAobnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBudW1Jc09iamVjdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bSA9IFtudW1dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChudW1Jc09iamVjdCkge1xuICAgIGZvciAodmFyIGkgaW4gbnVtKSB7XG4gICAgICBpZiAobnVtLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCBpID49IHgubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzZXJpZXMgbnVtYmVyIGluIHNldFZpc2liaWxpdHk6IFwiICsgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFtpXSA9IG51bVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBudW1baV0gPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaSA+PSB4Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc2VyaWVzIG51bWJlciBpbiBzZXRWaXNpYmlsaXR5OiBcIiArIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhbaV0gPSBudW1baV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChudW1baV0gPCAwIHx8IG51bVtpXSA+PSB4Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc2VyaWVzIG51bWJlciBpbiBzZXRWaXNpYmlsaXR5OiBcIiArIG51bVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeFtudW1baV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnByZWRyYXdfKCk7XG59O1xuXG4vKipcbiAqIEhvdyBsYXJnZSBvZiBhbiBhcmVhIHdpbGwgdGhlIGR5Z3JhcGggcmVuZGVyIGl0c2VsZiBpbj9cbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGVzdGluZy5cbiAqIEByZXR1cm4gQSB7d2lkdGg6IHcsIGhlaWdodDogaH0gb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4geyB3aWR0aDogdGhpcy53aWR0aF8sIGhlaWdodDogdGhpcy5oZWlnaHRfIH07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBhbm5vdGF0aW9ucyBhbmQgcmVkcmF3IHRoZSBjaGFydC5cbiAqIFNlZSBkeWdyYXBocy5jb20vYW5ub3RhdGlvbnMuaHRtbCBmb3IgbW9yZSBpbmZvIG9uIGhvdyB0byB1c2UgYW5ub3RhdGlvbnMuXG4gKiBAcGFyYW0gYW5uIHtBcnJheX0gQW4gYXJyYXkgb2YgYW5ub3RhdGlvbiBvYmplY3RzLlxuICogQHBhcmFtIHN1cHByZXNzRHJhdyB7Qm9vbGVhbn0gU2V0IHRvIFwidHJ1ZVwiIHRvIGJsb2NrIGNoYXJ0IHJlZHJhdyAob3B0aW9uYWwpLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubiwgc3VwcHJlc3NEcmF3KSB7XG4gIC8vIE9ubHkgYWRkIHRoZSBhbm5vdGF0aW9uIENTUyBydWxlIG9uY2Ugd2Uga25vdyBpdCB3aWxsIGJlIHVzZWQuXG4gIER5Z3JhcGguYWRkQW5ub3RhdGlvblJ1bGUoKTtcbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBhbm47XG4gIGlmICghdGhpcy5sYXlvdXRfKSB7XG4gICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gc2V0QW5ub3RhdGlvbnMgYmVmb3JlIGR5Z3JhcGggd2FzIHJlYWR5LiBcIiArXG4gICAgICAgICAgICAgICAgIFwiVHJ5IHNldHRpbmcgdGhlbSBpbiBhIHJlYWR5KCkgYmxvY2suIFNlZSBcIiArXG4gICAgICAgICAgICAgICAgIFwiZHlncmFwaHMuY29tL3Rlc3RzL2Fubm90YXRpb24uaHRtbFwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmxheW91dF8uc2V0QW5ub3RhdGlvbnModGhpcy5hbm5vdGF0aW9uc18pO1xuICBpZiAoIXN1cHByZXNzRHJhdykge1xuICAgIHRoaXMucHJlZHJhd18oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3Qgb2YgYW5ub3RhdGlvbnMuXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFubm90YXRpb25zXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIGxhYmVsIG5hbWVzIGZvciB0aGlzIGdyYXBoLiBUaGUgZmlyc3QgY29sdW1uIGlzIHRoZVxuICogeC1heGlzLCBzbyB0aGUgZGF0YSBzZXJpZXMgbmFtZXMgc3RhcnQgYXQgaW5kZXggMS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgd2hlbiBsYWJlbHMgaGF2ZSBub3QgeWV0IGJlZW4gZGVmaW5lZC5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUuZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbHMgPSB0aGlzLmF0dHJfKFwibGFiZWxzXCIpO1xuICByZXR1cm4gbGFiZWxzID8gbGFiZWxzLnNsaWNlKCkgOiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGluZGV4IG9mIGEgc2VyaWVzIChjb2x1bW4pIGdpdmVuIGl0cyBuYW1lLiBUaGUgZmlyc3QgY29sdW1uIGlzIHRoZVxuICogeC1heGlzLCBzbyB0aGUgZGF0YSBzZXJpZXMgc3RhcnQgd2l0aCBpbmRleCAxLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5pbmRleEZyb21TZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5zZXRJbmRleEJ5TmFtZV9bbmFtZV07XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHJvdyBudW1iZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4geC12YWx1ZS5cbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIHgtdmFsdWUgaW4gdGhlIGRhdGEuXG4gKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcm93cyB3aXRoIHRoZSBzYW1lIHgtdmFsdWUsIHRoaXMgd2lsbCByZXR1cm4gdGhlXG4gKiBmaXJzdCBvbmUuXG4gKiBAcGFyYW0ge251bWJlcn0geFZhbCBUaGUgeC12YWx1ZSB0byBsb29rIGZvciAoZS5nLiBtaWxsaXMgc2luY2UgZXBvY2gpLlxuICogQHJldHVybiB7P251bWJlcn0gVGhlIHJvdyBudW1iZXIsIHdoaWNoIHlvdSBjYW4gcGFzcyB0byBnZXRWYWx1ZSgpLCBvciBudWxsLlxuICovXG5EeWdyYXBoLnByb3RvdHlwZS5nZXRSb3dGb3JYID0gZnVuY3Rpb24oeFZhbCkge1xuICB2YXIgbG93ID0gMCxcbiAgICAgIGhpZ2ggPSB0aGlzLm51bVJvd3MoKSAtIDE7XG5cbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgdmFyIGlkeCA9IChoaWdoICsgbG93KSA+PiAxO1xuICAgIHZhciB4ID0gdGhpcy5nZXRWYWx1ZShpZHgsIDApO1xuICAgIGlmICh4IDwgeFZhbCkge1xuICAgICAgbG93ID0gaWR4ICsgMTtcbiAgICB9IGVsc2UgaWYgKHggPiB4VmFsKSB7XG4gICAgICBoaWdoID0gaWR4IC0gMTtcbiAgICB9IGVsc2UgaWYgKGxvdyAhPSBpZHgpIHsgIC8vIGVxdWFsLCBidXQgdGhlcmUgbWF5IGJlIGFuIGVhcmxpZXIgbWF0Y2guXG4gICAgICBoaWdoID0gaWR4O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgY2FsbGJhY2sgd2hlbiB0aGUgZHlncmFwaCBoYXMgZHJhd24gaXRzZWxmIGFuZCBpcyByZWFkeSB0byBiZVxuICogbWFuaXB1bGF0ZWQuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCB3aGVuIGR5Z3JhcGhzIGhhcyB0byBkbyBhbiBYSFIgZm9yIHRoZVxuICogZGF0YSAoaS5lLiBhIFVSTCBpcyBwYXNzZWQgYXMgdGhlIGRhdGEgc291cmNlKSBhbmQgdGhlIGNoYXJ0IGlzIGRyYXduXG4gKiBhc3luY2hyb25vdXNseS4gSWYgdGhlIGNoYXJ0IGhhcyBhbHJlYWR5IGRyYXduLCB0aGUgY2FsbGJhY2sgd2lsbCBmaXJlXG4gKiBpbW1lZGlhdGVseS5cbiAqXG4gKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSB0byBjYWxsIHNldEFubm90YXRpb24oKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFEeWdyYXBoKX0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgd2hlbiB0aGUgY2hhcnRcbiAqICAgICBpcyByZWFkeS5cbiAqL1xuRHlncmFwaC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAodGhpcy5pc19pbml0aWFsX2RyYXdfKSB7XG4gICAgdGhpcy5yZWFkeUZuc18ucHVzaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQWRkcyBhIGRlZmF1bHQgc3R5bGUgZm9yIHRoZSBhbm5vdGF0aW9uIENTUyBjbGFzc2VzIHRvIHRoZSBkb2N1bWVudC4gVGhpcyBpc1xuICogb25seSBleGVjdXRlZCB3aGVuIGFubm90YXRpb25zIGFyZSBhY3R1YWxseSB1c2VkLiBJdCBpcyBkZXNpZ25lZCB0byBvbmx5IGJlXG4gKiBjYWxsZWQgb25jZSAtLSBhbGwgY2FsbHMgYWZ0ZXIgdGhlIGZpcnN0IHdpbGwgcmV0dXJuIGltbWVkaWF0ZWx5LlxuICovXG5EeWdyYXBoLmFkZEFubm90YXRpb25SdWxlID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8oZGFudmspOiBtb3ZlIHRoaXMgZnVuY3Rpb24gaW50byBwbHVnaW5zL2Fubm90YXRpb25zLmpzP1xuICBpZiAoRHlncmFwaC5hZGRlZEFubm90YXRpb25DU1MpIHJldHVybjtcblxuICB2YXIgcnVsZSA9IFwiYm9yZGVyOiAxcHggc29saWQgYmxhY2s7IFwiICtcbiAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBcIiArXG4gICAgICAgICAgICAgXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XCI7XG5cbiAgdmFyIHN0eWxlU2hlZXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZVNoZWV0RWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGVTaGVldEVsZW1lbnQpO1xuXG4gIC8vIEZpbmQgdGhlIGZpcnN0IHN0eWxlIHNoZWV0IHRoYXQgd2UgY2FuIGFjY2Vzcy5cbiAgLy8gV2UgbWF5IG5vdCBhZGQgYSBydWxlIHRvIGEgc3R5bGUgc2hlZXQgZnJvbSBhbm90aGVyIGRvbWFpbiBmb3Igc2VjdXJpdHlcbiAgLy8gcmVhc29ucy4gVGhpcyBzb21ldGltZXMgY29tZXMgdXAgd2hlbiB1c2luZyBndml6LCBzaW5jZSB0aGUgR29vZ2xlIGd2aXogSlNcbiAgLy8gYWRkcyBpdHMgb3duIHN0eWxlIHNoZWV0cyBmcm9tIGdvb2dsZS5jb20uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZG9jdW1lbnQuc3R5bGVTaGVldHNbaV0uZGlzYWJsZWQpIGNvbnRpbnVlO1xuICAgIHZhciBteXNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgdHJ5IHtcbiAgICAgIGlmIChteXNoZWV0Lmluc2VydFJ1bGUpIHsgIC8vIEZpcmVmb3hcbiAgICAgICAgdmFyIGlkeCA9IG15c2hlZXQuY3NzUnVsZXMgPyBteXNoZWV0LmNzc1J1bGVzLmxlbmd0aCA6IDA7XG4gICAgICAgIG15c2hlZXQuaW5zZXJ0UnVsZShcIi5keWdyYXBoRGVmYXVsdEFubm90YXRpb24geyBcIiArIHJ1bGUgKyBcIiB9XCIsIGlkeCk7XG4gICAgICB9IGVsc2UgaWYgKG15c2hlZXQuYWRkUnVsZSkgeyAgLy8gSUVcbiAgICAgICAgbXlzaGVldC5hZGRSdWxlKFwiLmR5Z3JhcGhEZWZhdWx0QW5ub3RhdGlvblwiLCBydWxlKTtcbiAgICAgIH1cbiAgICAgIER5Z3JhcGguYWRkZWRBbm5vdGF0aW9uQ1NTID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgLy8gV2FzIGxpa2VseSBhIHNlY3VyaXR5IGV4Y2VwdGlvbi5cbiAgICB9XG4gIH1cblxuICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gYWRkIGRlZmF1bHQgYW5ub3RhdGlvbiBDU1MgcnVsZTsgZGlzcGxheSBtYXkgYmUgb2ZmLlwiKTtcbn07XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuIFRoaXMgZXZlbnQgaGFuZGxlciBpcyBrZXB0IHVudGlsIHRoZSBncmFwaCBpc1xuICogZGVzdHJveWVkIHdpdGggYSBjYWxsIHRvIGdyYXBoLmRlc3Ryb3koKS5cbiAqXG4gKiBAcGFyYW0geyFOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2Vtb3ZlJy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnQpOihib29sZWFufHVuZGVmaW5lZCl9IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gKiAgICAgb24gdGhlIGV2ZW50LiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlcjogdGhlIGV2ZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkR5Z3JhcGgucHJvdG90eXBlLmFkZEFuZFRyYWNrRXZlbnQgPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBmbikge1xuICB1dGlscy5hZGRFdmVudChlbGVtLCB0eXBlLCBmbik7XG4gIHRoaXMucmVnaXN0ZXJlZEV2ZW50c18ucHVzaCh7ZWxlbSwgdHlwZSwgZm59KTtcbn07XG5cbkR5Z3JhcGgucHJvdG90eXBlLnJlbW92ZVRyYWNrZWRFdmVudHNfID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHNfKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5yZWdpc3RlcmVkRXZlbnRzXy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB2YXIgcmVnID0gdGhpcy5yZWdpc3RlcmVkRXZlbnRzX1tpZHhdO1xuICAgICAgdXRpbHMucmVtb3ZlRXZlbnQocmVnLmVsZW0sIHJlZy50eXBlLCByZWcuZm4pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVnaXN0ZXJlZEV2ZW50c18gPSBbXTtcbn07XG5cblxuLy8gSW5zdGFsbGVkIHBsdWdpbnMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UgKG1vc3QtZ2VuZXJhbCB0byBtb3N0LXNwZWNpZmljKS5cbkR5Z3JhcGguUExVR0lOUyA9IFtcbiAgTGVnZW5kUGx1Z2luLFxuICBBeGVzUGx1Z2luLFxuICBSYW5nZVNlbGVjdG9yUGx1Z2luLCAvLyBIYXMgdG8gYmUgYmVmb3JlIENoYXJ0TGFiZWxzIHNvIHRoYXQgaXRzIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGFmdGVyIENoYXJ0TGFiZWxzJyBjYWxsYmFja3MuXG4gIENoYXJ0TGFiZWxzUGx1Z2luLFxuICBBbm5vdGF0aW9uc1BsdWdpbixcbiAgR3JpZFBsdWdpblxuXTtcblxuLy8gVGhlcmUgYXJlIG1hbnkgc3ltYm9scyB3aGljaCBoYXZlIGhpc3RvcmljYWxseSBiZWVuIGF2YWlsYWJsZSB0aHJvdWdoIHRoZVxuLy8gRHlncmFwaCBjbGFzcy4gVGhlc2UgYXJlIGV4cG9ydGVkIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuRHlncmFwaC5HVml6Q2hhcnQgPSBHVml6Q2hhcnQ7XG5EeWdyYXBoLkRBU0hFRF9MSU5FID0gdXRpbHMuREFTSEVEX0xJTkU7XG5EeWdyYXBoLkRPVF9EQVNIX0xJTkUgPSB1dGlscy5ET1RfREFTSF9MSU5FO1xuRHlncmFwaC5kYXRlQXhpc0xhYmVsRm9ybWF0dGVyID0gdXRpbHMuZGF0ZUF4aXNMYWJlbEZvcm1hdHRlcjtcbkR5Z3JhcGgudG9SR0JfID0gdXRpbHMudG9SR0JfO1xuRHlncmFwaC5maW5kUG9zID0gdXRpbHMuZmluZFBvcztcbkR5Z3JhcGgucGFnZVggPSB1dGlscy5wYWdlWDtcbkR5Z3JhcGgucGFnZVkgPSB1dGlscy5wYWdlWTtcbkR5Z3JhcGguZGF0ZVN0cmluZ18gPSB1dGlscy5kYXRlU3RyaW5nXztcbkR5Z3JhcGguZGVmYXVsdEludGVyYWN0aW9uTW9kZWwgPSBEeWdyYXBoSW50ZXJhY3Rpb24uZGVmYXVsdE1vZGVsO1xuRHlncmFwaC5ub25JbnRlcmFjdGl2ZU1vZGVsID0gRHlncmFwaC5ub25JbnRlcmFjdGl2ZU1vZGVsXyA9IER5Z3JhcGhJbnRlcmFjdGlvbi5ub25JbnRlcmFjdGl2ZU1vZGVsXztcbkR5Z3JhcGguQ2lyY2xlcyA9IHV0aWxzLkNpcmNsZXM7XG5cbkR5Z3JhcGguUGx1Z2lucyA9IHtcbiAgTGVnZW5kOiBMZWdlbmRQbHVnaW4sXG4gIEF4ZXM6IEF4ZXNQbHVnaW4sXG4gIEFubm90YXRpb25zOiBBbm5vdGF0aW9uc1BsdWdpbixcbiAgQ2hhcnRMYWJlbHM6IENoYXJ0TGFiZWxzUGx1Z2luLFxuICBHcmlkOiBHcmlkUGx1Z2luLFxuICBSYW5nZVNlbGVjdG9yOiBSYW5nZVNlbGVjdG9yUGx1Z2luXG59O1xuXG5EeWdyYXBoLkRhdGFIYW5kbGVycyA9IHtcbiAgRGVmYXVsdEhhbmRsZXIsXG4gIEJhcnNIYW5kbGVyLFxuICBDdXN0b21CYXJzSGFuZGxlcixcbiAgRGVmYXVsdEZyYWN0aW9uSGFuZGxlcixcbiAgRXJyb3JCYXJzSGFuZGxlcixcbiAgRnJhY3Rpb25zQmFyc0hhbmRsZXJcbn07XG5cbkR5Z3JhcGguc3RhcnRQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24uc3RhcnRQYW47XG5EeWdyYXBoLnN0YXJ0Wm9vbSA9IER5Z3JhcGhJbnRlcmFjdGlvbi5zdGFydFpvb207XG5EeWdyYXBoLm1vdmVQYW4gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVBhbjtcbkR5Z3JhcGgubW92ZVpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24ubW92ZVpvb207XG5EeWdyYXBoLmVuZFBhbiA9IER5Z3JhcGhJbnRlcmFjdGlvbi5lbmRQYW47XG5EeWdyYXBoLmVuZFpvb20gPSBEeWdyYXBoSW50ZXJhY3Rpb24uZW5kWm9vbTtcblxuRHlncmFwaC5udW1lcmljTGluZWFyVGlja3MgPSBEeWdyYXBoVGlja2Vycy5udW1lcmljTGluZWFyVGlja3M7XG5EeWdyYXBoLm51bWVyaWNUaWNrcyA9IER5Z3JhcGhUaWNrZXJzLm51bWVyaWNUaWNrcztcbkR5Z3JhcGguZGF0ZVRpY2tlciA9IER5Z3JhcGhUaWNrZXJzLmRhdGVUaWNrZXI7XG5EeWdyYXBoLkdyYW51bGFyaXR5ID0gRHlncmFwaFRpY2tlcnMuR3JhbnVsYXJpdHk7XG5EeWdyYXBoLmdldERhdGVBeGlzID0gRHlncmFwaFRpY2tlcnMuZ2V0RGF0ZUF4aXM7XG5EeWdyYXBoLmZsb2F0Rm9ybWF0ID0gdXRpbHMuZmxvYXRGb3JtYXQ7XG5cbmV4cG9ydCBkZWZhdWx0IER5Z3JhcGg7XG4iLCIvKipcbiAqIFRvIGNyZWF0ZSBhIFwiZHJhZ1wiIGludGVyYWN0aW9uLCB5b3UgdHlwaWNhbGx5IHJlZ2lzdGVyIGEgbW91c2Vkb3duIGV2ZW50XG4gKiBoYW5kbGVyIG9uIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBkcmFnIGJlZ2lucy4gSW4gdGhhdCBoYW5kbGVyLCB5b3UgcmVnaXN0ZXIgYVxuICogbW91c2V1cCBoYW5kbGVyIG9uIHRoZSB3aW5kb3cgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIG1vdXNlIGlzIHJlbGVhc2VkLFxuICogd2hlcmV2ZXIgdGhhdCByZWxlYXNlIGhhcHBlbnMuIFRoaXMgd29ya3Mgd2VsbCwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgcmVsZWFzZXNcbiAqIHRoZSBtb3VzZSBvdmVyIGFuIG9mZi1kb21haW4gaWZyYW1lLiBJbiB0aGF0IGNhc2UsIHRoZSBtb3VzZXVwIGV2ZW50IGlzXG4gKiBoYW5kbGVkIGJ5IHRoZSBpZnJhbWUgYW5kIG5ldmVyIGJ1YmJsZXMgdXAgdG8gdGhlIHdpbmRvdyBoYW5kbGVyLlxuICpcbiAqIFRvIGRlYWwgd2l0aCB0aGlzIGlzc3VlLCB3ZSBjb3ZlciBpZnJhbWVzIHdpdGggaGlnaCB6LWluZGV4IGRpdnMgdG8gbWFrZSBzdXJlXG4gKiB0aGV5IGRvbid0IGNhcHR1cmUgbW91c2V1cC5cbiAqXG4gKiBVc2FnZTpcbiAqIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XG4gKiAgIHZhciB0YXJwZXIgPSBuZXcgSUZyYW1lVGFycCgpO1xuICogICB0YXJwZXIuY292ZXIoKTtcbiAqICAgdmFyIG1vdXNlVXBIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgLi4uXG4gKiAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VVcEhhbmRsZXIpO1xuICogICAgIHRhcnBlci51bmNvdmVyKCk7XG4gKiAgIH07XG4gKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuICogfTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9keWdyYXBoLXV0aWxzJztcblxuZnVuY3Rpb24gSUZyYW1lVGFycCgpIHtcbiAgLyoqIEB0eXBlIHtBcnJheS48IUhUTUxEaXZFbGVtZW50Pn0gKi9cbiAgdGhpcy50YXJwcyA9IFtdO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCB0aGUgaWZyYW1lcyBpbiB0aGUgZG9jdW1lbnQgYW5kIGNvdmVyIHRoZW0gd2l0aCBoaWdoIHotaW5kZXhcbiAqIHRyYW5zcGFyZW50IGRpdnMuXG4gKi9cbklGcmFtZVRhcnAucHJvdG90eXBlLmNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZnJhbWVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZnJhbWUgPSBpZnJhbWVzW2ldO1xuICAgIHZhciBwb3MgPSB1dGlscy5maW5kUG9zKGlmcmFtZSksXG4gICAgICAgIHggPSBwb3MueCxcbiAgICAgICAgeSA9IHBvcy55LFxuICAgICAgICB3aWR0aCA9IGlmcmFtZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gaWZyYW1lLm9mZnNldEhlaWdodDtcblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIGRpdi5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICBkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZGl2LnN0eWxlLnpJbmRleCA9IDk5OTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgdGhpcy50YXJwcy5wdXNoKGRpdik7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgaWZyYW1lIGNvdmVycy4gWW91IHNob3VsZCBjYWxsIHRoaXMgaW4gYSBtb3VzZXVwIGhhbmRsZXIuXG4gKi9cbklGcmFtZVRhcnAucHJvdG90eXBlLnVuY292ZXIgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRhcnBzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy50YXJwc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGFycHNbaV0pO1xuICB9XG4gIHRoaXMudGFycHMgPSBbXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElGcmFtZVRhcnA7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG5cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuQ3VycmVudCBiaXRzIG9mIGphbmtpbmVzczpcbi0gVXNlcyBkeWdyYXBoLmxheW91dF8gdG8gZ2V0IHRoZSBwYXJzZWQgYW5ub3RhdGlvbnMuXG4tIFVzZXMgZHlncmFwaC5wbG90dGVyXy5hcmVhXG5cbkl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIHBsdWdpbiBkaWRuJ3QgcmVxdWlyZSBzbyBtdWNoIHNwZWNpYWwgc3VwcG9ydCBpbnNpZGVcbnRoZSBjb3JlIGR5Z3JhcGhzIGNsYXNzZXMsIGJ1dCBhbm5vdGF0aW9ucyBpbnZvbHZlIHF1aXRlIGEgYml0IG9mIHBhcnNpbmcgYW5kXG5sYXlvdXQuXG5cblRPRE8oZGFudmspOiBjYWNoZSBET00gZWxlbWVudHMuXG4qL1xuXG52YXIgYW5ub3RhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hbm5vdGF0aW9uc18gPSBbXTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJBbm5vdGF0aW9ucyBQbHVnaW5cIjtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgcmV0dXJuIHtcbiAgICBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmRldGFjaExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5ub3RhdGlvbnNfLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEgPSB0aGlzLmFubm90YXRpb25zX1tpXTtcbiAgICBpZiAoYS5wYXJlbnROb2RlKSBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uc19baV0gPSBudWxsO1xuICB9XG4gIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG59O1xuXG5hbm5vdGF0aW9ucy5wcm90b3R5cGUuY2xlYXJDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHMoKTtcbn07XG5cbmFubm90YXRpb25zLnByb3RvdHlwZS5kaWREcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIHZhciBnID0gZS5keWdyYXBoO1xuXG4gIC8vIEVhcmx5IG91dCBpbiB0aGUgKGNvbW1vbikgY2FzZSBvZiB6ZXJvIGFubm90YXRpb25zLlxuICB2YXIgcG9pbnRzID0gZy5sYXlvdXRfLmFubm90YXRlZF9wb2ludHM7XG4gIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICB2YXIgY29udGFpbmVyRGl2ID0gZS5jYW52YXMucGFyZW50Tm9kZTtcbiAgdmFyIGFubm90YXRpb25TdHlsZSA9IHtcbiAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICBcImZvbnRTaXplXCI6IGcuZ2V0T3B0aW9uKCdheGlzTGFiZWxGb250U2l6ZScpICsgXCJweFwiLFxuICAgIFwiekluZGV4XCI6IDEwLFxuICAgIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIlxuICB9O1xuXG4gIHZhciBiaW5kRXZ0ID0gZnVuY3Rpb24oZXZlbnROYW1lLCBjbGFzc0V2ZW50TmFtZSwgcHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYW5ub3RhdGlvbl9ldmVudCkge1xuICAgICAgdmFyIGEgPSBwdC5hbm5vdGF0aW9uO1xuICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBhW2V2ZW50TmFtZV0oYSwgcHQsIGcsIGFubm90YXRpb25fZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChnLmdldE9wdGlvbihjbGFzc0V2ZW50TmFtZSkpIHtcbiAgICAgICAgZy5nZXRPcHRpb24oY2xhc3NFdmVudE5hbWUpKGEsIHB0LCBnLCBhbm5vdGF0aW9uX2V2ZW50ICk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBBZGQgdGhlIGFubm90YXRpb25zIG9uZS1ieS1vbmUuXG4gIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG5cbiAgLy8geC1jb29yZCB0byBzdW0gb2YgcHJldmlvdXMgYW5ub3RhdGlvbidzIGhlaWdodHMgKHVzZWQgZm9yIHN0YWNraW5nKS5cbiAgdmFyIHhUb1VzZWRIZWlnaHQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIGlmIChwLmNhbnZhc3ggPCBhcmVhLnggfHwgcC5jYW52YXN4ID4gYXJlYS54ICsgYXJlYS53IHx8XG4gICAgICAgIHAuY2FudmFzeSA8IGFyZWEueSB8fCBwLmNhbnZhc3kgPiBhcmVhLnkgKyBhcmVhLmgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBhID0gcC5hbm5vdGF0aW9uO1xuICAgIHZhciB0aWNrX2hlaWdodCA9IDY7XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoXCJ0aWNrSGVpZ2h0XCIpKSB7XG4gICAgICB0aWNrX2hlaWdodCA9IGEudGlja0hlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFubm90YXRpb25TdHlsZSkge1xuICAgICAgaWYgKGFubm90YXRpb25TdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBkaXYuc3R5bGVbbmFtZV0gPSBhbm5vdGF0aW9uU3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYS5oYXNPd25Qcm9wZXJ0eSgnaWNvbicpKSB7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gXCJkeWdyYXBoRGVmYXVsdEFubm90YXRpb25cIjtcbiAgICB9XG4gICAgaWYgKGEuaGFzT3duUHJvcGVydHkoJ2Nzc0NsYXNzJykpIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgXCIgKyBhLmNzc0NsYXNzO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGEuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgPyBhLndpZHRoIDogMTY7XG4gICAgdmFyIGhlaWdodCA9IGEuaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpID8gYS5oZWlnaHQgOiAxNjtcbiAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eSgnaWNvbicpKSB7XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltZy5zcmMgPSBhLmljb247XG4gICAgICBpbWcud2lkdGggPSB3aWR0aDtcbiAgICAgIGltZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHAuYW5ub3RhdGlvbi5oYXNPd25Qcm9wZXJ0eSgnc2hvcnRUZXh0JykpIHtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwLmFubm90YXRpb24uc2hvcnRUZXh0KSk7XG4gICAgfVxuICAgIHZhciBsZWZ0ID0gcC5jYW52YXN4IC0gd2lkdGggLyAyO1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICB2YXIgZGl2VG9wID0gMDtcbiAgICBpZiAoYS5hdHRhY2hBdEJvdHRvbSkge1xuICAgICAgdmFyIHkgPSAoYXJlYS55ICsgYXJlYS5oIC0gaGVpZ2h0IC0gdGlja19oZWlnaHQpO1xuICAgICAgaWYgKHhUb1VzZWRIZWlnaHRbbGVmdF0pIHtcbiAgICAgICAgeSAtPSB4VG9Vc2VkSGVpZ2h0W2xlZnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFRvVXNlZEhlaWdodFtsZWZ0XSA9IDA7XG4gICAgICB9XG4gICAgICB4VG9Vc2VkSGVpZ2h0W2xlZnRdICs9ICh0aWNrX2hlaWdodCArIGhlaWdodCk7XG4gICAgICBkaXZUb3AgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXZUb3AgPSBwLmNhbnZhc3kgLSBoZWlnaHQgLSB0aWNrX2hlaWdodDtcbiAgICB9XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdlRvcCArIFwicHhcIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIGRpdi50aXRsZSA9IHAuYW5ub3RhdGlvbi50ZXh0O1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGRpdi5zdHlsZS5ib3JkZXJDb2xvciA9IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGEuZGl2ID0gZGl2O1xuXG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ2NsaWNrJyxcbiAgICAgICAgYmluZEV2dCgnY2xpY2tIYW5kbGVyJywgJ2Fubm90YXRpb25DbGlja0hhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ21vdXNlb3ZlcicsXG4gICAgICAgIGJpbmRFdnQoJ21vdXNlT3ZlckhhbmRsZXInLCAnYW5ub3RhdGlvbk1vdXNlT3ZlckhhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ21vdXNlb3V0JyxcbiAgICAgICAgYmluZEV2dCgnbW91c2VPdXRIYW5kbGVyJywgJ2Fubm90YXRpb25Nb3VzZU91dEhhbmRsZXInLCBwLCB0aGlzKSk7XG4gICAgZy5hZGRBbmRUcmFja0V2ZW50KGRpdiwgJ2RibGNsaWNrJyxcbiAgICAgICAgYmluZEV2dCgnZGJsQ2xpY2tIYW5kbGVyJywgJ2Fubm90YXRpb25EYmxDbGlja0hhbmRsZXInLCBwLCB0aGlzKSk7XG5cbiAgICBjb250YWluZXJEaXYuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLmFubm90YXRpb25zXy5wdXNoKGRpdik7XG5cbiAgICB2YXIgY3R4ID0gZS5kcmF3aW5nQ29udGV4dDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGcuY29sb3JzTWFwX1twLm5hbWVdO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoIWEuYXR0YWNoQXRCb3R0b20pIHtcbiAgICAgIGN0eC5tb3ZlVG8ocC5jYW52YXN4LCBwLmNhbnZhc3kpO1xuICAgICAgY3R4LmxpbmVUbyhwLmNhbnZhc3gsIHAuY2FudmFzeSAtIDIgLSB0aWNrX2hlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5ID0gZGl2VG9wICsgaGVpZ2h0O1xuICAgICAgY3R4Lm1vdmVUbyhwLmNhbnZhc3gsIHkpO1xuICAgICAgY3R4LmxpbmVUbyhwLmNhbnZhc3gsIHkgKyB0aWNrX2hlaWdodCk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcblxuYW5ub3RhdGlvbnMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHMoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFubm90YXRpb25zO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTIgRGFuIFZhbmRlcmthbSAoZGFudmRrQGdtYWlsLmNvbSlcbiAqIE1JVC1saWNlbnNlZCAoaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVClcbiAqL1xuXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cbid1c2Ugc3RyaWN0JztcblxuLypcbkJpdHMgb2YgamFua2luZXNzOlxuLSBEaXJlY3QgbGF5b3V0IGFjY2Vzc1xuLSBEaXJlY3QgYXJlYSBhY2Nlc3Ncbi0gU2hvdWxkIGluY2x1ZGUgY2FsY3VsYXRpb24gb2YgdGlja3MsIG5vdCBqdXN0IHRoZSBkcmF3aW5nLlxuXG5PcHRpb25zIGxlZnQgdG8gbWFrZSBheGlzLWZyaWVuZGx5LlxuICAoJ2RyYXdBeGVzQXRaZXJvJylcbiAgKCd4QXhpc0hlaWdodCcpXG4qL1xuXG4vKipcbiAqIERyYXdzIHRoZSBheGVzLiBUaGlzIGluY2x1ZGVzIHRoZSBsYWJlbHMgb24gdGhlIHgtIGFuZCB5LWF4ZXMsIGFzIHdlbGxcbiAqIGFzIHRoZSB0aWNrIG1hcmtzIG9uIHRoZSBheGVzLlxuICogSXQgZG9lcyBfbm90XyBkcmF3IHRoZSBncmlkIGxpbmVzIHdoaWNoIHNwYW4gdGhlIGVudGlyZSBjaGFydC5cbiAqL1xudmFyIGF4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ0F4ZXMgUGx1Z2luJztcbn07XG5cbmF4ZXMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24oZykge1xuICByZXR1cm4ge1xuICAgIGxheW91dDogdGhpcy5sYXlvdXQsXG4gICAgY2xlYXJDaGFydDogdGhpcy5jbGVhckNoYXJ0LFxuICAgIHdpbGxEcmF3Q2hhcnQ6IHRoaXMud2lsbERyYXdDaGFydFxuICB9O1xufTtcblxuYXhlcy5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5JykpIHtcbiAgICB2YXIgdyA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsV2lkdGgnLCAneScpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3knKTtcbiAgICBlLnJlc2VydmVTcGFjZUxlZnQodyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd4JykpIHtcbiAgICB2YXIgaDtcbiAgICAvLyBOT1RFOiBJIHRoaW5rIHRoaXMgaXMgcHJvYmFibHkgYnJva2VuIG5vdywgc2luY2UgZy5nZXRPcHRpb24oKSBub3dcbiAgICAvLyBoaXRzIHRoZSBkaWN0aW9uYXJ5LiAoVGhhdCBpcywgZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0Jykgbm93IGFsd2F5c1xuICAgIC8vIGhhcyBhIHZhbHVlLilcbiAgICBpZiAoZy5nZXRPcHRpb24oJ3hBeGlzSGVpZ2h0JykpIHtcbiAgICAgIGggPSBnLmdldE9wdGlvbigneEF4aXNIZWlnaHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCAneCcpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3gnKTtcbiAgICB9XG4gICAgZS5yZXNlcnZlU3BhY2VCb3R0b20oaCk7XG4gIH1cblxuICBpZiAoZy5udW1BeGVzKCkgPT0gMikge1xuICAgIGlmIChnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3kyJykpIHtcbiAgICAgIHZhciB3ID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxXaWR0aCcsICd5MicpICsgMiAqIGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc1RpY2tTaXplJywgJ3kyJyk7XG4gICAgICBlLnJlc2VydmVTcGFjZVJpZ2h0KHcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnLm51bUF4ZXMoKSA+IDIpIHtcbiAgICBnLmVycm9yKCdPbmx5IHR3byB5LWF4ZXMgYXJlIHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUuIChUcnlpbmcgJyArXG4gICAgICAgICAgICAndG8gdXNlICcgKyBnLm51bUF4ZXMoKSArICcpJyk7XG4gIH1cbn07XG5cbmF4ZXMucHJvdG90eXBlLmRldGFjaExhYmVscyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiByZW1vdmVBcnJheShhcnkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gYXJ5W2ldO1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFycmF5KHRoaXMueGxhYmVsc18pO1xuICByZW1vdmVBcnJheSh0aGlzLnlsYWJlbHNfKTtcbiAgdGhpcy54bGFiZWxzXyA9IFtdO1xuICB0aGlzLnlsYWJlbHNfID0gW107XG59O1xuXG5heGVzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLmRldGFjaExhYmVscygpO1xufTtcblxuYXhlcy5wcm90b3R5cGUud2lsbERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGcgPSBlLmR5Z3JhcGg7XG5cbiAgaWYgKCFnLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSAmJlxuICAgICAgIWcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpICYmXG4gICAgICAhZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3QXhpcycsICd5MicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUm91bmQgcGl4ZWxzIHRvIGhhbGYtaW50ZWdlciBib3VuZGFyaWVzIGZvciBjcmlzcGVyIGRyYXdpbmcuXG4gIGZ1bmN0aW9uIGhhbGZVcCh4KSAgeyByZXR1cm4gTWF0aC5yb3VuZCh4KSArIDAuNTsgfVxuICBmdW5jdGlvbiBoYWxmRG93bih5KXsgcmV0dXJuIE1hdGgucm91bmQoeSkgLSAwLjU7IH1cblxuICB2YXIgY29udGV4dCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBjb250YWluZXJEaXYgPSBlLmNhbnZhcy5wYXJlbnROb2RlO1xuICB2YXIgY2FudmFzV2lkdGggPSBnLndpZHRoXzsgIC8vIGUuY2FudmFzLndpZHRoIGlzIGFmZmVjdGVkIGJ5IHBpeGVsIHJhdGlvLlxuICB2YXIgY2FudmFzSGVpZ2h0ID0gZy5oZWlnaHRfO1xuXG4gIHZhciBsYWJlbCwgeCwgeSwgdGljaywgaTtcblxuICB2YXIgbWFrZUxhYmVsU3R5bGUgPSBmdW5jdGlvbihheGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgZm9udFNpemU6IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsRm9udFNpemUnLCBheGlzKSArICdweCcsXG4gICAgICB6SW5kZXg6IDEwLFxuICAgICAgY29sb3I6IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xhYmVsQ29sb3InLCBheGlzKSxcbiAgICAgIHdpZHRoOiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgYXhpcykgKyAncHgnLFxuICAgICAgLy8gaGVpZ2h0OiBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbEZvbnRTaXplJywgJ3gnKSArIDIgKyBcInB4XCIsXG4gICAgICBsaW5lSGVpZ2h0OiAnbm9ybWFsJywgIC8vIFNvbWV0aGluZyBvdGhlciB0aGFuIFwibm9ybWFsXCIgbGluZS1oZWlnaHQgc2NyZXdzIHVwIGxhYmVsIHBvc2l0aW9uaW5nLlxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGFiZWxTdHlsZXMgPSB7XG4gICAgeCA6IG1ha2VMYWJlbFN0eWxlKCd4JyksXG4gICAgeSA6IG1ha2VMYWJlbFN0eWxlKCd5JyksXG4gICAgeTIgOiBtYWtlTGFiZWxTdHlsZSgneTInKVxuICB9O1xuXG4gIHZhciBtYWtlRGl2ID0gZnVuY3Rpb24odHh0LCBheGlzLCBwcmVjX2F4aXMpIHtcbiAgICAvKlxuICAgICAqIFRoaXMgc2VlbXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyB0aHJlZSBzZXRzIG9mIGF4aXMvcHJlY19heGlzOlxuICAgICAqIHg6IHVuZGVmaW5lZFxuICAgICAqIHk6IHkxXG4gICAgICogeTogeTJcbiAgICAgKi9cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBsYWJlbFN0eWxlc1twcmVjX2F4aXMgPT0gJ3kyJyA/ICd5MicgOiBheGlzXTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGxhYmVsU3R5bGUpIHtcbiAgICAgIGlmIChsYWJlbFN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGRpdi5zdHlsZVtuYW1lXSA9IGxhYmVsU3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbm5lcl9kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lcl9kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtYXhpcy1sYWJlbCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnIGR5Z3JhcGgtYXhpcy1sYWJlbC0nICsgYXhpcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVjX2F4aXMgPyAnIGR5Z3JhcGgtYXhpcy1sYWJlbC0nICsgcHJlY19heGlzIDogJycpO1xuICAgIGlubmVyX2Rpdi5pbm5lckhUTUwgPSB0eHQ7XG4gICAgZGl2LmFwcGVuZENoaWxkKGlubmVyX2Rpdik7XG4gICAgcmV0dXJuIGRpdjtcbiAgfTtcblxuICAvLyBheGlzIGxpbmVzXG4gIGNvbnRleHQuc2F2ZSgpO1xuXG4gIHZhciBsYXlvdXQgPSBnLmxheW91dF87XG4gIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG5cbiAgLy8gSGVscGVyIGZvciByZXBlYXRlZCBheGlzLW9wdGlvbiBhY2Nlc3Nlcy5cbiAgdmFyIG1ha2VPcHRpb25HZXR0ZXIgPSBmdW5jdGlvbihheGlzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgcmV0dXJuIGcuZ2V0T3B0aW9uRm9yQXhpcyhvcHRpb24sIGF4aXMpO1xuICAgIH07XG4gIH07XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneScpKSB7XG4gICAgaWYgKGxheW91dC55dGlja3MgJiYgbGF5b3V0Lnl0aWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbnVtX2F4ZXMgPSBnLm51bUF4ZXMoKTtcbiAgICAgIHZhciBnZXRPcHRpb25zID0gW21ha2VPcHRpb25HZXR0ZXIoJ3knKSwgbWFrZU9wdGlvbkdldHRlcigneTInKV07XG4gICAgICBmb3IgKHZhciB0aWNrIG9mIGxheW91dC55dGlja3MpIHtcbiAgICAgICAgaWYgKHRpY2subGFiZWwgPT09IHVuZGVmaW5lZCkgY29udGludWU7ICAvLyB0aGlzIHRpY2sgb25seSBoYXMgYSBncmlkIGxpbmUuXG4gICAgICAgIHggPSBhcmVhLng7XG4gICAgICAgIHZhciBzZ24gPSAxO1xuICAgICAgICB2YXIgcHJlY19heGlzID0gJ3kxJztcbiAgICAgICAgdmFyIGdldEF4aXNPcHRpb24gPSBnZXRPcHRpb25zWzBdO1xuICAgICAgICBpZiAodGljay5heGlzID09IDEpIHsgIC8vIHJpZ2h0LXNpZGUgeS1heGlzXG4gICAgICAgICAgeCA9IGFyZWEueCArIGFyZWEudztcbiAgICAgICAgICBzZ24gPSAtMTtcbiAgICAgICAgICBwcmVjX2F4aXMgPSAneTInO1xuICAgICAgICAgIGdldEF4aXNPcHRpb24gPSBnZXRPcHRpb25zWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbEZvbnRTaXplJyk7XG4gICAgICAgIHkgPSBhcmVhLnkgKyB0aWNrLnBvcyAqIGFyZWEuaDtcblxuICAgICAgICAvKiBUaWNrIG1hcmtzIGFyZSBjdXJyZW50bHkgY2xpcHBlZCwgc28gZG9uJ3QgYm90aGVyIGRyYXdpbmcgdGhlbS5cbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oaGFsZlVwKHgpLCBoYWxmRG93bih5KSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGhhbGZVcCh4IC0gc2duICogdGhpcy5hdHRyXygnYXhpc1RpY2tTaXplJykpLCBoYWxmRG93bih5KSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICovXG5cbiAgICAgICAgbGFiZWwgPSBtYWtlRGl2KHRpY2subGFiZWwsICd5JywgbnVtX2F4ZXMgPT0gMiA/IHByZWNfYXhpcyA6IG51bGwpO1xuICAgICAgICB2YXIgdG9wID0gKHkgLSBmb250U2l6ZSAvIDIpO1xuICAgICAgICBpZiAodG9wIDwgMCkgdG9wID0gMDtcblxuICAgICAgICBpZiAodG9wICsgZm9udFNpemUgKyAzID4gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgbGFiZWwuc3R5bGUuYm90dG9tID0gJzAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpY2suYXhpcyA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54IC0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSAtIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICh0aWNrLmF4aXMgPT0gMSkge1xuICAgICAgICAgIGxhYmVsLnN0eWxlLmxlZnQgPSAoYXJlYS54ICsgYXJlYS53ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEF4aXNPcHRpb24oJ2F4aXNUaWNrU2l6ZScpKSArICdweCc7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSArICdweCc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMueWxhYmVsc18ucHVzaChsYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsb3dlc3QgdGljayBvbiB0aGUgeS1heGlzIG9mdGVuIG92ZXJsYXBzIHdpdGggdGhlIGxlZnRtb3N0XG4gICAgICAvLyB0aWNrIG9uIHRoZSB4LWF4aXMuIFNoaWZ0IHRoZSBib3R0b20gdGljayB1cCBhIGxpdHRsZSBiaXQgdG9cbiAgICAgIC8vIGNvbXBlbnNhdGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgdmFyIGJvdHRvbVRpY2sgPSB0aGlzLnlsYWJlbHNfWzBdO1xuICAgICAgLy8gSW50ZXJlc3RlZCBpbiB0aGUgeTIgYXhpcyBhbHNvP1xuICAgICAgdmFyIGZvbnRTaXplID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGFiZWxGb250U2l6ZScsICd5Jyk7XG4gICAgICB2YXIgYm90dG9tID0gcGFyc2VJbnQoYm90dG9tVGljay5zdHlsZS50b3AsIDEwKSArIGZvbnRTaXplO1xuICAgICAgaWYgKGJvdHRvbSA+IGNhbnZhc0hlaWdodCAtIGZvbnRTaXplKSB7XG4gICAgICAgIGJvdHRvbVRpY2suc3R5bGUudG9wID0gKHBhcnNlSW50KGJvdHRvbVRpY2suc3R5bGUudG9wLCAxMCkgLVxuICAgICAgICAgICAgZm9udFNpemUgLyAyKSArICdweCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZHJhdyBhIHZlcnRpY2FsIGxpbmUgb24gdGhlIGxlZnQgdG8gc2VwYXJhdGUgdGhlIGNoYXJ0IGZyb20gdGhlIGxhYmVscy5cbiAgICB2YXIgYXhpc1g7XG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdkcmF3QXhlc0F0WmVybycpKSB7XG4gICAgICB2YXIgciA9IGcudG9QZXJjZW50WENvb3JkKDApO1xuICAgICAgaWYgKHIgPiAxIHx8IHIgPCAwIHx8IGlzTmFOKHIpKSByID0gMDtcbiAgICAgIGF4aXNYID0gaGFsZlVwKGFyZWEueCArIHIgKiBhcmVhLncpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzWCA9IGhhbGZVcChhcmVhLngpO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lQ29sb3InLCAneScpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdheGlzTGluZVdpZHRoJywgJ3knKTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYXhpc1gsIGhhbGZEb3duKGFyZWEueSkpO1xuICAgIGNvbnRleHQubGluZVRvKGF4aXNYLCBoYWxmRG93bihhcmVhLnkgKyBhcmVhLmgpKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAvLyBpZiB0aGVyZSdzIGEgc2Vjb25kYXJ5IHktYXhpcywgZHJhdyBhIHZlcnRpY2FsIGxpbmUgZm9yIHRoYXQsIHRvby5cbiAgICBpZiAoZy5udW1BeGVzKCkgPT0gMikge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd5MicpO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneTInKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhoYWxmRG93bihhcmVhLnggKyBhcmVhLncpLCBoYWxmRG93bihhcmVhLnkpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGhhbGZEb3duKGFyZWEueCArIGFyZWEudyksIGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCkpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0F4aXMnLCAneCcpKSB7XG4gICAgaWYgKGxheW91dC54dGlja3MpIHtcbiAgICAgIHZhciBnZXRBeGlzT3B0aW9uID0gbWFrZU9wdGlvbkdldHRlcigneCcpO1xuICAgICAgZm9yICh2YXIgdGljayBvZiBsYXlvdXQueHRpY2tzKSB7XG4gICAgICAgIGlmICh0aWNrLmxhYmVsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAgLy8gdGhpcyB0aWNrIG9ubHkgaGFzIGEgZ3JpZCBsaW5lLlxuICAgICAgICB4ID0gYXJlYS54ICsgdGljay5wb3MgKiBhcmVhLnc7XG4gICAgICAgIHkgPSBhcmVhLnkgKyBhcmVhLmg7XG5cbiAgICAgICAgLyogVGljayBtYXJrcyBhcmUgY3VycmVudGx5IGNsaXBwZWQsIHNvIGRvbid0IGJvdGhlciBkcmF3aW5nIHRoZW0uXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcCh4KSwgaGFsZkRvd24oeSkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhoYWxmVXAoeCksIGhhbGZEb3duKHkgKyB0aGlzLmF0dHJfKCdheGlzVGlja1NpemUnKSkpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAqL1xuXG4gICAgICAgIGxhYmVsID0gbWFrZURpdih0aWNrLmxhYmVsLCAneCcpO1xuICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgbGFiZWwuc3R5bGUudG9wID0gKHkgKyBnZXRBeGlzT3B0aW9uKCdheGlzVGlja1NpemUnKSkgKyAncHgnO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gKHggLSBnZXRBeGlzT3B0aW9uKCdheGlzTGFiZWxXaWR0aCcpLzIpO1xuICAgICAgICBpZiAobGVmdCArIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJykgPiBjYW52YXNXaWR0aCkge1xuICAgICAgICAgIGxlZnQgPSBjYW52YXNXaWR0aCAtIGdldEF4aXNPcHRpb24oJ2F4aXNMYWJlbFdpZHRoJyk7XG4gICAgICAgICAgbGFiZWwuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICBsYWJlbC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIGxhYmVsLnN0eWxlLndpZHRoID0gZ2V0QXhpc09wdGlvbignYXhpc0xhYmVsV2lkdGgnKSArICdweCc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHRoaXMueGxhYmVsc18ucHVzaChsYWJlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnYXhpc0xpbmVDb2xvcicsICd4Jyk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBnLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMaW5lV2lkdGgnLCAneCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIGF4aXNZO1xuICAgIGlmIChnLmdldE9wdGlvbignZHJhd0F4ZXNBdFplcm8nKSkge1xuICAgICAgdmFyIHIgPSBnLnRvUGVyY2VudFlDb29yZCgwLCAwKTtcbiAgICAgIGlmIChyID4gMSB8fCByIDwgMCkgciA9IDE7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIHIgKiBhcmVhLmgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzWSA9IGhhbGZEb3duKGFyZWEueSArIGFyZWEuaCk7XG4gICAgfVxuICAgIGNvbnRleHQubW92ZVRvKGhhbGZVcChhcmVhLngpLCBheGlzWSk7XG4gICAgY29udGV4dC5saW5lVG8oaGFsZlVwKGFyZWEueCArIGFyZWEudyksIGF4aXNZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGF4ZXM7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPKGRhbnZrKTogbW92ZSBjaGFydCBsYWJlbCBvcHRpb25zIG91dCBvZiBkeWdyYXBocyBhbmQgaW50byB0aGUgcGx1Z2luLlxuLy8gVE9ETyhkYW52ayk6IG9ubHkgdGVhciBkb3duICYgcmVidWlsZCB0aGUgRElWcyB3aGVuIGl0J3MgbmVjZXNzYXJ5LlxuXG52YXIgY2hhcnRfbGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJDaGFydExhYmVscyBQbHVnaW5cIjtcbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihnKSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiB0aGlzLmxheW91dCxcbiAgICAvLyBjbGVhckNoYXJ0OiB0aGlzLmNsZWFyQ2hhcnQsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gUVVFU1RJT046IHNob3VsZCB0aGVyZSBiZSBhIHBsdWdpbi11dGlscy5qcz9cbnZhciBjcmVhdGVEaXZJblJlY3QgPSBmdW5jdGlvbihyKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZGl2LnN0eWxlLmxlZnQgPSByLnggKyAncHgnO1xuICBkaXYuc3R5bGUudG9wID0gci55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gci53ICsgJ3B4JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9IHIuaCArICdweCc7XG4gIHJldHVybiBkaXY7XG59O1xuXG4vLyBEZXRhY2ggYW5kIG51bGwgb3V0IGFueSBleGlzdGluZyBub2Rlcy5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGV0YWNoTGFiZWxzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxzID0gWyB0aGlzLnRpdGxlX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueGxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueWxhYmVsX2Rpdl8sXG4gICAgICAgICAgICAgIHRoaXMueTJsYWJlbF9kaXZfIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gZWxzW2ldO1xuICAgIGlmICghZWwpIGNvbnRpbnVlO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIHRoaXMudGl0bGVfZGl2XyA9IG51bGw7XG4gIHRoaXMueGxhYmVsX2Rpdl8gPSBudWxsO1xuICB0aGlzLnlsYWJlbF9kaXZfID0gbnVsbDtcbiAgdGhpcy55MmxhYmVsX2Rpdl8gPSBudWxsO1xufTtcblxudmFyIGNyZWF0ZVJvdGF0ZWREaXYgPSBmdW5jdGlvbihnLCBib3gsIGF4aXMsIGNsYXNzZXMsIGh0bWwpIHtcbiAgLy8gVE9ETyhkYW52ayk6IGlzIHRoaXMgb3V0ZXIgZGl2IGFjdHVhbGx5IG5lY2Vzc2FyeT9cbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlmIChheGlzID09IDEpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGNoZWF0aW5nLiBTaG91bGQgYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgYm94LlxuICAgIGRpdi5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIH0gZWxzZSB7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBib3gueCArICdweCc7XG4gIH1cbiAgZGl2LnN0eWxlLnRvcCA9IGJveC55ICsgJ3B4JztcbiAgZGl2LnN0eWxlLndpZHRoID0gYm94LncgKyAncHgnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gYm94LmggKyAncHgnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAoZy5nZXRPcHRpb24oJ3lMYWJlbFdpZHRoJykgLSAyKSArICdweCc7XG5cbiAgdmFyIGlubmVyX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlubmVyX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGlubmVyX2Rpdi5zdHlsZS53aWR0aCA9IGJveC5oICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmhlaWdodCA9IGJveC53ICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLnRvcCA9IChib3guaCAvIDIgLSBib3gudyAvIDIpICsgJ3B4JztcbiAgaW5uZXJfZGl2LnN0eWxlLmxlZnQgPSAoYm94LncgLyAyIC0gYm94LmggLyAyKSArICdweCc7XG4gIGlubmVyX2Rpdi5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcblxuICAvLyBDU1Mgcm90YXRpb24gaXMgYW4gSFRNTDUgZmVhdHVyZSB3aGljaCBpcyBub3Qgc3RhbmRhcmRpemVkLiBIZW5jZSBldmVyeVxuICAvLyBicm93c2VyIGhhcyBpdHMgb3duIG5hbWUgZm9yIHRoZSBDU1Mgc3R5bGUuXG4gIHZhciB2YWwgPSAncm90YXRlKCcgKyAoYXhpcyA9PSAxID8gJy0nIDogJycpICsgJzkwZGVnKSc7XG4gIGlubmVyX2Rpdi5zdHlsZS50cmFuc2Zvcm0gPSB2YWw7ICAgICAgICAvLyBIVE1MNVxuICBpbm5lcl9kaXYuc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gdmFsOyAgLy8gU2FmYXJpL0Nocm9tZVxuICBpbm5lcl9kaXYuc3R5bGUuTW96VHJhbnNmb3JtID0gdmFsOyAgICAgLy8gRmlyZWZveFxuICBpbm5lcl9kaXYuc3R5bGUuT1RyYW5zZm9ybSA9IHZhbDsgICAgICAgLy8gT3BlcmFcbiAgaW5uZXJfZGl2LnN0eWxlLm1zVHJhbnNmb3JtID0gdmFsOyAgICAgIC8vIElFOVxuXG4gIHZhciBjbGFzc19kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjbGFzc19kaXYuY2xhc3NOYW1lID0gY2xhc3NlcztcbiAgY2xhc3NfZGl2LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgaW5uZXJfZGl2LmFwcGVuZENoaWxkKGNsYXNzX2Rpdik7XG4gIGRpdi5hcHBlbmRDaGlsZChpbm5lcl9kaXYpO1xuICByZXR1cm4gZGl2O1xufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbihlKSB7XG4gIHRoaXMuZGV0YWNoTGFiZWxzXygpO1xuXG4gIHZhciBnID0gZS5keWdyYXBoO1xuICB2YXIgZGl2ID0gZS5jaGFydF9kaXY7XG4gIGlmIChnLmdldE9wdGlvbigndGl0bGUnKSkge1xuICAgIC8vIFFVRVNUSU9OOiBzaG91bGQgdGhpcyByZXR1cm4gYW4gYWJzb2x1dGVseS1wb3NpdGlvbmVkIGRpdiBpbnN0ZWFkP1xuICAgIHZhciB0aXRsZV9yZWN0ID0gZS5yZXNlcnZlU3BhY2VUb3AoZy5nZXRPcHRpb24oJ3RpdGxlSGVpZ2h0JykpO1xuICAgIHRoaXMudGl0bGVfZGl2XyA9IGNyZWF0ZURpdkluUmVjdCh0aXRsZV9yZWN0KTtcbiAgICB0aGlzLnRpdGxlX2Rpdl8uc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgdGhpcy50aXRsZV9kaXZfLnN0eWxlLmZvbnRTaXplID0gKGcuZ2V0T3B0aW9uKCd0aXRsZUhlaWdodCcpIC0gOCkgKyAncHgnO1xuICAgIHRoaXMudGl0bGVfZGl2Xy5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgIHRoaXMudGl0bGVfZGl2Xy5zdHlsZS56SW5kZXggPSAxMDtcblxuICAgIHZhciBjbGFzc19kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNsYXNzX2Rpdi5jbGFzc05hbWUgPSAnZHlncmFwaC1sYWJlbCBkeWdyYXBoLXRpdGxlJztcbiAgICBjbGFzc19kaXYuaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3RpdGxlJyk7XG4gICAgdGhpcy50aXRsZV9kaXZfLmFwcGVuZENoaWxkKGNsYXNzX2Rpdik7XG4gICAgZGl2LmFwcGVuZENoaWxkKHRoaXMudGl0bGVfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3hsYWJlbCcpKSB7XG4gICAgdmFyIHhfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlQm90dG9tKGcuZ2V0T3B0aW9uKCd4TGFiZWxIZWlnaHQnKSk7XG4gICAgdGhpcy54bGFiZWxfZGl2XyA9IGNyZWF0ZURpdkluUmVjdCh4X3JlY3QpO1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5zdHlsZS5mb250U2l6ZSA9IChnLmdldE9wdGlvbigneExhYmVsSGVpZ2h0JykgLSAyKSArICdweCc7XG5cbiAgICB2YXIgY2xhc3NfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjbGFzc19kaXYuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtbGFiZWwgZHlncmFwaC14bGFiZWwnO1xuICAgIGNsYXNzX2Rpdi5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneGxhYmVsJyk7XG4gICAgdGhpcy54bGFiZWxfZGl2Xy5hcHBlbmRDaGlsZChjbGFzc19kaXYpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnhsYWJlbF9kaXZfKTtcbiAgfVxuXG4gIGlmIChnLmdldE9wdGlvbigneWxhYmVsJykpIHtcbiAgICAvLyBJdCB3b3VsZCBtYWtlIHNlbnNlIHRvIHNoaWZ0IHRoZSBjaGFydCBoZXJlIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIHktYXhpc1xuICAgIC8vIGxhYmVsLCBidXQgdGhlIGRlZmF1bHQgeUF4aXNMYWJlbFdpZHRoIGlzIGxhcmdlIGVub3VnaCB0aGF0IHRoaXMgcmVzdWx0c1xuICAgIC8vIGluIG92ZXJseS1wYWRkZWQgY2hhcnRzLiBUaGUgeS1heGlzIGxhYmVsIHNob3VsZCBmaXQgZmluZS4gSWYgaXRcbiAgICAvLyBkb2Vzbid0LCB0aGUgeUF4aXNMYWJlbFdpZHRoIG9wdGlvbiBjYW4gYmUgaW5jcmVhc2VkLlxuICAgIHZhciB5X3JlY3QgPSBlLnJlc2VydmVTcGFjZUxlZnQoMCk7XG5cbiAgICB0aGlzLnlsYWJlbF9kaXZfID0gY3JlYXRlUm90YXRlZERpdihcbiAgICAgICAgZywgeV9yZWN0LFxuICAgICAgICAxLCAgLy8gcHJpbWFyeSAobGVmdCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteWxhYmVsJyxcbiAgICAgICAgZy5nZXRPcHRpb24oJ3lsYWJlbCcpKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy55bGFiZWxfZGl2Xyk7XG4gIH1cblxuICBpZiAoZy5nZXRPcHRpb24oJ3kybGFiZWwnKSAmJiBnLm51bUF4ZXMoKSA9PSAyKSB7XG4gICAgLy8gc2FtZSBsb2dpYyBhcHBsaWVzIGhlcmUgYXMgZm9yIHlsYWJlbC5cbiAgICB2YXIgeTJfcmVjdCA9IGUucmVzZXJ2ZVNwYWNlUmlnaHQoMCk7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8gPSBjcmVhdGVSb3RhdGVkRGl2KFxuICAgICAgICBnLCB5Ml9yZWN0LFxuICAgICAgICAyLCAgLy8gc2Vjb25kYXJ5IChyaWdodCkgeS1heGlzXG4gICAgICAgICdkeWdyYXBoLWxhYmVsIGR5Z3JhcGgteTJsYWJlbCcsXG4gICAgICAgIGcuZ2V0T3B0aW9uKCd5MmxhYmVsJykpO1xuICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLnkybGFiZWxfZGl2Xyk7XG4gIH1cbn07XG5cbmNoYXJ0X2xhYmVscy5wcm90b3R5cGUuZGlkRHJhd0NoYXJ0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgaWYgKHRoaXMudGl0bGVfZGl2Xykge1xuICAgIHRoaXMudGl0bGVfZGl2Xy5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigndGl0bGUnKTtcbiAgfVxuICBpZiAodGhpcy54bGFiZWxfZGl2Xykge1xuICAgIHRoaXMueGxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3hsYWJlbCcpO1xuICB9XG4gIGlmICh0aGlzLnlsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55bGFiZWxfZGl2Xy5jaGlsZHJlblswXS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBnLmdldE9wdGlvbigneWxhYmVsJyk7XG4gIH1cbiAgaWYgKHRoaXMueTJsYWJlbF9kaXZfKSB7XG4gICAgdGhpcy55MmxhYmVsX2Rpdl8uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gZy5nZXRPcHRpb24oJ3kybGFiZWwnKTtcbiAgfVxufTtcblxuY2hhcnRfbGFiZWxzLnByb3RvdHlwZS5jbGVhckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5jaGFydF9sYWJlbHMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZXRhY2hMYWJlbHNfKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjaGFydF9sYWJlbHM7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMiBEYW4gVmFuZGVya2FtIChkYW52ZGtAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlICovXG5cbi8qXG5cbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIERpcmVjdCBsYXlvdXQgYWNjZXNzXG4tIERpcmVjdCBhcmVhIGFjY2Vzc1xuXG4qL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERyYXdzIHRoZSBncmlkbGluZXMsIGkuZS4gdGhlIGdyYXkgaG9yaXpvbnRhbCAmIHZlcnRpY2FsIGxpbmVzIHJ1bm5pbmcgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGNoYXJ0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgZ3JpZCA9IGZ1bmN0aW9uKCkge1xufTtcblxuZ3JpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiR3JpZGxpbmUgUGx1Z2luXCI7XG59O1xuXG5ncmlkLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWxsRHJhd0NoYXJ0OiB0aGlzLndpbGxEcmF3Q2hhcnRcbiAgfTtcbn07XG5cbmdyaWQucHJvdG90eXBlLndpbGxEcmF3Q2hhcnQgPSBmdW5jdGlvbihlKSB7XG4gIC8vIERyYXcgdGhlIG5ldyBYL1kgZ3JpZC4gTGluZXMgYXBwZWFyIGNyaXNwZXIgd2hlbiBwaXhlbHMgYXJlIHJvdW5kZWQgdG9cbiAgLy8gaGFsZi1pbnRlZ2Vycy4gVGhpcyBwcmV2ZW50cyB0aGVtIGZyb20gZHJhd2luZyBpbiB0d28gcm93cy9jb2xzLlxuICB2YXIgZyA9IGUuZHlncmFwaDtcbiAgdmFyIGN0eCA9IGUuZHJhd2luZ0NvbnRleHQ7XG4gIHZhciBsYXlvdXQgPSBnLmxheW91dF87XG4gIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG5cbiAgZnVuY3Rpb24gaGFsZlVwKHgpICB7IHJldHVybiBNYXRoLnJvdW5kKHgpICsgMC41OyB9XG4gIGZ1bmN0aW9uIGhhbGZEb3duKHkpeyByZXR1cm4gTWF0aC5yb3VuZCh5KSAtIDAuNTsgfVxuXG4gIHZhciB4LCB5LCBpLCB0aWNrcztcbiAgaWYgKGcuZ2V0T3B0aW9uRm9yQXhpcygnZHJhd0dyaWQnLCAneScpKSB7XG4gICAgdmFyIGF4ZXMgPSBbXCJ5XCIsIFwieTJcIl07XG4gICAgdmFyIHN0cm9rZVN0eWxlcyA9IFtdLCBsaW5lV2lkdGhzID0gW10sIGRyYXdHcmlkID0gW10sIHN0cm9raW5nID0gW10sIHN0cm9rZVBhdHRlcm4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRyYXdHcmlkW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsIGF4ZXNbaV0pO1xuICAgICAgaWYgKGRyYXdHcmlkW2ldKSB7XG4gICAgICAgIHN0cm9rZVN0eWxlc1tpXSA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVDb2xvcicsIGF4ZXNbaV0pO1xuICAgICAgICBsaW5lV2lkdGhzW2ldID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgYXhlc1tpXSk7XG4gICAgICAgIHN0cm9rZVBhdHRlcm5baV0gPSBnLmdldE9wdGlvbkZvckF4aXMoJ2dyaWRMaW5lUGF0dGVybicsIGF4ZXNbaV0pO1xuICAgICAgICBzdHJva2luZ1tpXSA9IHN0cm9rZVBhdHRlcm5baV0gJiYgKHN0cm9rZVBhdHRlcm5baV0ubGVuZ3RoID49IDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aWNrcyA9IGxheW91dC55dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICAvLyBkcmF3IGdyaWRzIGZvciB0aGUgZGlmZmVyZW50IHkgYXhlc1xuICAgIGZvciAodmFyIHRpY2sgb2YgdGlja3MpIHtcbiAgICAgIGlmICghdGljay5oYXNfdGljaykgY29udGludWU7XG4gICAgICB2YXIgYXhpcyA9IHRpY2suYXhpcztcbiAgICAgIGlmIChkcmF3R3JpZFtheGlzXSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAoc3Ryb2tpbmdbYXhpc10pIHtcbiAgICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoKSBjdHguc2V0TGluZURhc2goc3Ryb2tlUGF0dGVybltheGlzXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVzW2F4aXNdO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoc1theGlzXTtcblxuICAgICAgICB4ID0gaGFsZlVwKGFyZWEueCk7XG4gICAgICAgIHkgPSBoYWxmRG93bihhcmVhLnkgKyB0aWNrLnBvcyAqIGFyZWEuaCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgYXJlYS53LCB5KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvLyBkcmF3IGdyaWQgZm9yIHggYXhpc1xuICBpZiAoZy5nZXRPcHRpb25Gb3JBeGlzKCdkcmF3R3JpZCcsICd4JykpIHtcbiAgICB0aWNrcyA9IGxheW91dC54dGlja3M7XG4gICAgY3R4LnNhdmUoKTtcbiAgICB2YXIgc3Ryb2tlUGF0dGVybiA9IGcuZ2V0T3B0aW9uRm9yQXhpcygnZ3JpZExpbmVQYXR0ZXJuJywgJ3gnKTtcbiAgICB2YXIgc3Ryb2tpbmcgPSBzdHJva2VQYXR0ZXJuICYmIChzdHJva2VQYXR0ZXJuLmxlbmd0aCA+PSAyKTtcbiAgICBpZiAoc3Ryb2tpbmcpIHtcbiAgICAgIGlmIChjdHguc2V0TGluZURhc2gpIGN0eC5zZXRMaW5lRGFzaChzdHJva2VQYXR0ZXJuKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZUNvbG9yJywgJ3gnKTtcbiAgICBjdHgubGluZVdpZHRoID0gZy5nZXRPcHRpb25Gb3JBeGlzKCdncmlkTGluZVdpZHRoJywgJ3gnKTtcbiAgICBmb3IgKHZhciB0aWNrIG9mIHRpY2tzKSB7XG4gICAgICBpZiAoIXRpY2suaGFzX3RpY2spIGNvbnRpbnVlO1xuICAgICAgeCA9IGhhbGZVcChhcmVhLnggKyB0aWNrLnBvcyAqIGFyZWEudyk7XG4gICAgICB5ID0gaGFsZkRvd24oYXJlYS55ICsgYXJlYS5oKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHgsIGFyZWEueSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmIChzdHJva2luZykge1xuICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCkgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcblxuZ3JpZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ3JpZDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDEyIERhbiBWYW5kZXJrYW0gKGRhbnZka0BnbWFpbC5jb20pXG4gKiBNSVQtbGljZW5zZWQgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gKi9cbi8qZ2xvYmFsIER5Z3JhcGg6ZmFsc2UgKi9cblxuLypcbkN1cnJlbnQgYml0cyBvZiBqYW5raW5lc3M6XG4tIFVzZXMgdHdvIHByaXZhdGUgQVBJczpcbiAgICAxLiBEeWdyYXBoLm9wdGlvbnNWaWV3Rm9yQXhpc19cbiAgICAyLiBkeWdyYXBoLnBsb3R0ZXJfLmFyZWFcbi0gUmVnaXN0ZXJzIGZvciBhIFwicHJlZHJhd1wiIGV2ZW50LCB3aGljaCBzaG91bGQgYmUgcmVuYW1lZC5cbi0gSSBjYWxsIGNhbGN1bGF0ZUVtV2lkdGhJbkRpdiBtb3JlIG9mdGVuIHRoYW4gbmVlZGVkLlxuKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgbGVnZW5kLCB3aGljaCBhcHBlYXJzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIGNoYXJ0LlxuICogVGhlIGxlZ2VuZCBjYW4gYmUgZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgb3IgZ2VuZXJhdGVkIGRpdi5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExlZ2VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxlZ2VuZF9kaXZfID0gbnVsbDtcbiAgdGhpcy5pc19nZW5lcmF0ZWRfZGl2XyA9IGZhbHNlOyAgLy8gZG8gd2Ugb3duIHRoaXMgZGl2LCBvciB3YXMgaXQgdXNlci1zcGVjaWZpZWQ/XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIkxlZ2VuZCBQbHVnaW5cIjtcbn07XG5cbi8vIChkZWZpbmVkIGJlbG93KVxudmFyIGdlbmVyYXRlTGVnZW5kRGFzaEhUTUw7XG5cbi8qKlxuICogVGhpcyBpcyBjYWxsZWQgZHVyaW5nIHRoZSBkeWdyYXBoIGNvbnN0cnVjdG9yLCBhZnRlciBvcHRpb25zIGhhdmUgYmVlbiBzZXRcbiAqIGJ1dCBiZWZvcmUgdGhlIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIFByb3BlciB0YXNrcyB0byBkbyBoZXJlIGluY2x1ZGU6XG4gKiAtIFJlYWRpbmcgeW91ciBvd24gb3B0aW9uc1xuICogLSBET00gbWFuaXB1bGF0aW9uXG4gKiAtIFJlZ2lzdGVyaW5nIGV2ZW50IGxpc3RlbmVyc1xuICpcbiAqIEBwYXJhbSB7RHlncmFwaH0gZyBHcmFwaCBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge29iamVjdC48c3RyaW5nLCBmdW5jdGlvbihldik+fSBNYXBwaW5nIG9mIGV2ZW50IG5hbWVzIHRvIGNhbGxiYWNrcy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgdmFyIGRpdjtcbiAgdmFyIGRpdldpZHRoID0gZy5nZXRPcHRpb24oJ2xhYmVsc0RpdldpZHRoJyk7XG5cbiAgdmFyIHVzZXJMYWJlbHNEaXYgPSBnLmdldE9wdGlvbignbGFiZWxzRGl2Jyk7XG4gIGlmICh1c2VyTGFiZWxzRGl2ICYmIG51bGwgIT09IHVzZXJMYWJlbHNEaXYpIHtcbiAgICBpZiAodHlwZW9mKHVzZXJMYWJlbHNEaXYpID09IFwic3RyaW5nXCIgfHwgdXNlckxhYmVsc0RpdiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodXNlckxhYmVsc0Rpdik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdiA9IHVzZXJMYWJlbHNEaXY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgbGVnZW5kIHN0eWxlcy4gVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gaW4gQ1NTIGJ5IGFkZGluZ1xuICAgIC8vIFwiIWltcG9ydGFudFwiIGFmdGVyIHlvdXIgcnVsZSwgZS5nLiBcImxlZnQ6IDMwcHggIWltcG9ydGFudDtcIlxuICAgIHZhciBtZXNzYWdlc3R5bGUgPSB7XG4gICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcbiAgICAgIFwiZm9udFNpemVcIjogXCIxNHB4XCIsXG4gICAgICBcInpJbmRleFwiOiAxMCxcbiAgICAgIFwid2lkdGhcIjogZGl2V2lkdGggKyBcInB4XCIsXG4gICAgICBcInRvcFwiOiBcIjBweFwiLFxuICAgICAgXCJsZWZ0XCI6IChnLnNpemUoKS53aWR0aCAtIGRpdldpZHRoIC0gMikgKyBcInB4XCIsXG4gICAgICBcImJhY2tncm91bmRcIjogXCJ3aGl0ZVwiLFxuICAgICAgXCJsaW5lSGVpZ2h0XCI6IFwibm9ybWFsXCIsXG4gICAgICBcInRleHRBbGlnblwiOiBcImxlZnRcIixcbiAgICAgIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIn07XG5cbiAgICAvLyBUT0RPKGRhbnZrKTogZ2V0IHJpZCBvZiBsYWJlbHNEaXZTdHlsZXM/IENTUyBpcyBiZXR0ZXIuXG4gICAgdXRpbHMudXBkYXRlKG1lc3NhZ2VzdHlsZSwgZy5nZXRPcHRpb24oJ2xhYmVsc0RpdlN0eWxlcycpKTtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcImR5Z3JhcGgtbGVnZW5kXCI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtZXNzYWdlc3R5bGUpIHtcbiAgICAgIGlmICghbWVzc2FnZXN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZGl2LnN0eWxlW25hbWVdID0gbWVzc2FnZXN0eWxlW25hbWVdO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgYXJlIHVzaW5nIHVuc3VwcG9ydGVkIGNzcyBwcm9wZXJ0aWVzIGZvciB5b3VyIFwiICtcbiAgICAgICAgICAgIFwiYnJvd3NlciBpbiBsYWJlbHNEaXZTdHlsZXNcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhkYW52ayk6IGNvbWUgdXAgd2l0aCBhIGNsZWFuZXIgd2F5IHRvIGV4cG9zZSB0aGlzLlxuICAgIGcuZ3JhcGhEaXYuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLmlzX2dlbmVyYXRlZF9kaXZfID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBkaXY7XG4gIHRoaXMub25lX2VtX3dpZHRoXyA9IDEwOyAgLy8ganVzdCBhIGd1ZXNzLCB3aWxsIGJlIHVwZGF0ZWQuXG5cbiAgcmV0dXJuIHtcbiAgICBzZWxlY3Q6IHRoaXMuc2VsZWN0LFxuICAgIGRlc2VsZWN0OiB0aGlzLmRlc2VsZWN0LFxuICAgIC8vIFRPRE8oZGFudmspOiByZXRoaW5rIHRoZSBuYW1lIFwicHJlZHJhd1wiIGJlZm9yZSB3ZSBjb21taXQgdG8gaXQgaW4gYW55IEFQSS5cbiAgICBwcmVkcmF3OiB0aGlzLnByZWRyYXcsXG4gICAgZGlkRHJhd0NoYXJ0OiB0aGlzLmRpZERyYXdDaGFydFxuICB9O1xufTtcblxuLy8gTmVlZGVkIGZvciBkYXNoZWQgbGluZXMuXG52YXIgY2FsY3VsYXRlRW1XaWR0aEluRGl2ID0gZnVuY3Rpb24oZGl2KSB7XG4gIHZhciBzaXplU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgc2l6ZVNwYW4uc2V0QXR0cmlidXRlKCdzdHlsZScsICdtYXJnaW46IDA7IHBhZGRpbmc6IDAgMCAwIDFlbTsgYm9yZGVyOiAwOycpO1xuICBkaXYuYXBwZW5kQ2hpbGQoc2l6ZVNwYW4pO1xuICB2YXIgb25lRW1XaWR0aD1zaXplU3Bhbi5vZmZzZXRXaWR0aDtcbiAgZGl2LnJlbW92ZUNoaWxkKHNpemVTcGFuKTtcbiAgcmV0dXJuIG9uZUVtV2lkdGg7XG59O1xuXG52YXIgZXNjYXBlSFRNTCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbn07XG5cbkxlZ2VuZC5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oZSkge1xuICB2YXIgeFZhbHVlID0gZS5zZWxlY3RlZFg7XG4gIHZhciBwb2ludHMgPSBlLnNlbGVjdGVkUG9pbnRzO1xuICB2YXIgcm93ID0gZS5zZWxlY3RlZFJvdztcblxuICB2YXIgbGVnZW5kTW9kZSA9IGUuZHlncmFwaC5nZXRPcHRpb24oJ2xlZ2VuZCcpO1xuICBpZiAobGVnZW5kTW9kZSA9PT0gJ25ldmVyJykge1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobGVnZW5kTW9kZSA9PT0gJ2ZvbGxvdycpIHtcbiAgICAvLyBjcmVhdGUgZmxvYXRpbmcgbGVnZW5kIGRpdlxuICAgIHZhciBhcmVhID0gZS5keWdyYXBoLnBsb3R0ZXJfLmFyZWE7XG4gICAgdmFyIGxhYmVsc0RpdldpZHRoID0gZS5keWdyYXBoLmdldE9wdGlvbignbGFiZWxzRGl2V2lkdGgnKTtcbiAgICB2YXIgeUF4aXNMYWJlbFdpZHRoID0gZS5keWdyYXBoLmdldE9wdGlvbkZvckF4aXMoJ2F4aXNMYWJlbFdpZHRoJywgJ3knKTtcbiAgICAvLyBkZXRlcm1pbmUgZmxvYXRpbmcgW2xlZnQsIHRvcF0gY29vcmRpbmF0ZXMgb2YgdGhlIGxlZ2VuZCBkaXZcbiAgICAvLyB3aXRoaW4gdGhlIHBsb3R0ZXJfIGFyZWFcbiAgICAvLyBvZmZzZXQgNTAgcHggdG8gdGhlIHJpZ2h0IGFuZCBkb3duIGZyb20gdGhlIGZpcnN0IHNlbGVjdGlvbiBwb2ludFxuICAgIC8vIDUwIHB4IGlzIGd1ZXNzIGJhc2VkIG9uIG1vdXNlIGN1cnNvciBzaXplXG4gICAgdmFyIGxlZnRMZWdlbmQgPSBwb2ludHNbMF0ueCAqIGFyZWEudyArIDUwO1xuICAgIHZhciB0b3BMZWdlbmQgID0gcG9pbnRzWzBdLnkgKiBhcmVhLmggLSA1MDtcblxuICAgIC8vIGlmIGxlZ2VuZCBmbG9hdHMgdG8gZW5kIG9mIHRoZSBjaGFydCBhcmVhLCBpdCBmbGlwcyB0byB0aGUgb3RoZXJcbiAgICAvLyBzaWRlIG9mIHRoZSBzZWxlY3Rpb24gcG9pbnRcbiAgICBpZiAoKGxlZnRMZWdlbmQgKyBsYWJlbHNEaXZXaWR0aCArIDEpID4gYXJlYS53KSB7XG4gICAgICBsZWZ0TGVnZW5kID0gbGVmdExlZ2VuZCAtIDIgKiA1MCAtIGxhYmVsc0RpdldpZHRoIC0gKHlBeGlzTGFiZWxXaWR0aCAtIGFyZWEueCk7XG4gICAgfVxuXG4gICAgZS5keWdyYXBoLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMubGVnZW5kX2Rpdl8pO1xuICAgIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUubGVmdCA9IHlBeGlzTGFiZWxXaWR0aCArIGxlZnRMZWdlbmQgKyBcInB4XCI7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS50b3AgPSB0b3BMZWdlbmQgKyBcInB4XCI7XG4gIH1cblxuICB2YXIgaHRtbCA9IExlZ2VuZC5nZW5lcmF0ZUxlZ2VuZEhUTUwoZS5keWdyYXBoLCB4VmFsdWUsIHBvaW50cywgdGhpcy5vbmVfZW1fd2lkdGhfLCByb3cpO1xuICB0aGlzLmxlZ2VuZF9kaXZfLmlubmVySFRNTCA9IGh0bWw7XG4gIHRoaXMubGVnZW5kX2Rpdl8uc3R5bGUuZGlzcGxheSA9ICcnO1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdmFyIGxlZ2VuZE1vZGUgPSBlLmR5Z3JhcGguZ2V0T3B0aW9uKCdsZWdlbmQnKTtcbiAgaWYgKGxlZ2VuZE1vZGUgIT09ICdhbHdheXMnKSB7XG4gICAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH1cblxuICAvLyBIYXZlIHRvIGRvIHRoaXMgZXZlcnkgdGltZSwgc2luY2Ugc3R5bGVzIG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgdmFyIG9uZUVtV2lkdGggPSBjYWxjdWxhdGVFbVdpZHRoSW5EaXYodGhpcy5sZWdlbmRfZGl2Xyk7XG4gIHRoaXMub25lX2VtX3dpZHRoXyA9IG9uZUVtV2lkdGg7XG5cbiAgdmFyIGh0bWwgPSBMZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MKGUuZHlncmFwaCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9uZUVtV2lkdGgsIG51bGwpO1xuICB0aGlzLmxlZ2VuZF9kaXZfLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLmRpZERyYXdDaGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5kZXNlbGVjdChlKTtcbn07XG5cbi8vIFJpZ2h0IGVkZ2Ugc2hvdWxkIGJlIGZsdXNoIHdpdGggdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0aW5nIGFyZWEgKHdoaWNoXG4vLyBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSByaWdodCBlZGdlIG9mIHRoZSBkaXYsIGlmIHdlIGhhdmUgdHdvIHktYXhlcy5cbi8vIFRPRE8oZGFudmspOiBpcyBhbnkgb2YgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBDb3VsZCBqdXN0IHNldCBcInJpZ2h0XCIgaW4gXCJhY3RpdmF0ZVwiLlxuLyoqXG4gKiBQb3NpdGlvbiB0aGUgbGFiZWxzIGRpdiBzbyB0aGF0OlxuICogLSBpdHMgcmlnaHQgZWRnZSBpcyBmbHVzaCB3aXRoIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydGluZyBhcmVhXG4gKiAtIGl0cyB0b3AgZWRnZSBpcyBmbHVzaCB3aXRoIHRoZSB0b3AgZWRnZSBvZiB0aGUgY2hhcnRpbmcgYXJlYVxuICogQHByaXZhdGVcbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5wcmVkcmF3ID0gZnVuY3Rpb24oZSkge1xuICAvLyBEb24ndCB0b3VjaCBhIHVzZXItc3BlY2lmaWVkIGxhYmVsc0Rpdi5cbiAgaWYgKCF0aGlzLmlzX2dlbmVyYXRlZF9kaXZfKSByZXR1cm47XG5cbiAgLy8gVE9ETyhkYW52ayk6IG9ubHkgdXNlIHJlYWwgQVBJcyBmb3IgdGhpcy5cbiAgZS5keWdyYXBoLmdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMubGVnZW5kX2Rpdl8pO1xuICB2YXIgYXJlYSA9IGUuZHlncmFwaC5nZXRBcmVhKCk7XG4gIHZhciBsYWJlbHNEaXZXaWR0aCA9IGUuZHlncmFwaC5nZXRPcHRpb24oXCJsYWJlbHNEaXZXaWR0aFwiKTtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS5sZWZ0ID0gYXJlYS54ICsgYXJlYS53IC0gbGFiZWxzRGl2V2lkdGggLSAxICsgXCJweFwiO1xuICB0aGlzLmxlZ2VuZF9kaXZfLnN0eWxlLnRvcCA9IGFyZWEueSArIFwicHhcIjtcbiAgdGhpcy5sZWdlbmRfZGl2Xy5zdHlsZS53aWR0aCA9IGxhYmVsc0RpdldpZHRoICsgXCJweFwiO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBkeWdyYXBoLmRlc3Ryb3koKSBpcyBjYWxsZWQuXG4gKiBZb3Ugc2hvdWxkIG51bGwgb3V0IGFueSByZWZlcmVuY2VzIGFuZCBkZXRhY2ggYW55IERPTSBlbGVtZW50cy5cbiAqL1xuTGVnZW5kLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubGVnZW5kX2Rpdl8gPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmb3IgdGhlIGxlZ2VuZCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoZVxuICogY2hhcnQuIElmIG5vIHNlbGVjdGVkIHBvaW50cyBhcmUgc3BlY2lmaWVkLCBhIGRlZmF1bHQgbGVnZW5kIGlzIHJldHVybmVkXG4gKiAodGhpcyBtYXkganVzdCBiZSB0aGUgZW1wdHkgc3RyaW5nKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4LXZhbHVlIG9mIHRoZSBzZWxlY3RlZCBwb2ludHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsX3BvaW50cyBMaXN0IG9mIHNlbGVjdGVkIHBvaW50cyBmb3IgdGhlIGdpdmVuXG4gKiAgIHgtdmFsdWUuIFNob3VsZCBoYXZlIHByb3BlcnRpZXMgbGlrZSAnbmFtZScsICd5dmFsJyBhbmQgJ2NhbnZhc3knLlxuICogQHBhcmFtIHtudW1iZXJ9IG9uZUVtV2lkdGggVGhlIHBpeGVsIHdpZHRoIGZvciAxZW0gaW4gdGhlIGxlZ2VuZC4gT25seVxuICogICByZWxldmFudCB3aGVuIGRpc3BsYXlpbmcgYSBsZWdlbmQgd2l0aCBubyBzZWxlY3Rpb24gKGkuZS4ge2xlZ2VuZDpcbiAqICAgJ2Fsd2F5cyd9KSBhbmQgd2l0aCBkYXNoZWQgbGluZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcm93IFRoZSBzZWxlY3RlZCByb3cgaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5MZWdlbmQuZ2VuZXJhdGVMZWdlbmRIVE1MID0gZnVuY3Rpb24oZywgeCwgc2VsX3BvaW50cywgb25lRW1XaWR0aCwgcm93KSB7XG4gIC8vIERhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiB0byBwYXNzIHRvIGxlZ2VuZEZvcm1hdHRlclxuICB2YXIgZGF0YSA9IHtcbiAgICBkeWdyYXBoOiBnLFxuICAgIHg6IHgsXG4gICAgc2VyaWVzOiBbXVxuICB9O1xuXG4gIHZhciBsYWJlbFRvU2VyaWVzID0ge307XG4gIHZhciBsYWJlbHMgPSBnLmdldExhYmVscygpO1xuICBpZiAobGFiZWxzKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZXJpZXMgPSBnLmdldFByb3BlcnRpZXNGb3JTZXJpZXMobGFiZWxzW2ldKTtcbiAgICAgIHZhciBzdHJva2VQYXR0ZXJuID0gZy5nZXRPcHRpb24oJ3N0cm9rZVBhdHRlcm4nLCBsYWJlbHNbaV0pO1xuICAgICAgdmFyIHNlcmllc0RhdGEgPSB7XG4gICAgICAgIGRhc2hIVE1MOiBnZW5lcmF0ZUxlZ2VuZERhc2hIVE1MKHN0cm9rZVBhdHRlcm4sIHNlcmllcy5jb2xvciwgb25lRW1XaWR0aCksXG4gICAgICAgIGxhYmVsOiBsYWJlbHNbaV0sXG4gICAgICAgIGxhYmVsSFRNTDogZXNjYXBlSFRNTChsYWJlbHNbaV0pLFxuICAgICAgICBpc1Zpc2libGU6IHNlcmllcy52aXNpYmxlLFxuICAgICAgICBjb2xvcjogc2VyaWVzLmNvbG9yXG4gICAgICB9O1xuXG4gICAgICBkYXRhLnNlcmllcy5wdXNoKHNlcmllc0RhdGEpO1xuICAgICAgbGFiZWxUb1Nlcmllc1tsYWJlbHNbaV1dID0gc2VyaWVzRGF0YTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mKHgpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB4T3B0VmlldyA9IGcub3B0aW9uc1ZpZXdGb3JBeGlzXygneCcpO1xuICAgIHZhciB4dmYgPSB4T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICBkYXRhLnhIVE1MID0geHZmLmNhbGwoZywgeCwgeE9wdFZpZXcsIGxhYmVsc1swXSwgZywgcm93LCAwKTtcblxuICAgIHZhciB5T3B0Vmlld3MgPSBbXTtcbiAgICB2YXIgbnVtX2F4ZXMgPSBnLm51bUF4ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9heGVzOyBpKyspIHtcbiAgICAgIC8vIFRPRE8oZGFudmspOiByZW1vdmUgdGhpcyB1c2Ugb2YgYSBwcml2YXRlIEFQSVxuICAgICAgeU9wdFZpZXdzW2ldID0gZy5vcHRpb25zVmlld0ZvckF4aXNfKCd5JyArIChpID8gMSArIGkgOiAnJykpO1xuICAgIH1cblxuICAgIHZhciBzaG93WmVyb3MgPSBnLmdldE9wdGlvbignbGFiZWxzU2hvd1plcm9WYWx1ZXMnKTtcbiAgICB2YXIgaGlnaGxpZ2h0U2VyaWVzID0gZy5nZXRIaWdobGlnaHRTZXJpZXMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gc2VsX3BvaW50c1tpXTtcbiAgICAgIHZhciBzZXJpZXNEYXRhID0gbGFiZWxUb1Nlcmllc1twdC5uYW1lXTtcbiAgICAgIHNlcmllc0RhdGEueSA9IHB0Lnl2YWw7XG5cbiAgICAgIGlmICgocHQueXZhbCA9PT0gMCAmJiAhc2hvd1plcm9zKSB8fCBpc05hTihwdC5jYW52YXN5KSkge1xuICAgICAgICBzZXJpZXNEYXRhLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmllcyA9IGcuZ2V0UHJvcGVydGllc0ZvclNlcmllcyhwdC5uYW1lKTtcbiAgICAgIHZhciB5T3B0VmlldyA9IHlPcHRWaWV3c1tzZXJpZXMuYXhpcyAtIDFdO1xuICAgICAgdmFyIGZtdEZ1bmMgPSB5T3B0VmlldygndmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgIHZhciB5SFRNTCA9IGZtdEZ1bmMuY2FsbChnLCBwdC55dmFsLCB5T3B0VmlldywgcHQubmFtZSwgZywgcm93LCBsYWJlbHMuaW5kZXhPZihwdC5uYW1lKSk7XG5cbiAgICAgIHV0aWxzLnVwZGF0ZShzZXJpZXNEYXRhLCB7eUhUTUx9KTtcblxuICAgICAgaWYgKHB0Lm5hbWUgPT0gaGlnaGxpZ2h0U2VyaWVzKSB7XG4gICAgICAgIHNlcmllc0RhdGEuaXNIaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvcm1hdHRlciA9IChnLmdldE9wdGlvbignbGVnZW5kRm9ybWF0dGVyJykgfHwgTGVnZW5kLmRlZmF1bHRGb3JtYXR0ZXIpO1xuICByZXR1cm4gZm9ybWF0dGVyLmNhbGwoZywgZGF0YSk7XG59XG5cbkxlZ2VuZC5kZWZhdWx0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgZyA9IGRhdGEuZHlncmFwaDtcblxuICAvLyBUT0RPKGRhbnZrKTogZGVwcmVjYXRlIHRoaXMgb3B0aW9uIGluIHBsYWNlIG9mIHtsZWdlbmQ6ICduZXZlcid9XG4gIC8vIFhYWCBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbiB0aGUgZm9ybWF0dGVyP1xuICBpZiAoZy5nZXRPcHRpb24oJ3Nob3dMYWJlbHNPbkhpZ2hsaWdodCcpICE9PSB0cnVlKSByZXR1cm4gJyc7XG5cbiAgdmFyIHNlcExpbmVzID0gZy5nZXRPcHRpb24oJ2xhYmVsc1NlcGFyYXRlTGluZXMnKTtcbiAgdmFyIGh0bWw7XG5cbiAgaWYgKHR5cGVvZihkYXRhLngpID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRPRE86IHRoaXMgY2hlY2sgaXMgZHVwbGljYXRlZCBpbiBnZW5lcmF0ZUxlZ2VuZEhUTUwuIFB1dCBpdCBpbiBvbmUgcGxhY2UuXG4gICAgaWYgKGcuZ2V0T3B0aW9uKCdsZWdlbmQnKSAhPSAnYWx3YXlzJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGh0bWwgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VyaWVzID0gZGF0YS5zZXJpZXNbaV07XG4gICAgICBpZiAoIXNlcmllcy5pc1Zpc2libGUpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoaHRtbCAhPT0gJycpIGh0bWwgKz0gKHNlcExpbmVzID8gJzxici8+JyA6ICcgJyk7XG4gICAgICBodG1sICs9IGA8c3BhbiBzdHlsZT0nZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiAke3Nlcmllcy5jb2xvcn07Jz4ke3Nlcmllcy5kYXNoSFRNTH0gJHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj5gO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGh0bWwgPSBkYXRhLnhIVE1MICsgJzonO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlcmllcyA9IGRhdGEuc2VyaWVzW2ldO1xuICAgIGlmICghc2VyaWVzLmlzVmlzaWJsZSkgY29udGludWU7XG4gICAgaWYgKHNlcExpbmVzKSBodG1sICs9ICc8YnI+JztcbiAgICB2YXIgY2xzID0gc2VyaWVzLmlzSGlnaGxpZ2h0ZWQgPyAnIGNsYXNzPVwiaGlnaGxpZ2h0XCInIDogJyc7XG4gICAgaHRtbCArPSBgPHNwYW4ke2Nsc30+IDxiPjxzcGFuIHN0eWxlPSdjb2xvcjogJHtzZXJpZXMuY29sb3J9Oyc+JHtzZXJpZXMubGFiZWxIVE1MfTwvc3Bhbj48L2I+OiYjMTYwOyR7c2VyaWVzLnlIVE1MfTwvc3Bhbj5gO1xuICB9XG4gIHJldHVybiBodG1sO1xufTtcblxuXG4vKipcbiAqIEdlbmVyYXRlcyBodG1sIGZvciB0aGUgXCJkYXNoXCIgZGlzcGxheWVkIG9uIHRoZSBsZWdlbmQgd2hlbiB1c2luZyBcImxlZ2VuZDogYWx3YXlzXCIuXG4gKiBJbiBwYXJ0aWN1bGFyLCB0aGlzIHdvcmtzIGZvciBkYXNoZWQgbGluZXMgd2l0aCBhbnkgc3Ryb2tlIHBhdHRlcm4uIEl0IHdpbGxcbiAqIHRyeSB0byBzY2FsZSB0aGUgcGF0dGVybiB0byBmaXQgaW4gMWVtIHdpZHRoLiBPciBpZiBzbWFsbCBlbm91Z2ggcmVwZWF0IHRoZVxuICogcGF0dGVybiBmb3IgMWVtIHdpZHRoLlxuICpcbiAqIEBwYXJhbSBzdHJva2VQYXR0ZXJuIFRoZSBwYXR0ZXJuXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBzZXJpZXMuXG4gKiBAcGFyYW0gb25lRW1XaWR0aCBUaGUgd2lkdGggaW4gcGl4ZWxzIG9mIDFlbSBpbiB0aGUgbGVnZW5kLlxuICogQHByaXZhdGVcbiAqL1xuLy8gVE9ETyhkYW52ayk6IGNhY2hlIHRoZSByZXN1bHRzIG9mIHRoaXNcbmdlbmVyYXRlTGVnZW5kRGFzaEhUTUwgPSBmdW5jdGlvbihzdHJva2VQYXR0ZXJuLCBjb2xvciwgb25lRW1XaWR0aCkge1xuICAvLyBFYXN5LCBjb21tb24gY2FzZTogYSBzb2xpZCBsaW5lXG4gIGlmICghc3Ryb2tlUGF0dGVybiB8fCBzdHJva2VQYXR0ZXJuLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBzdHlsZT1cXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IFwiICtcbiAgICBcImJvdHRvbTogLjVleDsgcGFkZGluZy1sZWZ0OiAxZW07IGhlaWdodDogMXB4OyBcIiArXG4gICAgXCJib3JkZXItYm90dG9tOiAycHggc29saWQgXCIgKyBjb2xvciArIFwiO1xcXCI+PC9kaXY+XCI7XG4gIH1cblxuICB2YXIgaSwgaiwgcGFkZGluZ0xlZnQsIG1hcmdpblJpZ2h0O1xuICB2YXIgc3Ryb2tlUGl4ZWxMZW5ndGggPSAwLCBzZWdtZW50TG9vcCA9IDA7XG4gIHZhciBub3JtYWxpemVkUGF0dGVybiA9IFtdO1xuICB2YXIgbG9vcDtcblxuICAvLyBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHBpeGVscyBpbmNsdWRpbmcgdGhlIGZpcnN0IHNlZ21lbnQgdHdpY2UsIFxuICAvLyBzaW5jZSB3ZSByZXBlYXQgaXQuXG4gIGZvciAoaSA9IDA7IGkgPD0gc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHN0cm9rZVBpeGVsTGVuZ3RoICs9IHN0cm9rZVBhdHRlcm5baSVzdHJva2VQYXR0ZXJuLmxlbmd0aF07XG4gIH1cblxuICAvLyBTZWUgaWYgd2UgY2FuIGxvb3AgdGhlIHBhdHRlcm4gYnkgaXRzZWxmIGF0IGxlYXN0IHR3aWNlLlxuICBsb29wID0gTWF0aC5mbG9vcihvbmVFbVdpZHRoLyhzdHJva2VQaXhlbExlbmd0aC1zdHJva2VQYXR0ZXJuWzBdKSk7XG4gIGlmIChsb29wID4gMSkge1xuICAgIC8vIFRoaXMgcGF0dGVybiBmaXRzIGF0IGxlYXN0IHR3byB0aW1lcywgbm8gc2NhbGluZyBqdXN0IGNvbnZlcnQgdG8gZW07XG4gICAgZm9yIChpID0gMDsgaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXR0ZXJuW2ldID0gc3Ryb2tlUGF0dGVybltpXS9vbmVFbVdpZHRoO1xuICAgIH1cbiAgICAvLyBTaW5jZSB3ZSBhcmUgcmVwZWF0aW5nIHRoZSBwYXR0ZXJuLCB3ZSBkb24ndCB3b3JyeSBhYm91dCByZXBlYXRpbmcgdGhlXG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpbiBvbmUgZHJhdy5cbiAgICBzZWdtZW50TG9vcCA9IG5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBkb2Vzbid0IGZpdCBpbiB0aGUgbGVnZW5kIHdlIHNjYWxlIGl0IHRvIGZpdC5cbiAgICBsb29wID0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Ryb2tlUGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFBhdHRlcm5baV0gPSBzdHJva2VQYXR0ZXJuW2ldL3N0cm9rZVBpeGVsTGVuZ3RoO1xuICAgIH1cbiAgICAvLyBGb3IgdGhlIHNjYWxlZCBwYXR0ZXJucyB3ZSBkbyByZWRyYXcgdGhlIGZpcnN0IHNlZ21lbnQuXG4gICAgc2VnbWVudExvb3AgPSBub3JtYWxpemVkUGF0dGVybi5sZW5ndGgrMTtcbiAgfVxuXG4gIC8vIE5vdyBtYWtlIHRoZSBwYXR0ZXJuLlxuICB2YXIgZGFzaCA9IFwiXCI7XG4gIGZvciAoaiA9IDA7IGogPCBsb29wOyBqKyspIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudExvb3A7IGkrPTIpIHtcbiAgICAgIC8vIFRoZSBwYWRkaW5nIGlzIHRoZSBkcmF3biBzZWdtZW50LlxuICAgICAgcGFkZGluZ0xlZnQgPSBub3JtYWxpemVkUGF0dGVybltpJW5vcm1hbGl6ZWRQYXR0ZXJuLmxlbmd0aF07XG4gICAgICBpZiAoaSA8IHN0cm9rZVBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFRoZSBtYXJnaW4gaXMgdGhlIHNwYWNlIHNlZ21lbnQuXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gbm9ybWFsaXplZFBhdHRlcm5bKGkrMSklbm9ybWFsaXplZFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSByZXBlYXRlZCBmaXJzdCBzZWdtZW50IGhhcyBubyByaWdodCBtYXJnaW4uXG4gICAgICAgIG1hcmdpblJpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGRhc2ggKz0gXCI8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBvc2l0aW9uOiByZWxhdGl2ZTsgXCIgK1xuICAgICAgICBcImJvdHRvbTogLjVleDsgbWFyZ2luLXJpZ2h0OiBcIiArIG1hcmdpblJpZ2h0ICsgXCJlbTsgcGFkZGluZy1sZWZ0OiBcIiArXG4gICAgICAgIHBhZGRpbmdMZWZ0ICsgXCJlbTsgaGVpZ2h0OiAxcHg7IGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBcIiArIGNvbG9yICtcbiAgICAgICAgXCI7XFxcIj48L2Rpdj5cIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhc2g7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMZWdlbmQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMSBQYXVsIEZlbGl4IChwYXVsLmVyaWMuZmVsaXhAZ21haWwuY29tKVxuICogTUlULWxpY2Vuc2VkIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICovXG4vKmdsb2JhbCBEeWdyYXBoOmZhbHNlLFRvdWNoRXZlbnQ6ZmFsc2UgKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSBjb250YWlucyB0aGUgUmFuZ2VTZWxlY3RvciBwbHVnaW4gdXNlZCB0byBwcm92aWRlXG4gKiBhIHRpbWVsaW5lIHJhbmdlIHNlbGVjdG9yIHdpZGdldCBmb3IgZHlncmFwaHMuXG4gKi9cblxuLypnbG9iYWwgRHlncmFwaDpmYWxzZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL2R5Z3JhcGgtdXRpbHMnO1xuaW1wb3J0IER5Z3JhcGhJbnRlcmFjdGlvbiBmcm9tICcuLi9keWdyYXBoLWludGVyYWN0aW9uLW1vZGVsJztcbmltcG9ydCBJRnJhbWVUYXJwIGZyb20gJy4uL2lmcmFtZS10YXJwJztcblxudmFyIHJhbmdlU2VsZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYXNUb3VjaEludGVyZmFjZV8gPSB0eXBlb2YoVG91Y2hFdmVudCkgIT0gJ3VuZGVmaW5lZCc7XG4gIHRoaXMuaXNNb2JpbGVEZXZpY2VfID0gL21vYmlsZXxhbmRyb2lkL2dpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pO1xuICB0aGlzLmludGVyZmFjZUNyZWF0ZWRfID0gZmFsc2U7XG59O1xuXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJSYW5nZVNlbGVjdG9yIFBsdWdpblwiO1xufTtcblxucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbihkeWdyYXBoKSB7XG4gIHRoaXMuZHlncmFwaF8gPSBkeWdyYXBoO1xuICBpZiAodGhpcy5nZXRPcHRpb25fKCdzaG93UmFuZ2VTZWxlY3RvcicpKSB7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VfKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IHRoaXMucmVzZXJ2ZVNwYWNlXyxcbiAgICBwcmVkcmF3OiB0aGlzLnJlbmRlclN0YXRpY0xheWVyXyxcbiAgICBkaWREcmF3Q2hhcnQ6IHRoaXMucmVuZGVySW50ZXJhY3RpdmVMYXllcl9cbiAgfTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iZ2NhbnZhc18gPSBudWxsO1xuICB0aGlzLmZnY2FudmFzXyA9IG51bGw7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfID0gbnVsbDtcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfID0gbnVsbDtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlIG1ldGhvZHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldE9wdGlvbl8gPSBmdW5jdGlvbihuYW1lLCBvcHRfc2VyaWVzKSB7XG4gIHJldHVybiB0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbihuYW1lLCBvcHRfc2VyaWVzKTtcbn07XG5cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNldERlZmF1bHRPcHRpb25fID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5keWdyYXBoXy5hdHRyc19bbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIHJhbmdlIHNlbGVjdG9yIGVsZW1lbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGdyYXBoLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVJbnRlcmZhY2VfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlQ2FudmFzZXNfKCk7XG4gIHRoaXMuY3JlYXRlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuaW5pdEludGVyYWN0aW9uXygpO1xuXG4gIC8vIFJhbmdlIHNlbGVjdG9yIGFuZCBhbmltYXRlZFpvb21zIGhhdmUgYSBiYWQgaW50ZXJhY3Rpb24uIFNlZSBpc3N1ZSAzNTkuXG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ2FuaW1hdGVkWm9vbXMnKSkge1xuICAgIGNvbnNvbGUud2FybignQW5pbWF0ZWQgem9vbXMgYW5kIHJhbmdlIHNlbGVjdG9yIGFyZSBub3QgY29tcGF0aWJsZTsgZGlzYWJsaW5nIGFuaW1hdGVkWm9vbXMuJyk7XG4gICAgdGhpcy5keWdyYXBoXy51cGRhdGVPcHRpb25zKHthbmltYXRlZFpvb21zOiBmYWxzZX0sIHRydWUpO1xuICB9XG5cbiAgdGhpcy5pbnRlcmZhY2VDcmVhdGVkXyA9IHRydWU7XG4gIHRoaXMuYWRkVG9HcmFwaF8oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEFkZHMgdGhlIHJhbmdlIHNlbGVjdG9yIHRvIHRoZSBncmFwaC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl8gPSB0aGlzLmR5Z3JhcGhfLmdyYXBoRGl2O1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLmJnY2FudmFzXyk7XG4gIGdyYXBoRGl2LmFwcGVuZENoaWxkKHRoaXMuZmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYuYXBwZW5kQ2hpbGQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8pO1xuICBncmFwaERpdi5hcHBlbmRDaGlsZCh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVtb3ZlcyB0aGUgcmFuZ2Ugc2VsZWN0b3IgZnJvbSB0aGUgZ3JhcGguXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbW92ZUZyb21HcmFwaF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdyYXBoRGl2ID0gdGhpcy5ncmFwaERpdl87XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMuYmdjYW52YXNfKTtcbiAgZ3JhcGhEaXYucmVtb3ZlQ2hpbGQodGhpcy5mZ2NhbnZhc18pO1xuICBncmFwaERpdi5yZW1vdmVDaGlsZCh0aGlzLmxlZnRab29tSGFuZGxlXyk7XG4gIGdyYXBoRGl2LnJlbW92ZUNoaWxkKHRoaXMucmlnaHRab29tSGFuZGxlXyk7XG4gIHRoaXMuZ3JhcGhEaXZfID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENhbGxlZCBieSBMYXlvdXQgdG8gYWxsb3cgcmFuZ2Ugc2VsZWN0b3IgdG8gcmVzZXJ2ZSBpdHMgc3BhY2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlc2VydmVTcGFjZV8gPSBmdW5jdGlvbihlKSB7XG4gIGlmICh0aGlzLmdldE9wdGlvbl8oJ3Nob3dSYW5nZVNlbGVjdG9yJykpIHtcbiAgICBlLnJlc2VydmVTcGFjZUJvdHRvbSh0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JIZWlnaHQnKSArIDQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBzdGF0aWMgcG9ydGlvbiBvZiB0aGUgcmFuZ2Ugc2VsZWN0b3IgYXQgdGhlIHByZWRyYXcgc3RhZ2UuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlclN0YXRpY0xheWVyXyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudXBkYXRlVmlzaWJpbGl0eV8oKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlc2l6ZV8oKTtcbiAgdGhpcy5kcmF3U3RhdGljTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZW5kZXJzIHRoZSBpbnRlcmFjdGl2ZSBwb3J0aW9uIG9mIHRoZSByYW5nZSBzZWxlY3RvciBhZnRlciB0aGUgY2hhcnQgaGFzIGJlZW4gZHJhd24uXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlckludGVyYWN0aXZlTGF5ZXJfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy51cGRhdGVWaXNpYmlsaXR5XygpIHx8IHRoaXMuaXNDaGFuZ2luZ1JhbmdlXykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnBsYWNlWm9vbUhhbmRsZXNfKCk7XG4gIHRoaXMuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIHJhbmdlIHNlbGVjdG9yIGlzIGVuYWJsZWQvZGlzYWJsZWQgYW5kIHVwZGF0ZSB2aXNpYmlsaXR5IGFjY29yZGluZ2x5LlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS51cGRhdGVWaXNpYmlsaXR5XyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5hYmxlZCA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd1JhbmdlU2VsZWN0b3InKTtcbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJmYWNlQ3JlYXRlZF8pIHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJmYWNlXygpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhEaXZfIHx8ICF0aGlzLmdyYXBoRGl2Xy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmFkZFRvR3JhcGhfKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuZ3JhcGhEaXZfKSB7XG4gICAgdGhpcy5yZW1vdmVGcm9tR3JhcGhfKCk7XG4gICAgdmFyIGR5Z3JhcGggPSB0aGlzLmR5Z3JhcGhfO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGR5Z3JhcGgud2lkdGhfID0gMDsgZHlncmFwaC5yZXNpemUoKTsgfSwgMSk7XG4gIH1cbiAgcmV0dXJuIGVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZXNpemVzIHRoZSByYW5nZSBzZWxlY3Rvci5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUucmVzaXplXyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzZXRFbGVtZW50UmVjdChjYW52YXMsIGNvbnRleHQsIHJlY3QpIHtcbiAgICB2YXIgY2FudmFzU2NhbGUgPSB1dGlscy5nZXRDb250ZXh0UGl4ZWxSYXRpbyhjb250ZXh0KTtcblxuICAgIGNhbnZhcy5zdHlsZS50b3AgPSByZWN0LnkgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gcmVjdC54ICsgJ3B4JztcbiAgICBjYW52YXMud2lkdGggPSByZWN0LncgKiBjYW52YXNTY2FsZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcmVjdC5oICogY2FudmFzU2NhbGU7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gcmVjdC53ICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gcmVjdC5oICsgJ3B4JztcblxuICAgIGlmKGNhbnZhc1NjYWxlICE9IDEpIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoY2FudmFzU2NhbGUsIGNhbnZhc1NjYWxlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxvdEFyZWEgPSB0aGlzLmR5Z3JhcGhfLmxheW91dF8uZ2V0UGxvdEFyZWEoKTtcblxuICB2YXIgeEF4aXNMYWJlbEhlaWdodCA9IDA7XG4gIGlmICh0aGlzLmR5Z3JhcGhfLmdldE9wdGlvbkZvckF4aXMoJ2RyYXdBeGlzJywgJ3gnKSkge1xuICAgIHhBeGlzTGFiZWxIZWlnaHQgPSB0aGlzLmdldE9wdGlvbl8oJ3hBeGlzSGVpZ2h0JykgfHwgKHRoaXMuZ2V0T3B0aW9uXygnYXhpc0xhYmVsRm9udFNpemUnKSArIDIgKiB0aGlzLmdldE9wdGlvbl8oJ2F4aXNUaWNrU2l6ZScpKTtcbiAgfVxuICB0aGlzLmNhbnZhc1JlY3RfID0ge1xuICAgIHg6IHBsb3RBcmVhLngsXG4gICAgeTogcGxvdEFyZWEueSArIHBsb3RBcmVhLmggKyB4QXhpc0xhYmVsSGVpZ2h0ICsgNCxcbiAgICB3OiBwbG90QXJlYS53LFxuICAgIGg6IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvckhlaWdodCcpXG4gIH07XG5cbiAgc2V0RWxlbWVudFJlY3QodGhpcy5iZ2NhbnZhc18sIHRoaXMuYmdjYW52YXNfY3R4XywgdGhpcy5jYW52YXNSZWN0Xyk7XG4gIHNldEVsZW1lbnRSZWN0KHRoaXMuZmdjYW52YXNfLCB0aGlzLmZnY2FudmFzX2N0eF8sIHRoaXMuY2FudmFzUmVjdF8pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ3JlYXRlcyB0aGUgYmFja2dyb3VuZCBhbmQgZm9yZWdyb3VuZCBjYW52YXNlcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlQ2FudmFzZXNfID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYmdjYW52YXNfID0gdXRpbHMuY3JlYXRlQ2FudmFzKCk7XG4gIHRoaXMuYmdjYW52YXNfLmNsYXNzTmFtZSA9ICdkeWdyYXBoLXJhbmdlc2VsLWJnY2FudmFzJztcbiAgdGhpcy5iZ2NhbnZhc18uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0aGlzLmJnY2FudmFzXy5zdHlsZS56SW5kZXggPSA5O1xuICB0aGlzLmJnY2FudmFzX2N0eF8gPSB1dGlscy5nZXRDb250ZXh0KHRoaXMuYmdjYW52YXNfKTtcblxuICB0aGlzLmZnY2FudmFzXyA9IHV0aWxzLmNyZWF0ZUNhbnZhcygpO1xuICB0aGlzLmZnY2FudmFzXy5jbGFzc05hbWUgPSAnZHlncmFwaC1yYW5nZXNlbC1mZ2NhbnZhcyc7XG4gIHRoaXMuZmdjYW52YXNfLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgdGhpcy5mZ2NhbnZhc18uc3R5bGUuekluZGV4ID0gOTtcbiAgdGhpcy5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICB0aGlzLmZnY2FudmFzX2N0eF8gPSB1dGlscy5nZXRDb250ZXh0KHRoaXMuZmdjYW52YXNfKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENyZWF0ZXMgdGhlIHpvb20gaGFuZGxlIGVsZW1lbnRzLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jcmVhdGVab29tSGFuZGxlc18gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICBpbWcuY2xhc3NOYW1lID0gJ2R5Z3JhcGgtcmFuZ2VzZWwtem9vbWhhbmRsZSc7XG4gIGltZy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGltZy5zdHlsZS56SW5kZXggPSAxMDtcbiAgaW1nLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsgLy8gSW5pdGlhbGx5IGhpZGRlbiBzbyB0aGV5IGRvbid0IHNob3cgdXAgaW4gdGhlIHdyb25nIHBsYWNlLlxuICBpbWcuc3R5bGUuY3Vyc29yID0gJ2NvbC1yZXNpemUnO1xuICAvLyBUT0RPOiBjaGFuZ2UgaW1hZ2UgdG8gbW9yZSBvcHRpb25zXG4gIGltZy53aWR0aCA9IDk7XG4gIGltZy5oZWlnaHQgPSAxNjtcbiAgaW1nLnNyYyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsJyArXG4naVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQVFDQVlBQUFERVNGVkRBQUFBQVhOU1IwSUFyczRjNlFBQUFBWmlTMGRFQU5BQScgK1xuJ3p3RFA0WjdLZWdBQUFBbHdTRmx6QUFBT3hBQUFEc1FCbFNzT0d3QUFBQWQwU1UxRkI5c0hHdzBjTXFkdDFVd0FBQUFaZEVWWWRFTnYnICtcbidiVzFsYm5RQVEzSmxZWFJsWkNCM2FYUm9JRWRKVFZCWGdRNFhBQUFBYUVsRVFWUW96KzNTc1JGQVFCQ0Y0WjlXSk04S0NEVndvd25sJyArXG4nNllYc1RtQ1VzeUtHa1p6Y2w3emt6M1lMa3lwZ0FucmVGbURFcEhrSXdWT01mcGRpOUNFRU4ybkdwRmR3RDAzeUVxRHRPZ0NhdW43cycgK1xuJ3FTVERIMzJJMXBRQTJQYjlzWmVjQXhjNXIzSUFiMjFkNjg3OHhzQUFBQUFBU1VWT1JLNUNZSUk9JztcblxuICBpZiAodGhpcy5pc01vYmlsZURldmljZV8pIHtcbiAgICBpbWcud2lkdGggKj0gMjtcbiAgICBpbWcuaGVpZ2h0ICo9IDI7XG4gIH1cblxuICB0aGlzLmxlZnRab29tSGFuZGxlXyA9IGltZztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfID0gaW1nLmNsb25lTm9kZShmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBTZXRzIHVwIHRoZSBpbnRlcmFjdGlvbiBmb3IgdGhlIHJhbmdlIHNlbGVjdG9yLlxuICovXG5yYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5pbml0SW50ZXJhY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRvcEVsZW0gPSBkb2N1bWVudDtcbiAgdmFyIGNsaWVudFhMYXN0ID0gMDtcbiAgdmFyIGhhbmRsZSA9IG51bGw7XG4gIHZhciBpc1pvb21pbmcgPSBmYWxzZTtcbiAgdmFyIGlzUGFubmluZyA9IGZhbHNlO1xuICB2YXIgZHluYW1pYyA9ICF0aGlzLmlzTW9iaWxlRGV2aWNlXztcblxuICAvLyBXZSBjb3ZlciBpZnJhbWVzIGR1cmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNlZSBjb21tZW50cyBpblxuICAvLyBkeWdyYXBoLXV0aWxzLmpzIGZvciBtb3JlIGluZm8gb24gd2h5IHRoaXMgaXMgYSBnb29kIGlkZWEuXG4gIHZhciB0YXJwID0gbmV3IElGcmFtZVRhcnAoKTtcblxuICAvLyBmdW5jdGlvbnMsIGRlZmluZWQgYmVsb3cuICBEZWZpbmluZyB0aGVtIHRoaXMgd2F5IChyYXRoZXIgdGhhbiB3aXRoXG4gIC8vIFwiZnVuY3Rpb24gZm9vKCkgey4uLn1cIiBtYWtlcyBKU0hpbnQgaGFwcHkuXG4gIHZhciB0b1hEYXRhV2luZG93LCBvblpvb21TdGFydCwgb25ab29tLCBvblpvb21FbmQsIGRvWm9vbSwgaXNNb3VzZUluUGFuWm9uZSxcbiAgICAgIG9uUGFuU3RhcnQsIG9uUGFuLCBvblBhbkVuZCwgZG9QYW4sIG9uQ2FudmFzSG92ZXI7XG5cbiAgLy8gVG91Y2ggZXZlbnQgZnVuY3Rpb25zXG4gIHZhciBvblpvb21IYW5kbGVUb3VjaEV2ZW50LCBvbkNhbnZhc1RvdWNoRXZlbnQsIGFkZFRvdWNoRXZlbnRzO1xuXG4gIHRvWERhdGFXaW5kb3cgPSBmdW5jdGlvbih6b29tSGFuZGxlU3RhdHVzKSB7XG4gICAgdmFyIHhEYXRhTGltaXRzID0gc2VsZi5keWdyYXBoXy54QXhpc0V4dHJlbWVzKCk7XG4gICAgdmFyIGZhY3QgPSAoeERhdGFMaW1pdHNbMV0gLSB4RGF0YUxpbWl0c1swXSkvc2VsZi5jYW52YXNSZWN0Xy53O1xuICAgIHZhciB4RGF0YU1pbiA9IHhEYXRhTGltaXRzWzBdICsgKHpvb21IYW5kbGVTdGF0dXMubGVmdEhhbmRsZVBvcyAtIHNlbGYuY2FudmFzUmVjdF8ueCkqZmFjdDtcbiAgICB2YXIgeERhdGFNYXggPSB4RGF0YUxpbWl0c1swXSArICh6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gc2VsZi5jYW52YXNSZWN0Xy54KSpmYWN0O1xuICAgIHJldHVybiBbeERhdGFNaW4sIHhEYXRhTWF4XTtcbiAgfTtcblxuICBvblpvb21TdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICBpc1pvb21pbmcgPSB0cnVlO1xuICAgIGNsaWVudFhMYXN0ID0gZS5jbGllbnRYO1xuICAgIGhhbmRsZSA9IGUudGFyZ2V0ID8gZS50YXJnZXQgOiBlLnNyY0VsZW1lbnQ7XG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSByZW1vdmVkIG1hbnVhbGx5LlxuICAgICAgdXRpbHMuYWRkRXZlbnQodG9wRWxlbSwgJ21vdXNlbW92ZScsIG9uWm9vbSk7XG4gICAgICB1dGlscy5hZGRFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uWm9vbUVuZCk7XG4gICAgfVxuICAgIHNlbGYuZmdjYW52YXNfLnN0eWxlLmN1cnNvciA9ICdjb2wtcmVzaXplJztcbiAgICB0YXJwLmNvdmVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgb25ab29tID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNab29taW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuXG4gICAgdmFyIGRlbFggPSBlLmNsaWVudFggLSBjbGllbnRYTGFzdDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsWCkgPCA0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG5cbiAgICAvLyBNb3ZlIGhhbmRsZS5cbiAgICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcbiAgICB2YXIgbmV3UG9zO1xuICAgIGlmIChoYW5kbGUgPT0gc2VsZi5sZWZ0Wm9vbUhhbmRsZV8pIHtcbiAgICAgIG5ld1BvcyA9IHpvb21IYW5kbGVTdGF0dXMubGVmdEhhbmRsZVBvcyArIGRlbFg7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1pbihuZXdQb3MsIHpvb21IYW5kbGVTdGF0dXMucmlnaHRIYW5kbGVQb3MgLSBoYW5kbGUud2lkdGggLSAzKTtcbiAgICAgIG5ld1BvcyA9IE1hdGgubWF4KG5ld1Bvcywgc2VsZi5jYW52YXNSZWN0Xy54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3UG9zID0gem9vbUhhbmRsZVN0YXR1cy5yaWdodEhhbmRsZVBvcyArIGRlbFg7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1pbihuZXdQb3MsIHNlbGYuY2FudmFzUmVjdF8ueCArIHNlbGYuY2FudmFzUmVjdF8udyk7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1heChuZXdQb3MsIHpvb21IYW5kbGVTdGF0dXMubGVmdEhhbmRsZVBvcyArIGhhbmRsZS53aWR0aCArIDMpO1xuICAgIH1cbiAgICB2YXIgaGFsZkhhbmRsZVdpZHRoID0gaGFuZGxlLndpZHRoLzI7XG4gICAgaGFuZGxlLnN0eWxlLmxlZnQgPSAobmV3UG9zIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gICAgc2VsZi5kcmF3SW50ZXJhY3RpdmVMYXllcl8oKTtcblxuICAgIC8vIFpvb20gb24gdGhlIGZseS5cbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgZG9ab29tKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIG9uWm9vbUVuZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWlzWm9vbWluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1pvb21pbmcgPSBmYWxzZTtcbiAgICB0YXJwLnVuY292ZXIoKTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2Vtb3ZlJywgb25ab29tKTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uWm9vbUVuZCk7XG4gICAgc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuXG4gICAgLy8gSWYgb24gYSBzbG93ZXIgZGV2aWNlLCB6b29tIG5vdy5cbiAgICBpZiAoIWR5bmFtaWMpIHtcbiAgICAgIGRvWm9vbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBkb1pvb20gPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSBzZWxmLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSB0cnVlO1xuICAgICAgaWYgKCF6b29tSGFuZGxlU3RhdHVzLmlzWm9vbWVkKSB7XG4gICAgICAgIHNlbGYuZHlncmFwaF8ucmVzZXRab29tKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeERhdGFXaW5kb3cgPSB0b1hEYXRhV2luZG93KHpvb21IYW5kbGVTdGF0dXMpO1xuICAgICAgICBzZWxmLmR5Z3JhcGhfLmRvWm9vbVhEYXRlc18oeERhdGFXaW5kb3dbMF0sIHhEYXRhV2luZG93WzFdKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2VsZi5pc0NoYW5naW5nUmFuZ2VfID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGlzTW91c2VJblBhblpvbmUgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHJlY3QgPSBzZWxmLmxlZnRab29tSGFuZGxlXy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbGVmdEhhbmRsZUNsaWVudFggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoLzI7XG4gICAgcmVjdCA9IHNlbGYucmlnaHRab29tSGFuZGxlXy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcmlnaHRIYW5kbGVDbGllbnRYID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aC8yO1xuICAgIHJldHVybiAoZS5jbGllbnRYID4gbGVmdEhhbmRsZUNsaWVudFggJiYgZS5jbGllbnRYIDwgcmlnaHRIYW5kbGVDbGllbnRYKTtcbiAgfTtcblxuICBvblBhblN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNQYW5uaW5nICYmIGlzTW91c2VJblBhblpvbmUoZSkgJiYgc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpLmlzWm9vbWVkKSB7XG4gICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIGlzUGFubmluZyA9IHRydWU7XG4gICAgICBjbGllbnRYTGFzdCA9IGUuY2xpZW50WDtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgIC8vIFRoZXNlIGV2ZW50cyBhcmUgcmVtb3ZlZCBtYW51YWxseS5cbiAgICAgICAgdXRpbHMuYWRkRXZlbnQodG9wRWxlbSwgJ21vdXNlbW92ZScsIG9uUGFuKTtcbiAgICAgICAgdXRpbHMuYWRkRXZlbnQodG9wRWxlbSwgJ21vdXNldXAnLCBvblBhbkVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIG9uUGFuID0gZnVuY3Rpb24oZSkge1xuICAgIGlmICghaXNQYW5uaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuXG4gICAgdmFyIGRlbFggPSBlLmNsaWVudFggLSBjbGllbnRYTGFzdDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsWCkgPCA0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xpZW50WExhc3QgPSBlLmNsaWVudFg7XG5cbiAgICAvLyBNb3ZlIHJhbmdlIHZpZXdcbiAgICB2YXIgem9vbUhhbmRsZVN0YXR1cyA9IHNlbGYuZ2V0Wm9vbUhhbmRsZVN0YXR1c18oKTtcbiAgICB2YXIgbGVmdEhhbmRsZVBvcyA9IHpvb21IYW5kbGVTdGF0dXMubGVmdEhhbmRsZVBvcztcbiAgICB2YXIgcmlnaHRIYW5kbGVQb3MgPSB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zO1xuICAgIHZhciByYW5nZVNpemUgPSByaWdodEhhbmRsZVBvcyAtIGxlZnRIYW5kbGVQb3M7XG4gICAgaWYgKGxlZnRIYW5kbGVQb3MgKyBkZWxYIDw9IHNlbGYuY2FudmFzUmVjdF8ueCkge1xuICAgICAgbGVmdEhhbmRsZVBvcyA9IHNlbGYuY2FudmFzUmVjdF8ueDtcbiAgICAgIHJpZ2h0SGFuZGxlUG9zID0gbGVmdEhhbmRsZVBvcyArIHJhbmdlU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHJpZ2h0SGFuZGxlUG9zICsgZGVsWCA+PSBzZWxmLmNhbnZhc1JlY3RfLnggKyBzZWxmLmNhbnZhc1JlY3RfLncpIHtcbiAgICAgIHJpZ2h0SGFuZGxlUG9zID0gc2VsZi5jYW52YXNSZWN0Xy54ICsgc2VsZi5jYW52YXNSZWN0Xy53O1xuICAgICAgbGVmdEhhbmRsZVBvcyA9IHJpZ2h0SGFuZGxlUG9zIC0gcmFuZ2VTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0SGFuZGxlUG9zICs9IGRlbFg7XG4gICAgICByaWdodEhhbmRsZVBvcyArPSBkZWxYO1xuICAgIH1cbiAgICB2YXIgaGFsZkhhbmRsZVdpZHRoID0gc2VsZi5sZWZ0Wm9vbUhhbmRsZV8ud2lkdGgvMjtcbiAgICBzZWxmLmxlZnRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKGxlZnRIYW5kbGVQb3MgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgICBzZWxmLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCA9IChyaWdodEhhbmRsZVBvcyAtIGhhbGZIYW5kbGVXaWR0aCkgKyAncHgnO1xuICAgIHNlbGYuZHJhd0ludGVyYWN0aXZlTGF5ZXJfKCk7XG5cbiAgICAvLyBEbyBwYW4gb24gdGhlIGZseS5cbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgZG9QYW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgb25QYW5FbmQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFpc1Bhbm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgdXRpbHMucmVtb3ZlRXZlbnQodG9wRWxlbSwgJ21vdXNlbW92ZScsIG9uUGFuKTtcbiAgICB1dGlscy5yZW1vdmVFdmVudCh0b3BFbGVtLCAnbW91c2V1cCcsIG9uUGFuRW5kKTtcbiAgICAvLyBJZiBvbiBhIHNsb3dlciBkZXZpY2UsIGRvIHBhbiBub3cuXG4gICAgaWYgKCFkeW5hbWljKSB7XG4gICAgICBkb1BhbigpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBkb1BhbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBzZWxmLmlzQ2hhbmdpbmdSYW5nZV8gPSB0cnVlO1xuICAgICAgc2VsZi5keWdyYXBoXy5kYXRlV2luZG93XyA9IHRvWERhdGFXaW5kb3coc2VsZi5nZXRab29tSGFuZGxlU3RhdHVzXygpKTtcbiAgICAgIHNlbGYuZHlncmFwaF8uZHJhd0dyYXBoXyhmYWxzZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNlbGYuaXNDaGFuZ2luZ1JhbmdlXyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBvbkNhbnZhc0hvdmVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChpc1pvb21pbmcgfHwgaXNQYW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjdXJzb3IgPSBpc01vdXNlSW5QYW5ab25lKGUpID8gJ21vdmUnIDogJ2RlZmF1bHQnO1xuICAgIGlmIChjdXJzb3IgIT0gc2VsZi5mZ2NhbnZhc18uc3R5bGUuY3Vyc29yKSB7XG4gICAgICBzZWxmLmZnY2FudmFzXy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxuICB9O1xuXG4gIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUudHlwZSA9PSAndG91Y2hzdGFydCcgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25ab29tU3RhcnQoZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudHlwZSA9PSAndG91Y2htb3ZlJyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmIChvblpvb20oZS50YXJnZXRUb3VjaGVzWzBdKSkge1xuICAgICAgICB1dGlscy5jYW5jZWxFdmVudChlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25ab29tRW5kKGUpO1xuICAgIH1cbiAgfTtcblxuICBvbkNhbnZhc1RvdWNoRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUudHlwZSA9PSAndG91Y2hzdGFydCcgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAob25QYW5TdGFydChlLnRhcmdldFRvdWNoZXNbMF0pKSB7XG4gICAgICAgIHV0aWxzLmNhbmNlbEV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50eXBlID09ICd0b3VjaG1vdmUnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKG9uUGFuKGUudGFyZ2V0VG91Y2hlc1swXSkpIHtcbiAgICAgICAgdXRpbHMuY2FuY2VsRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUGFuRW5kKGUpO1xuICAgIH1cbiAgfTtcblxuICBhZGRUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uKGVsZW0sIGZuKSB7XG4gICAgdmFyIHR5cGVzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZScsICd0b3VjaGNhbmNlbCddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGYuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudChlbGVtLCB0eXBlc1tpXSwgZm4pO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnNldERlZmF1bHRPcHRpb25fKCdpbnRlcmFjdGlvbk1vZGVsJywgRHlncmFwaEludGVyYWN0aW9uLmRyYWdJc1BhbkludGVyYWN0aW9uTW9kZWwpO1xuICB0aGlzLnNldERlZmF1bHRPcHRpb25fKCdwYW5FZGdlRnJhY3Rpb24nLCAwLjAwMDEpO1xuXG4gIHZhciBkcmFnU3RhcnRFdmVudCA9IHdpbmRvdy5vcGVyYSA/ICdtb3VzZWRvd24nIDogJ2RyYWdzdGFydCc7XG4gIHRoaXMuZHlncmFwaF8uYWRkQW5kVHJhY2tFdmVudCh0aGlzLmxlZnRab29tSGFuZGxlXywgZHJhZ1N0YXJ0RXZlbnQsIG9uWm9vbVN0YXJ0KTtcbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMucmlnaHRab29tSGFuZGxlXywgZHJhZ1N0YXJ0RXZlbnQsIG9uWm9vbVN0YXJ0KTtcblxuICB0aGlzLmR5Z3JhcGhfLmFkZEFuZFRyYWNrRXZlbnQodGhpcy5mZ2NhbnZhc18sICdtb3VzZWRvd24nLCBvblBhblN0YXJ0KTtcbiAgdGhpcy5keWdyYXBoXy5hZGRBbmRUcmFja0V2ZW50KHRoaXMuZmdjYW52YXNfLCAnbW91c2Vtb3ZlJywgb25DYW52YXNIb3Zlcik7XG5cbiAgLy8gVG91Y2ggZXZlbnRzXG4gIGlmICh0aGlzLmhhc1RvdWNoSW50ZXJmYWNlXykge1xuICAgIGFkZFRvdWNoRXZlbnRzKHRoaXMubGVmdFpvb21IYW5kbGVfLCBvblpvb21IYW5kbGVUb3VjaEV2ZW50KTtcbiAgICBhZGRUb3VjaEV2ZW50cyh0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8sIG9uWm9vbUhhbmRsZVRvdWNoRXZlbnQpO1xuICAgIGFkZFRvdWNoRXZlbnRzKHRoaXMuZmdjYW52YXNfLCBvbkNhbnZhc1RvdWNoRXZlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEcmF3cyB0aGUgc3RhdGljIGxheWVyIGluIHRoZSBiYWNrZ3JvdW5kIGNhbnZhcy5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZHJhd1N0YXRpY0xheWVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3R4ID0gdGhpcy5iZ2NhbnZhc19jdHhfO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzUmVjdF8udywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmRyYXdNaW5pUGxvdF8oKTtcbiAgfSBjYXRjaChleCkge1xuICAgIGNvbnNvbGUud2FybihleCk7XG4gIH1cblxuICB2YXIgbWFyZ2luID0gMC41O1xuICB0aGlzLmJnY2FudmFzX2N0eF8ubGluZVdpZHRoID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQmFja2dyb3VuZExpbmVXaWR0aCcpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JCYWNrZ3JvdW5kU3Ryb2tlQ29sb3InKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgY3R4LmxpbmVUbyhtYXJnaW4sIHRoaXMuY2FudmFzUmVjdF8uaC1tYXJnaW4pO1xuICBjdHgubGluZVRvKHRoaXMuY2FudmFzUmVjdF8udy1tYXJnaW4sIHRoaXMuY2FudmFzUmVjdF8uaC1tYXJnaW4pO1xuICBjdHgubGluZVRvKHRoaXMuY2FudmFzUmVjdF8udy1tYXJnaW4sIG1hcmdpbik7XG4gIGN0eC5zdHJva2UoKTtcbn07XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRHJhd3MgdGhlIG1pbmkgcGxvdCBpbiB0aGUgYmFja2dyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdNaW5pUGxvdF8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvclBsb3RGaWxsQ29sb3InKTtcbiAgdmFyIGZpbGxHcmFkaWVudFN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yUGxvdEZpbGxHcmFkaWVudENvbG9yJyk7XG4gIHZhciBzdHJva2VTdHlsZSA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvclBsb3RTdHJva2VDb2xvcicpO1xuICBpZiAoIWZpbGxTdHlsZSAmJiAhc3Ryb2tlU3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3RlcFBsb3QgPSB0aGlzLmdldE9wdGlvbl8oJ3N0ZXBQbG90Jyk7XG5cbiAgdmFyIGNvbWJpbmVkU2VyaWVzRGF0YSA9IHRoaXMuY29tcHV0ZUNvbWJpbmVkU2VyaWVzQW5kTGltaXRzXygpO1xuICB2YXIgeVJhbmdlID0gY29tYmluZWRTZXJpZXNEYXRhLnlNYXggLSBjb21iaW5lZFNlcmllc0RhdGEueU1pbjtcblxuICAvLyBEcmF3IHRoZSBtaW5pIHBsb3QuXG4gIHZhciBjdHggPSB0aGlzLmJnY2FudmFzX2N0eF87XG4gIHZhciBtYXJnaW4gPSAwLjU7XG5cbiAgdmFyIHhFeHRyZW1lcyA9IHRoaXMuZHlncmFwaF8ueEF4aXNFeHRyZW1lcygpO1xuICB2YXIgeFJhbmdlID0gTWF0aC5tYXgoeEV4dHJlbWVzWzFdIC0geEV4dHJlbWVzWzBdLCAxLmUtMzApO1xuICB2YXIgeEZhY3QgPSAodGhpcy5jYW52YXNSZWN0Xy53IC0gbWFyZ2luKS94UmFuZ2U7XG4gIHZhciB5RmFjdCA9ICh0aGlzLmNhbnZhc1JlY3RfLmggLSBtYXJnaW4pL3lSYW5nZTtcbiAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXNSZWN0Xy53IC0gbWFyZ2luO1xuICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXNSZWN0Xy5oIC0gbWFyZ2luO1xuXG4gIHZhciBwcmV2WCA9IG51bGwsIHByZXZZID0gbnVsbDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8obWFyZ2luLCBjYW52YXNIZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzRGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGFQb2ludCA9IGNvbWJpbmVkU2VyaWVzRGF0YS5kYXRhW2ldO1xuICAgIHZhciB4ID0gKChkYXRhUG9pbnRbMF0gIT09IG51bGwpID8gKChkYXRhUG9pbnRbMF0gLSB4RXh0cmVtZXNbMF0pKnhGYWN0KSA6IE5hTik7XG4gICAgdmFyIHkgPSAoKGRhdGFQb2ludFsxXSAhPT0gbnVsbCkgPyAoY2FudmFzSGVpZ2h0IC0gKGRhdGFQb2ludFsxXSAtIGNvbWJpbmVkU2VyaWVzRGF0YS55TWluKSp5RmFjdCkgOiBOYU4pO1xuXG4gICAgLy8gU2tpcCBwb2ludHMgdGhhdCBkb24ndCBjaGFuZ2UgdGhlIHgtdmFsdWUuIE92ZXJseSBmaW5lLWdyYWluZWQgcG9pbnRzXG4gICAgLy8gY2FuIGNhdXNlIG1ham9yIHNsb3dkb3ducyB3aXRoIHRoZSBjdHguZmlsbCgpIGNhbGwgYmVsb3cuXG4gICAgaWYgKCFzdGVwUGxvdCAmJiBwcmV2WCAhPT0gbnVsbCAmJiBNYXRoLnJvdW5kKHgpID09IE1hdGgucm91bmQocHJldlgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGaW5pdGUoeCkgJiYgaXNGaW5pdGUoeSkpIHtcbiAgICAgIGlmKHByZXZYID09PSBudWxsKSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0ZXBQbG90KSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgcHJldlkpO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIHByZXZYID0geDtcbiAgICAgIHByZXZZID0geTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihwcmV2WCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RlcFBsb3QpIHtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHByZXZZKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwcmV2WCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldlggPSBwcmV2WSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGN0eC5saW5lVG8oY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcblxuICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgdmFyIGxpbmdyYWQgPSB0aGlzLmJnY2FudmFzX2N0eF8uY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgY2FudmFzSGVpZ2h0KTtcbiAgICBpZiAoZmlsbEdyYWRpZW50U3R5bGUpIHtcbiAgICAgIGxpbmdyYWQuYWRkQ29sb3JTdG9wKDAsIGZpbGxHcmFkaWVudFN0eWxlKTtcbiAgICB9XG4gICAgbGluZ3JhZC5hZGRDb2xvclN0b3AoMSwgZmlsbFN0eWxlKTtcbiAgICB0aGlzLmJnY2FudmFzX2N0eF8uZmlsbFN0eWxlID0gbGluZ3JhZDtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgdGhpcy5iZ2NhbnZhc19jdHhfLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgdGhpcy5iZ2NhbnZhc19jdHhfLmxpbmVXaWR0aCA9IHRoaXMuZ2V0T3B0aW9uXygncmFuZ2VTZWxlY3RvclBsb3RMaW5lV2lkdGgnKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBjb21iaW5lZCBzZXJpZXMgZGF0YSBhbG9uZyB3aXRoIG1pbi9tYXggZm9yIHRoZSBtaW5pIHBsb3QuXG4gKiBUaGUgY29tYmluZWQgc2VyaWVzIGNvbnNpc3RzIG9mIGF2ZXJhZ2VkIHZhbHVlcyBmb3IgYWxsIHNlcmllcy5cbiAqIFdoZW4gc2VyaWVzIGhhdmUgZXJyb3IgYmFycywgdGhlIGVycm9yIGJhcnMgYXJlIGlnbm9yZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGNvbWJpbmVkIHNlcmllcyBhcnJheSwgeW1pbiwgeW1heC5cbiAqL1xucmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUNvbWJpbmVkU2VyaWVzQW5kTGltaXRzXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZyA9IHRoaXMuZHlncmFwaF87XG4gIHZhciBsb2dzY2FsZSA9IHRoaXMuZ2V0T3B0aW9uXygnbG9nc2NhbGUnKTtcbiAgdmFyIGk7XG5cbiAgLy8gU2VsZWN0IHNlcmllcyB0byBjb21iaW5lLiBCeSBkZWZhdWx0LCBhbGwgc2VyaWVzIGFyZSBjb21iaW5lZC5cbiAgdmFyIG51bUNvbHVtbnMgPSBnLm51bUNvbHVtbnMoKTtcbiAgdmFyIGxhYmVscyA9IGcuZ2V0TGFiZWxzKCk7XG4gIHZhciBpbmNsdWRlU2VyaWVzID0gbmV3IEFycmF5KG51bUNvbHVtbnMpO1xuICB2YXIgYW55U2V0ID0gZmFsc2U7XG4gIGZvciAoaSA9IDE7IGkgPCBudW1Db2x1bW5zOyBpKyspIHtcbiAgICB2YXIgaW5jbHVkZSA9IHRoaXMuZ2V0T3B0aW9uXygnc2hvd0luUmFuZ2VTZWxlY3RvcicsIGxhYmVsc1tpXSk7XG4gICAgaW5jbHVkZVNlcmllc1tpXSA9IGluY2x1ZGU7XG4gICAgaWYgKGluY2x1ZGUgIT09IG51bGwpIGFueVNldCA9IHRydWU7ICAvLyBpdCdzIHNldCBleHBsaWNpdGx5IGZvciB0aGlzIHNlcmllc1xuICB9XG4gIGlmICghYW55U2V0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGluY2x1ZGVTZXJpZXMubGVuZ3RoOyBpKyspIGluY2x1ZGVTZXJpZXNbaV0gPSB0cnVlO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgY29tYmluZWQgc2VyaWVzIChhdmVyYWdlIG9mIHNlbGVjdGVkIHNlcmllcyB2YWx1ZXMpLlxuICAvLyBUT0RPKGRhbnZrKTogc2hvcnQtY2lyY3VpdCBpZiB0aGVyZSdzIG9ubHkgb25lIHNlcmllcy5cbiAgdmFyIHJvbGxlZFNlcmllcyA9IFtdO1xuICB2YXIgZGF0YUhhbmRsZXIgPSBnLmRhdGFIYW5kbGVyXztcbiAgdmFyIG9wdGlvbnMgPSBnLmF0dHJpYnV0ZXNfO1xuICBmb3IgKGkgPSAxOyBpIDwgZy5udW1Db2x1bW5zKCk7IGkrKykge1xuICAgIGlmICghaW5jbHVkZVNlcmllc1tpXSkgY29udGludWU7XG4gICAgdmFyIHNlcmllcyA9IGRhdGFIYW5kbGVyLmV4dHJhY3RTZXJpZXMoZy5yYXdEYXRhXywgaSwgb3B0aW9ucyk7XG4gICAgaWYgKGcucm9sbFBlcmlvZCgpID4gMSkge1xuICAgICAgc2VyaWVzID0gZGF0YUhhbmRsZXIucm9sbGluZ0F2ZXJhZ2Uoc2VyaWVzLCBnLnJvbGxQZXJpb2QoKSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcm9sbGVkU2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgfVxuXG4gIHZhciBjb21iaW5lZFNlcmllcyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcm9sbGVkU2VyaWVzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvbGxlZFNlcmllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHkgPSByb2xsZWRTZXJpZXNbal1baV1bMV07XG4gICAgICBpZiAoeSA9PT0gbnVsbCB8fCBpc05hTih5KSkgY29udGludWU7XG4gICAgICBjb3VudCsrO1xuICAgICAgc3VtICs9IHk7XG4gICAgfVxuICAgIGNvbWJpbmVkU2VyaWVzLnB1c2goW3JvbGxlZFNlcmllc1swXVtpXVswXSwgc3VtIC8gY291bnRdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHkgcmFuZ2UuXG4gIHZhciB5TWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgdmFyIHlNYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbWJpbmVkU2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHlWYWwgPSBjb21iaW5lZFNlcmllc1tpXVsxXTtcbiAgICBpZiAoeVZhbCAhPT0gbnVsbCAmJiBpc0Zpbml0ZSh5VmFsKSAmJiAoIWxvZ3NjYWxlIHx8IHlWYWwgPiAwKSkge1xuICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHlWYWwpO1xuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHlWYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnZlcnQgWSBkYXRhIHRvIGxvZyBzY2FsZSBpZiBuZWVkZWQuXG4gIC8vIEFsc28sIGV4cGFuZCB0aGUgWSByYW5nZSB0byBjb21wcmVzcyB0aGUgbWluaSBwbG90IGEgbGl0dGxlLlxuICB2YXIgZXh0cmFQZXJjZW50ID0gMC4yNTtcbiAgaWYgKGxvZ3NjYWxlKSB7XG4gICAgeU1heCA9IHV0aWxzLmxvZzEwKHlNYXgpO1xuICAgIHlNYXggKz0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgeU1pbiA9IHV0aWxzLmxvZzEwKHlNaW4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21iaW5lZFNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tYmluZWRTZXJpZXNbaV1bMV0gPSB1dGlscy5sb2cxMChjb21iaW5lZFNlcmllc1tpXVsxXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB5RXh0cmE7XG4gICAgdmFyIHlSYW5nZSA9IHlNYXggLSB5TWluO1xuICAgIGlmICh5UmFuZ2UgPD0gTnVtYmVyLk1JTl9WQUxVRSkge1xuICAgICAgeUV4dHJhID0geU1heCpleHRyYVBlcmNlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHlFeHRyYSA9IHlSYW5nZSpleHRyYVBlcmNlbnQ7XG4gICAgfVxuICAgIHlNYXggKz0geUV4dHJhO1xuICAgIHlNaW4gLT0geUV4dHJhO1xuICB9XG5cbiAgcmV0dXJuIHtkYXRhOiBjb21iaW5lZFNlcmllcywgeU1pbjogeU1pbiwgeU1heDogeU1heH07XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQbGFjZXMgdGhlIHpvb20gaGFuZGxlcyBpbiB0aGUgcHJvcGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IFggZGF0YSB3aW5kb3cuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnBsYWNlWm9vbUhhbmRsZXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4RXh0cmVtZXMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzRXh0cmVtZXMoKTtcbiAgdmFyIHhXaW5kb3dMaW1pdHMgPSB0aGlzLmR5Z3JhcGhfLnhBeGlzUmFuZ2UoKTtcbiAgdmFyIHhSYW5nZSA9IHhFeHRyZW1lc1sxXSAtIHhFeHRyZW1lc1swXTtcbiAgdmFyIGxlZnRQZXJjZW50ID0gTWF0aC5tYXgoMCwgKHhXaW5kb3dMaW1pdHNbMF0gLSB4RXh0cmVtZXNbMF0pL3hSYW5nZSk7XG4gIHZhciByaWdodFBlcmNlbnQgPSBNYXRoLm1heCgwLCAoeEV4dHJlbWVzWzFdIC0geFdpbmRvd0xpbWl0c1sxXSkveFJhbmdlKTtcbiAgdmFyIGxlZnRDb29yZCA9IHRoaXMuY2FudmFzUmVjdF8ueCArIHRoaXMuY2FudmFzUmVjdF8udypsZWZ0UGVyY2VudDtcbiAgdmFyIHJpZ2h0Q29vcmQgPSB0aGlzLmNhbnZhc1JlY3RfLnggKyB0aGlzLmNhbnZhc1JlY3RfLncqKDEgLSByaWdodFBlcmNlbnQpO1xuICB2YXIgaGFuZGxlVG9wID0gTWF0aC5tYXgodGhpcy5jYW52YXNSZWN0Xy55LCB0aGlzLmNhbnZhc1JlY3RfLnkgKyAodGhpcy5jYW52YXNSZWN0Xy5oIC0gdGhpcy5sZWZ0Wm9vbUhhbmRsZV8uaGVpZ2h0KS8yKTtcbiAgdmFyIGhhbGZIYW5kbGVXaWR0aCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLndpZHRoLzI7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLmxlZnQgPSAobGVmdENvb3JkIC0gaGFsZkhhbmRsZVdpZHRoKSArICdweCc7XG4gIHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IGhhbmRsZVRvcCArICdweCc7XG4gIHRoaXMucmlnaHRab29tSGFuZGxlXy5zdHlsZS5sZWZ0ID0gKHJpZ2h0Q29vcmQgLSBoYWxmSGFuZGxlV2lkdGgpICsgJ3B4JztcbiAgdGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLnRvcCA9IHRoaXMubGVmdFpvb21IYW5kbGVfLnN0eWxlLnRvcDtcblxuICB0aGlzLmxlZnRab29tSGFuZGxlXy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB0aGlzLnJpZ2h0Wm9vbUhhbmRsZV8uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERyYXdzIHRoZSBpbnRlcmFjdGl2ZSBsYXllciBpbiB0aGUgZm9yZWdyb3VuZCBjYW52YXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmRyYXdJbnRlcmFjdGl2ZUxheWVyXyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3R4ID0gdGhpcy5mZ2NhbnZhc19jdHhfO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzUmVjdF8udywgdGhpcy5jYW52YXNSZWN0Xy5oKTtcbiAgdmFyIG1hcmdpbiA9IDE7XG4gIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzUmVjdF8udyAtIG1hcmdpbjtcbiAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzUmVjdF8uaCAtIG1hcmdpbjtcbiAgdmFyIHpvb21IYW5kbGVTdGF0dXMgPSB0aGlzLmdldFpvb21IYW5kbGVTdGF0dXNfKCk7XG5cbiAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yRm9yZWdyb3VuZFN0cm9rZUNvbG9yJyk7XG4gIGN0eC5saW5lV2lkdGggPSB0aGlzLmdldE9wdGlvbl8oJ3JhbmdlU2VsZWN0b3JGb3JlZ3JvdW5kTGluZVdpZHRoJyk7XG4gIGlmICghem9vbUhhbmRsZVN0YXR1cy5pc1pvb21lZCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKG1hcmdpbiwgbWFyZ2luKTtcbiAgICBjdHgubGluZVRvKG1hcmdpbiwgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8od2lkdGgsIG1hcmdpbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZWZ0SGFuZGxlQ2FudmFzUG9zID0gTWF0aC5tYXgobWFyZ2luLCB6b29tSGFuZGxlU3RhdHVzLmxlZnRIYW5kbGVQb3MgLSB0aGlzLmNhbnZhc1JlY3RfLngpO1xuICAgIHZhciByaWdodEhhbmRsZUNhbnZhc1BvcyA9IE1hdGgubWluKHdpZHRoLCB6b29tSGFuZGxlU3RhdHVzLnJpZ2h0SGFuZGxlUG9zIC0gdGhpcy5jYW52YXNSZWN0Xy54KTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNDAsIDI0MCwgMjQwLCAnICsgdGhpcy5nZXRPcHRpb25fKCdyYW5nZVNlbGVjdG9yQWxwaGEnKS50b1N0cmluZygpICsgJyknO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBsZWZ0SGFuZGxlQ2FudmFzUG9zLCB0aGlzLmNhbnZhc1JlY3RfLmgpO1xuICAgIGN0eC5maWxsUmVjdChyaWdodEhhbmRsZUNhbnZhc1BvcywgMCwgdGhpcy5jYW52YXNSZWN0Xy53IC0gcmlnaHRIYW5kbGVDYW52YXNQb3MsIHRoaXMuY2FudmFzUmVjdF8uaCk7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhtYXJnaW4sIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyhsZWZ0SGFuZGxlQ2FudmFzUG9zLCBtYXJnaW4pO1xuICAgIGN0eC5saW5lVG8obGVmdEhhbmRsZUNhbnZhc1BvcywgaGVpZ2h0KTtcbiAgICBjdHgubGluZVRvKHJpZ2h0SGFuZGxlQ2FudmFzUG9zLCBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8ocmlnaHRIYW5kbGVDYW52YXNQb3MsIG1hcmdpbik7XG4gICAgY3R4LmxpbmVUbyh3aWR0aCwgbWFyZ2luKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBoYW5kbGUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB6b29tIGhhbmRsZSBzdGF0dXMuXG4gKi9cbnJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldFpvb21IYW5kbGVTdGF0dXNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmSGFuZGxlV2lkdGggPSB0aGlzLmxlZnRab29tSGFuZGxlXy53aWR0aC8yO1xuICB2YXIgbGVmdEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5sZWZ0Wm9vbUhhbmRsZV8uc3R5bGUubGVmdCkgKyBoYWxmSGFuZGxlV2lkdGg7XG4gIHZhciByaWdodEhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy5yaWdodFpvb21IYW5kbGVfLnN0eWxlLmxlZnQpICsgaGFsZkhhbmRsZVdpZHRoO1xuICByZXR1cm4ge1xuICAgICAgbGVmdEhhbmRsZVBvczogbGVmdEhhbmRsZVBvcyxcbiAgICAgIHJpZ2h0SGFuZGxlUG9zOiByaWdodEhhbmRsZVBvcyxcbiAgICAgIGlzWm9vbWVkOiAobGVmdEhhbmRsZVBvcyAtIDEgPiB0aGlzLmNhbnZhc1JlY3RfLnggfHwgcmlnaHRIYW5kbGVQb3MgKyAxIDwgdGhpcy5jYW52YXNSZWN0Xy54K3RoaXMuY2FudmFzUmVjdF8udylcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJhbmdlU2VsZWN0b3I7XG4iXX0=
